(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var Log = exports.Log = __webpack_require__(1).default;
	var OidcClient = exports.OidcClient = __webpack_require__(2).default;
	var OidcClientSettings = exports.OidcClientSettings = __webpack_require__(3).default;
	var WebStorageStateStore = exports.WebStorageStateStore = __webpack_require__(4).default;
	var InMemoryWebStorage = exports.InMemoryWebStorage = __webpack_require__(40).default;
	var UserManager = exports.UserManager = __webpack_require__(41).default;
	var AccessTokenEvents = exports.AccessTokenEvents = __webpack_require__(50).default;
	var MetadataService = exports.MetadataService = __webpack_require__(7).default;
	var CordovaPopupNavigator = exports.CordovaPopupNavigator = __webpack_require__(57).default;
	var CordovaIFrameNavigator = exports.CordovaIFrameNavigator = __webpack_require__(59).default;
	var CheckSessionIFrame = exports.CheckSessionIFrame = __webpack_require__(55).default;
	var TokenRevocationClient = exports.TokenRevocationClient = __webpack_require__(56).default;
	var SessionMonitor = exports.SessionMonitor = __webpack_require__(54).default;
	var Global = exports.Global = __webpack_require__(5).default;
	var User = exports.User = __webpack_require__(48).default;
	
	exports.default = {
	    Log: Log,
	    OidcClient: OidcClient,
	    OidcClientSettings: OidcClientSettings,
	    WebStorageStateStore: WebStorageStateStore,
	    InMemoryWebStorage: InMemoryWebStorage,
	    UserManager: UserManager,
	    AccessTokenEvents: AccessTokenEvents,
	    MetadataService: MetadataService,
	    CordovaPopupNavigator: CordovaPopupNavigator,
	    CordovaIFrameNavigator: CordovaIFrameNavigator,
	    CheckSessionIFrame: CheckSessionIFrame,
	    TokenRevocationClient: TokenRevocationClient,
	    SessionMonitor: SessionMonitor,
	    Global: Global,
	    User: User
	};

/***/ }),
/* 1 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var nopLogger = {
	    debug: function debug() {},
	    info: function info() {},
	    warn: function warn() {},
	    error: function error() {}
	};
	
	var NONE = 0;
	var ERROR = 1;
	var WARN = 2;
	var INFO = 3;
	var DEBUG = 4;
	
	var logger = void 0;
	var level = void 0;
	
	var Log = function () {
	    function Log() {
	        _classCallCheck(this, Log);
	    }
	
	    _createClass(Log, null, [{
	        key: "reset",
	        value: function reset() {
	            level = DEBUG;
	            logger = console;
	        }
	    }, {
	        key: "debug",
	        value: function debug() {
	            if (level >= DEBUG) {
	                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	                    args[_key] = arguments[_key];
	                }
	
	                logger.debug.apply(logger, Array.from(args));
	            }
	        }
	    }, {
	        key: "info",
	        value: function info() {
	            if (level >= INFO) {
	                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	                    args[_key2] = arguments[_key2];
	                }
	
	                logger.info.apply(logger, Array.from(args));
	            }
	        }
	    }, {
	        key: "warn",
	        value: function warn() {
	            if (level >= WARN) {
	                for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	                    args[_key3] = arguments[_key3];
	                }
	
	                logger.warn.apply(logger, Array.from(args));
	            }
	        }
	    }, {
	        key: "error",
	        value: function error() {
	            if (level >= ERROR) {
	                for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	                    args[_key4] = arguments[_key4];
	                }
	
	                logger.error.apply(logger, Array.from(args));
	            }
	        }
	    }, {
	        key: "NONE",
	        get: function get() {
	            return NONE;
	        }
	    }, {
	        key: "ERROR",
	        get: function get() {
	            return ERROR;
	        }
	    }, {
	        key: "WARN",
	        get: function get() {
	            return WARN;
	        }
	    }, {
	        key: "INFO",
	        get: function get() {
	            return INFO;
	        }
	    }, {
	        key: "DEBUG",
	        get: function get() {
	            return DEBUG;
	        }
	    }, {
	        key: "level",
	        get: function get() {
	            return level;
	        },
	        set: function set(value) {
	            if (NONE <= value && value <= DEBUG) {
	                level = value;
	            } else {
	                throw new Error("Invalid log level");
	            }
	        }
	    }, {
	        key: "logger",
	        get: function get() {
	            return logger;
	        },
	        set: function set(value) {
	            if (!value.debug && value.info) {
	                // just to stay backwards compat. can remove in 2.0
	                value.debug = value.info;
	            }
	
	            if (value.debug && value.info && value.warn && value.error) {
	                logger = value;
	            } else {
	                throw new Error("Invalid logger");
	            }
	        }
	    }]);
	
	    return Log;
	}();
	
	exports.default = Log;
	
	
	Log.reset();

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _OidcClientSettings = __webpack_require__(3);
	
	var _OidcClientSettings2 = _interopRequireDefault(_OidcClientSettings);
	
	var _ErrorResponse = __webpack_require__(10);
	
	var _ErrorResponse2 = _interopRequireDefault(_ErrorResponse);
	
	var _SigninRequest = __webpack_require__(32);
	
	var _SigninRequest2 = _interopRequireDefault(_SigninRequest);
	
	var _SigninResponse = __webpack_require__(37);
	
	var _SigninResponse2 = _interopRequireDefault(_SigninResponse);
	
	var _SignoutRequest = __webpack_require__(38);
	
	var _SignoutRequest2 = _interopRequireDefault(_SignoutRequest);
	
	var _SignoutResponse = __webpack_require__(39);
	
	var _SignoutResponse2 = _interopRequireDefault(_SignoutResponse);
	
	var _SigninState = __webpack_require__(34);
	
	var _SigninState2 = _interopRequireDefault(_SigninState);
	
	var _State = __webpack_require__(35);
	
	var _State2 = _interopRequireDefault(_State);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var OidcClient = function () {
	    function OidcClient() {
	        var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	        _classCallCheck(this, OidcClient);
	
	        if (settings instanceof _OidcClientSettings2.default) {
	            this._settings = settings;
	        } else {
	            this._settings = new _OidcClientSettings2.default(settings);
	        }
	    }
	
	    _createClass(OidcClient, [{
	        key: 'createSigninRequest',
	        value: function createSigninRequest() {
	            var _this = this;
	
	            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	                response_type = _ref.response_type,
	                scope = _ref.scope,
	                redirect_uri = _ref.redirect_uri,
	                data = _ref.data,
	                state = _ref.state,
	                prompt = _ref.prompt,
	                display = _ref.display,
	                max_age = _ref.max_age,
	                ui_locales = _ref.ui_locales,
	                id_token_hint = _ref.id_token_hint,
	                login_hint = _ref.login_hint,
	                acr_values = _ref.acr_values,
	                resource = _ref.resource,
	                request = _ref.request,
	                request_uri = _ref.request_uri,
	                extraQueryParams = _ref.extraQueryParams;
	
	            var stateStore = arguments[1];
	
	            _Log2.default.debug("OidcClient.createSigninRequest");
	
	            var client_id = this._settings.client_id;
	            response_type = response_type || this._settings.response_type;
	            scope = scope || this._settings.scope;
	            redirect_uri = redirect_uri || this._settings.redirect_uri;
	
	            // id_token_hint, login_hint aren't allowed on _settings
	            prompt = prompt || this._settings.prompt;
	            display = display || this._settings.display;
	            max_age = max_age || this._settings.max_age;
	            ui_locales = ui_locales || this._settings.ui_locales;
	            acr_values = acr_values || this._settings.acr_values;
	            resource = resource || this._settings.resource;
	            extraQueryParams = extraQueryParams || this._settings.extraQueryParams;
	
	            var authority = this._settings.authority;
	
	            return this._metadataService.getAuthorizationEndpoint().then(function (url) {
	                _Log2.default.debug("Received authorization endpoint", url);
	
	                var signinRequest = new _SigninRequest2.default({
	                    url: url,
	                    client_id: client_id,
	                    redirect_uri: redirect_uri,
	                    response_type: response_type,
	                    scope: scope,
	                    data: data || state,
	                    authority: authority,
	                    prompt: prompt, display: display, max_age: max_age, ui_locales: ui_locales, id_token_hint: id_token_hint, login_hint: login_hint, acr_values: acr_values,
	                    resource: resource, request: request, request_uri: request_uri, extraQueryParams: extraQueryParams
	                });
	
	                var signinState = signinRequest.state;
	                stateStore = stateStore || _this._stateStore;
	
	                return stateStore.set(signinState.id, signinState.toStorageString()).then(function () {
	                    return signinRequest;
	                });
	            });
	        }
	    }, {
	        key: 'processSigninResponse',
	        value: function processSigninResponse(url, stateStore) {
	            var _this2 = this;
	
	            _Log2.default.debug("OidcClient.processSigninResponse");
	
	            var response = new _SigninResponse2.default(url);
	
	            if (!response.state) {
	                _Log2.default.error("No state in response");
	                return Promise.reject(new Error("No state in response"));
	            }
	
	            stateStore = stateStore || this._stateStore;
	
	            return stateStore.remove(response.state).then(function (storedStateString) {
	                if (!storedStateString) {
	                    _Log2.default.error("No matching state found in storage");
	                    throw new Error("No matching state found in storage");
	                }
	
	                var state = _SigninState2.default.fromStorageString(storedStateString);
	
	                _Log2.default.debug("Received state from storage; validating response");
	                return _this2._validator.validateSigninResponse(state, response);
	            });
	        }
	    }, {
	        key: 'createSignoutRequest',
	        value: function createSignoutRequest() {
	            var _this3 = this;
	
	            var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	                id_token_hint = _ref2.id_token_hint,
	                data = _ref2.data,
	                state = _ref2.state,
	                post_logout_redirect_uri = _ref2.post_logout_redirect_uri;
	
	            var stateStore = arguments[1];
	
	            _Log2.default.debug("OidcClient.createSignoutRequest");
	
	            post_logout_redirect_uri = post_logout_redirect_uri || this._settings.post_logout_redirect_uri;
	
	            return this._metadataService.getEndSessionEndpoint().then(function (url) {
	                if (!url) {
	                    _Log2.default.error("No end session endpoint url returned");
	                    throw new Error("no end session endpoint");
	                }
	
	                _Log2.default.debug("Received end session endpoint", url);
	
	                var request = new _SignoutRequest2.default({
	                    url: url,
	                    id_token_hint: id_token_hint,
	                    post_logout_redirect_uri: post_logout_redirect_uri,
	                    data: data || state
	                });
	
	                var signoutState = request.state;
	                if (signoutState) {
	                    _Log2.default.debug("Signout request has state to persist");
	
	                    stateStore = stateStore || _this3._stateStore;
	                    stateStore.set(signoutState.id, signoutState.toStorageString());
	                }
	
	                return request;
	            });
	        }
	    }, {
	        key: 'processSignoutResponse',
	        value: function processSignoutResponse(url, stateStore) {
	            var _this4 = this;
	
	            _Log2.default.debug("OidcClient.processSignoutResponse");
	
	            var response = new _SignoutResponse2.default(url);
	            if (!response.state) {
	                _Log2.default.debug("No state in response");
	
	                if (response.error) {
	                    _Log2.default.warn("Response was error", response.error);
	                    return Promise.reject(new _ErrorResponse2.default(response));
	                }
	
	                return Promise.resolve(response);
	            }
	
	            var stateKey = response.state;
	
	            stateStore = stateStore || this._stateStore;
	
	            return stateStore.remove(stateKey).then(function (storedStateString) {
	                if (!storedStateString) {
	                    _Log2.default.error("No matching state found in storage");
	                    throw new Error("No matching state found in storage");
	                }
	
	                var state = _State2.default.fromStorageString(storedStateString);
	
	                _Log2.default.debug("Received state from storage; validating response");
	                return _this4._validator.validateSignoutResponse(state, response);
	            });
	        }
	    }, {
	        key: 'clearStaleState',
	        value: function clearStaleState(stateStore) {
	            _Log2.default.debug("OidcClient.clearStaleState");
	
	            stateStore = stateStore || this._stateStore;
	
	            return _State2.default.clearStaleState(stateStore, this.settings.staleStateAge);
	        }
	    }, {
	        key: '_stateStore',
	        get: function get() {
	            return this.settings.stateStore;
	        }
	    }, {
	        key: '_validator',
	        get: function get() {
	            return this.settings.validator;
	        }
	    }, {
	        key: '_metadataService',
	        get: function get() {
	            return this.settings.metadataService;
	        }
	    }, {
	        key: 'settings',
	        get: function get() {
	            return this._settings;
	        }
	    }, {
	        key: 'metadataService',
	        get: function get() {
	            return this._metadataService;
	        }
	    }]);
	
	    return OidcClient;
	}();
	
	exports.default = OidcClient;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _WebStorageStateStore = __webpack_require__(4);
	
	var _WebStorageStateStore2 = _interopRequireDefault(_WebStorageStateStore);
	
	var _ResponseValidator = __webpack_require__(6);
	
	var _ResponseValidator2 = _interopRequireDefault(_ResponseValidator);
	
	var _MetadataService = __webpack_require__(7);
	
	var _MetadataService2 = _interopRequireDefault(_MetadataService);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var OidcMetadataUrlPath = '.well-known/openid-configuration';
	
	var DefaultResponseType = "id_token";
	var DefaultScope = "openid";
	var DefaultStaleStateAge = 60 * 5; // seconds
	var DefaultClockSkewInSeconds = 59;
	
	var OidcClientSettings = function () {
	    function OidcClientSettings() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            authority = _ref.authority,
	            metadataUrl = _ref.metadataUrl,
	            metadata = _ref.metadata,
	            signingKeys = _ref.signingKeys,
	            client_id = _ref.client_id,
	            client_secret = _ref.client_secret,
	            _ref$response_type = _ref.response_type,
	            response_type = _ref$response_type === undefined ? DefaultResponseType : _ref$response_type,
	            _ref$scope = _ref.scope,
	            scope = _ref$scope === undefined ? DefaultScope : _ref$scope,
	            redirect_uri = _ref.redirect_uri,
	            post_logout_redirect_uri = _ref.post_logout_redirect_uri,
	            prompt = _ref.prompt,
	            display = _ref.display,
	            max_age = _ref.max_age,
	            ui_locales = _ref.ui_locales,
	            acr_values = _ref.acr_values,
	            resource = _ref.resource,
	            _ref$filterProtocolCl = _ref.filterProtocolClaims,
	            filterProtocolClaims = _ref$filterProtocolCl === undefined ? true : _ref$filterProtocolCl,
	            _ref$loadUserInfo = _ref.loadUserInfo,
	            loadUserInfo = _ref$loadUserInfo === undefined ? true : _ref$loadUserInfo,
	            _ref$staleStateAge = _ref.staleStateAge,
	            staleStateAge = _ref$staleStateAge === undefined ? DefaultStaleStateAge : _ref$staleStateAge,
	            _ref$clockSkew = _ref.clockSkew,
	            clockSkew = _ref$clockSkew === undefined ? DefaultClockSkewInSeconds : _ref$clockSkew,
	            _ref$stateStore = _ref.stateStore,
	            stateStore = _ref$stateStore === undefined ? new _WebStorageStateStore2.default() : _ref$stateStore,
	            _ref$ResponseValidato = _ref.ResponseValidatorCtor,
	            ResponseValidatorCtor = _ref$ResponseValidato === undefined ? _ResponseValidator2.default : _ref$ResponseValidato,
	            _ref$MetadataServiceC = _ref.MetadataServiceCtor,
	            MetadataServiceCtor = _ref$MetadataServiceC === undefined ? _MetadataService2.default : _ref$MetadataServiceC,
	            _ref$extraQueryParams = _ref.extraQueryParams,
	            extraQueryParams = _ref$extraQueryParams === undefined ? {} : _ref$extraQueryParams;
	
	        _classCallCheck(this, OidcClientSettings);
	
	        this._authority = authority;
	        this._metadataUrl = metadataUrl;
	        this._metadata = metadata;
	        this._signingKeys = signingKeys;
	
	        this._client_id = client_id;
	        this._client_secret = client_secret;
	        this._response_type = response_type;
	        this._scope = scope;
	        this._redirect_uri = redirect_uri;
	        this._post_logout_redirect_uri = post_logout_redirect_uri;
	
	        this._prompt = prompt;
	        this._display = display;
	        this._max_age = max_age;
	        this._ui_locales = ui_locales;
	        this._acr_values = acr_values;
	        this._resource = resource;
	
	        this._filterProtocolClaims = !!filterProtocolClaims;
	        this._loadUserInfo = !!loadUserInfo;
	        this._staleStateAge = staleStateAge;
	        this._clockSkew = clockSkew;
	
	        this._stateStore = stateStore;
	        this._validator = new ResponseValidatorCtor(this);
	        this._metadataService = new MetadataServiceCtor(this);
	
	        this._extraQueryParams = (typeof extraQueryParams === 'undefined' ? 'undefined' : _typeof(extraQueryParams)) === 'object' ? extraQueryParams : {};
	    }
	
	    // client config
	
	
	    _createClass(OidcClientSettings, [{
	        key: 'client_id',
	        get: function get() {
	            return this._client_id;
	        },
	        set: function set(value) {
	            if (!this._client_id) {
	                // one-time set only
	                this._client_id = value;
	            } else {
	                _Log2.default.error("client_id has already been assigned.");
	                throw new Error("client_id has already been assigned.");
	            }
	        }
	    }, {
	        key: 'client_secret',
	        get: function get() {
	            return this._client_secret;
	        }
	    }, {
	        key: 'response_type',
	        get: function get() {
	            return this._response_type;
	        }
	    }, {
	        key: 'scope',
	        get: function get() {
	            return this._scope;
	        }
	    }, {
	        key: 'redirect_uri',
	        get: function get() {
	            return this._redirect_uri;
	        }
	    }, {
	        key: 'post_logout_redirect_uri',
	        get: function get() {
	            return this._post_logout_redirect_uri;
	        }
	
	        // optional protocol params
	
	    }, {
	        key: 'prompt',
	        get: function get() {
	            return this._prompt;
	        }
	    }, {
	        key: 'display',
	        get: function get() {
	            return this._display;
	        }
	    }, {
	        key: 'max_age',
	        get: function get() {
	            return this._max_age;
	        }
	    }, {
	        key: 'ui_locales',
	        get: function get() {
	            return this._ui_locales;
	        }
	    }, {
	        key: 'acr_values',
	        get: function get() {
	            return this._acr_values;
	        }
	    }, {
	        key: 'resource',
	        get: function get() {
	            return this._resource;
	        }
	
	        // metadata
	
	    }, {
	        key: 'authority',
	        get: function get() {
	            return this._authority;
	        },
	        set: function set(value) {
	            if (!this._authority) {
	                // one-time set only
	                this._authority = value;
	            } else {
	                _Log2.default.error("authority has already been assigned.");
	                throw new Error("authority has already been assigned.");
	            }
	        }
	    }, {
	        key: 'metadataUrl',
	        get: function get() {
	            if (!this._metadataUrl) {
	                this._metadataUrl = this.authority;
	
	                if (this._metadataUrl && this._metadataUrl.indexOf(OidcMetadataUrlPath) < 0) {
	                    if (this._metadataUrl[this._metadataUrl.length - 1] !== '/') {
	                        this._metadataUrl += '/';
	                    }
	                    this._metadataUrl += OidcMetadataUrlPath;
	                }
	            }
	
	            return this._metadataUrl;
	        }
	
	        // settable/cachable metadata values
	
	    }, {
	        key: 'metadata',
	        get: function get() {
	            return this._metadata;
	        },
	        set: function set(value) {
	            this._metadata = value;
	        }
	    }, {
	        key: 'signingKeys',
	        get: function get() {
	            return this._signingKeys;
	        },
	        set: function set(value) {
	            this._signingKeys = value;
	        }
	
	        // behavior flags
	
	    }, {
	        key: 'filterProtocolClaims',
	        get: function get() {
	            return this._filterProtocolClaims;
	        }
	    }, {
	        key: 'loadUserInfo',
	        get: function get() {
	            return this._loadUserInfo;
	        }
	    }, {
	        key: 'staleStateAge',
	        get: function get() {
	            return this._staleStateAge;
	        }
	    }, {
	        key: 'clockSkew',
	        get: function get() {
	            return this._clockSkew;
	        }
	    }, {
	        key: 'stateStore',
	        get: function get() {
	            return this._stateStore;
	        }
	    }, {
	        key: 'validator',
	        get: function get() {
	            return this._validator;
	        }
	    }, {
	        key: 'metadataService',
	        get: function get() {
	            return this._metadataService;
	        }
	
	        // extra query params
	
	    }, {
	        key: 'extraQueryParams',
	        get: function get() {
	            return this._extraQueryParams;
	        },
	        set: function set(value) {
	            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	                this._extraQueryParams = value;
	            } else {
	                this._extraQueryParams = {};
	            }
	        }
	    }]);
	
	    return OidcClientSettings;
	}();
	
	exports.default = OidcClientSettings;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _Global = __webpack_require__(5);
	
	var _Global2 = _interopRequireDefault(_Global);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var WebStorageStateStore = function () {
	    function WebStorageStateStore() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            _ref$prefix = _ref.prefix,
	            prefix = _ref$prefix === undefined ? "oidc." : _ref$prefix,
	            _ref$store = _ref.store,
	            store = _ref$store === undefined ? _Global2.default.localStorage : _ref$store;
	
	        _classCallCheck(this, WebStorageStateStore);
	
	        this._store = store;
	        this._prefix = prefix;
	    }
	
	    _createClass(WebStorageStateStore, [{
	        key: 'set',
	        value: function set(key, value) {
	            _Log2.default.debug("WebStorageStateStore.set", key);
	
	            key = this._prefix + key;
	
	            this._store.setItem(key, value);
	
	            return Promise.resolve();
	        }
	    }, {
	        key: 'get',
	        value: function get(key) {
	            _Log2.default.debug("WebStorageStateStore.get", key);
	
	            key = this._prefix + key;
	
	            var item = this._store.getItem(key);
	
	            return Promise.resolve(item);
	        }
	    }, {
	        key: 'remove',
	        value: function remove(key) {
	            _Log2.default.debug("WebStorageStateStore.remove", key);
	
	            key = this._prefix + key;
	
	            var item = this._store.getItem(key);
	            this._store.removeItem(key);
	
	            return Promise.resolve(item);
	        }
	    }, {
	        key: 'getAllKeys',
	        value: function getAllKeys() {
	            _Log2.default.debug("WebStorageStateStore.getAllKeys");
	
	            var keys = [];
	
	            for (var index = 0; index < this._store.length; index++) {
	                var key = this._store.key(index);
	
	                if (key.indexOf(this._prefix) === 0) {
	                    keys.push(key.substr(this._prefix.length));
	                }
	            }
	
	            return Promise.resolve(keys);
	        }
	    }]);
	
	    return WebStorageStateStore;
	}();
	
	exports.default = WebStorageStateStore;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var timer = {
	    setInterval: function (_setInterval) {
	        function setInterval(_x, _x2) {
	            return _setInterval.apply(this, arguments);
	        }
	
	        setInterval.toString = function () {
	            return _setInterval.toString();
	        };
	
	        return setInterval;
	    }(function (cb, duration) {
	        return setInterval(cb, duration);
	    }),
	    clearInterval: function (_clearInterval) {
	        function clearInterval(_x3) {
	            return _clearInterval.apply(this, arguments);
	        }
	
	        clearInterval.toString = function () {
	            return _clearInterval.toString();
	        };
	
	        return clearInterval;
	    }(function (handle) {
	        return clearInterval(handle);
	    })
	};
	
	var testing = false;
	var request = null;
	
	var Global = function () {
	    function Global() {
	        _classCallCheck(this, Global);
	    }
	
	    _createClass(Global, null, [{
	        key: "_testing",
	        value: function _testing() {
	            testing = true;
	        }
	    }, {
	        key: "setXMLHttpRequest",
	        value: function setXMLHttpRequest(newRequest) {
	            request = newRequest;
	        }
	    }, {
	        key: "location",
	        get: function get() {
	            if (!testing) {
	                return location;
	            }
	        }
	    }, {
	        key: "localStorage",
	        get: function get() {
	            if (!testing) {
	                return localStorage;
	            }
	        }
	    }, {
	        key: "sessionStorage",
	        get: function get() {
	            if (!testing) {
	                return sessionStorage;
	            }
	        }
	    }, {
	        key: "XMLHttpRequest",
	        get: function get() {
	            if (!testing) {
	                return request || XMLHttpRequest;
	            }
	        }
	    }, {
	        key: "timer",
	        get: function get() {
	            if (!testing) {
	                return timer;
	            }
	        }
	    }]);
	
	    return Global;
	}();
	
	exports.default = Global;
	;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _MetadataService = __webpack_require__(7);
	
	var _MetadataService2 = _interopRequireDefault(_MetadataService);
	
	var _UserInfoService = __webpack_require__(9);
	
	var _UserInfoService2 = _interopRequireDefault(_UserInfoService);
	
	var _ErrorResponse = __webpack_require__(10);
	
	var _ErrorResponse2 = _interopRequireDefault(_ErrorResponse);
	
	var _JoseUtil = __webpack_require__(11);
	
	var _JoseUtil2 = _interopRequireDefault(_JoseUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ProtocolClaims = ["nonce", "at_hash", "iat", "nbf", "exp", "aud", "iss", "c_hash"];
	
	var ResponseValidator = function () {
	    function ResponseValidator(settings) {
	        var MetadataServiceCtor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _MetadataService2.default;
	        var UserInfoServiceCtor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _UserInfoService2.default;
	        var joseUtil = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _JoseUtil2.default;
	
	        _classCallCheck(this, ResponseValidator);
	
	        if (!settings) {
	            _Log2.default.error("No settings passed to ResponseValidator");
	            throw new Error("settings");
	        }
	
	        this._settings = settings;
	        this._metadataService = new MetadataServiceCtor(this._settings);
	        this._userInfoService = new UserInfoServiceCtor(this._settings);
	        this._joseUtil = joseUtil;
	    }
	
	    _createClass(ResponseValidator, [{
	        key: 'validateSigninResponse',
	        value: function validateSigninResponse(state, response) {
	            var _this = this;
	
	            _Log2.default.debug("ResponseValidator.validateSigninResponse");
	
	            return this._processSigninParams(state, response).then(function (response) {
	                _Log2.default.debug("state processed");
	                return _this._validateTokens(state, response).then(function (response) {
	                    _Log2.default.debug("tokens validated");
	                    _Log2.default.debug('------');
	                    _Log2.default.debug(response);
	                    return _this._processClaims(response).then(function (response) {
	                        _Log2.default.debug("claims processed");
	                        return response;
	                    });
	                });
	            });
	        }
	    }, {
	        key: 'validateSignoutResponse',
	        value: function validateSignoutResponse(state, response) {
	            _Log2.default.debug("ResponseValidator.validateSignoutResponse");
	
	            if (state.id !== response.state) {
	                _Log2.default.error("State does not match");
	                return Promise.reject(new Error("State does not match"));
	            }
	
	            // now that we know the state matches, take the stored data
	            // and set it into the response so callers can get their state
	            // this is important for both success & error outcomes
	            _Log2.default.debug("state validated");
	            response.state = state.data;
	
	            if (response.error) {
	                _Log2.default.warn("Response was error", response.error);
	                return Promise.reject(new _ErrorResponse2.default(response));
	            }
	
	            return Promise.resolve(response);
	        }
	    }, {
	        key: '_processSigninParams',
	        value: function _processSigninParams(state, response) {
	            _Log2.default.debug("ResponseValidator._processSigninParams");
	
	            if (state.id !== response.state) {
	                _Log2.default.error("State does not match");
	                return Promise.reject(new Error("State does not match"));
	            }
	
	            if (!state.client_id) {
	                _Log2.default.error("No client_id on state");
	                return Promise.reject(new Error("No client_id on state"));
	            }
	
	            if (!state.authority) {
	                _Log2.default.error("No authority on state");
	                return Promise.reject(new Error("No authority on state"));
	            }
	
	            // this allows the authority to be loaded from the signin state
	            if (!this._settings.authority) {
	                this._settings.authority = state.authority;
	            }
	            // ensure we're using the correct authority if the authority is not loaded from signin state
	            else if (this._settings.authority && this._settings.authority !== state.authority) {
	                    _Log2.default.error("authority mismatch on settings vs. signin state");
	                    return Promise.reject(new Error("authority mismatch on settings vs. signin state"));
	                }
	            // this allows the client_id to be loaded from the signin state
	            if (!this._settings.client_id) {
	                this._settings.client_id = state.client_id;
	            }
	            // ensure we're using the correct client_id if the client_id is not loaded from signin state
	            else if (this._settings.client_id && this._settings.client_id !== state.client_id) {
	                    _Log2.default.error("client_id mismatch on settings vs. signin state");
	                    return Promise.reject(new Error("client_id mismatch on settings vs. signin state"));
	                }
	
	            // now that we know the state matches, take the stored data
	            // and set it into the response so callers can get their state
	            // this is important for both success & error outcomes
	            _Log2.default.debug("state validated");
	            response.state = state.data;
	
	            if (response.error) {
	                _Log2.default.warn("Response was error", response.error);
	                return Promise.reject(new _ErrorResponse2.default(response));
	            }
	
	            if (state.nonce && !response.id_token) {
	                _Log2.default.error("Expecting id_token in response");
	                return Promise.reject(new Error("No id_token in response"));
	            }
	
	            if (!state.nonce && response.id_token) {
	                _Log2.default.error("Not expecting id_token in response");
	                return Promise.reject(new Error("Unexpected id_token in response"));
	            }
	
	            return Promise.resolve(response);
	        }
	    }, {
	        key: '_processClaims',
	        value: function _processClaims(response) {
	            var _this2 = this;
	
	            _Log2.default.debug("ResponseValidator._processClaims");
	
	            if (response.isOpenIdConnect) {
	                _Log2.default.debug("response is OIDC, processing claims");
	
	                response.profile = this._filterProtocolClaims(response.profile);
	
	                if (this._settings.loadUserInfo && response.access_token) {
	                    _Log2.default.debug("loading user info");
	
	                    return this._userInfoService.getClaims(response.access_token).then(function (claims) {
	                        _Log2.default.debug("user info claims received from user info endpoint");
	
	                        if (claims.sub !== response.profile.sub) {
	                            _Log2.default.error("sub from user info endpoint does not match sub in access_token");
	                            return Promise.reject(new Error("sub from user info endpoint does not match sub in access_token"));
	                        }
	
	                        response.profile = _this2._mergeClaims(response.profile, claims);
	                        _Log2.default.debug("user info claims received, updated profile:", response.profile);
	
	                        return response;
	                    });
	                } else {
	                    _Log2.default.debug("not loading user info");
	                }
	            } else {
	                _Log2.default.debug("response is not OIDC, not processing claims");
	            }
	
	            return Promise.resolve(response);
	        }
	    }, {
	        key: '_mergeClaims',
	        value: function _mergeClaims(claims1, claims2) {
	            var result = Object.assign({}, claims1);
	
	            for (var name in claims2) {
	                var values = claims2[name];
	                if (!Array.isArray(values)) {
	                    values = [values];
	                }
	
	                for (var i = 0; i < values.length; i++) {
	                    var value = values[i];
	                    if (!result[name]) {
	                        result[name] = value;
	                    } else if (Array.isArray(result[name])) {
	                        if (result[name].indexOf(value) < 0) {
	                            result[name].push(value);
	                        }
	                    } else if (result[name] !== value) {
	                        result[name] = [result[name], value];
	                    }
	                }
	            }
	
	            return result;
	        }
	    }, {
	        key: '_filterProtocolClaims',
	        value: function _filterProtocolClaims(claims) {
	            _Log2.default.debug("ResponseValidator._filterProtocolClaims, incoming claims:", claims);
	
	            var result = Object.assign({}, claims);
	
	            if (this._settings._filterProtocolClaims) {
	                ProtocolClaims.forEach(function (type) {
	                    delete result[type];
	                });
	
	                _Log2.default.debug("protocol claims filtered", result);
	            } else {
	                _Log2.default.debug("protocol claims not filtered");
	            }
	
	            return result;
	        }
	    }, {
	        key: '_validateTokens',
	        value: function _validateTokens(state, response) {
	            _Log2.default.debug("ResponseValidator._validateTokens");
	
	            if (response.id_token) {
	
	                if (response.access_token) {
	                    _Log2.default.debug("Validating id_token and access_token");
	                    return this._validateIdTokenAndAccessToken(state, response);
	                }
	
	                _Log2.default.debug("Validating id_token");
	                return this._validateIdToken(state, response);
	            }
	
	            _Log2.default.debug("No id_token to validate");
	            return Promise.resolve(response);
	        }
	    }, {
	        key: '_validateIdTokenAndAccessToken',
	        value: function _validateIdTokenAndAccessToken(state, response) {
	            var _this3 = this;
	
	            _Log2.default.debug("ResponseValidator._validateIdTokenAndAccessToken");
	
	            return this._validateIdToken(state, response).then(function (response) {
	                return _this3._validateAccessToken(response);
	            });
	        }
	    }, {
	        key: '_validateIdToken',
	        value: function _validateIdToken(state, response) {
	            var _this4 = this;
	
	            _Log2.default.debug("ResponseValidator._validateIdToken");
	
	            if (!state.nonce) {
	                _Log2.default.error("No nonce on state");
	                return Promise.reject(new Error("No nonce on state"));
	            }
	
	            var jwt = this._joseUtil.parseJwt(response.id_token);
	            if (!jwt || !jwt.header || !jwt.payload) {
	                _Log2.default.error("Failed to parse id_token", jwt);
	                return Promise.reject(new Error("Failed to parse id_token"));
	            }
	
	            if (state.nonce !== jwt.payload.nonce) {
	                _Log2.default.error("Invalid nonce in id_token");
	                return Promise.reject(new Error("Invalid nonce in id_token"));
	            }
	
	            var kid = jwt.header.kid;
	
	            return this._metadataService.getIssuer().then(function (issuer) {
	                _Log2.default.debug("Received issuer");
	
	                return _this4._metadataService.getSigningKeys().then(function (keys) {
	                    if (!keys) {
	                        _Log2.default.error("No signing keys from metadata");
	                        return Promise.reject(new Error("No signing keys from metadata"));
	                    }
	
	                    _Log2.default.debug("Received signing keys");
	                    var key = void 0;
	                    if (!kid) {
	                        keys = _this4._filterByAlg(keys, jwt.header.alg);
	
	                        if (keys.length > 1) {
	                            _Log2.default.error("No kid found in id_token and more than one key found in metadata");
	                            return Promise.reject(new Error("No kid found in id_token and more than one key found in metadata"));
	                        } else {
	                            // kid is mandatory only when there are multiple keys in the referenced JWK Set document
	                            // see http://openid.net/specs/openid-connect-core-1_0.html#Signing
	                            key = keys[0];
	                        }
	                    } else {
	                        key = keys.filter(function (key) {
	                            return key.kid === kid;
	                        })[0];
	                    }
	
	                    if (!key) {
	                        _Log2.default.error("No key matching kid or alg found in signing keys");
	                        return Promise.reject(new Error("No key matching kid or alg found in signing keys"));
	                    }
	
	                    var audience = state.client_id;
	
	                    var clockSkewInSeconds = _this4._settings.clockSkew;
	                    _Log2.default.debug("Validaing JWT; using clock skew (in seconds) of: ", clockSkewInSeconds);
	
	                    return _this4._joseUtil.validateJwt(response.id_token, key, issuer, audience, clockSkewInSeconds).then(function () {
	                        _Log2.default.debug("JWT validation successful");
	
	                        if (!jwt.payload.sub) {
	                            _Log2.default.error("No sub present in id_token");
	                            return Promise.reject(new Error("No sub present in id_token"));
	                        }
	
	                        response.profile = jwt.payload;
	
	                        return response;
	                    });
	                });
	            });
	        }
	    }, {
	        key: '_filterByAlg',
	        value: function _filterByAlg(keys, alg) {
	            _Log2.default.debug("ResponseValidator._filterByAlg", alg);
	
	            var kty = null;
	            if (alg.startsWith("RS")) {
	                kty = "RSA";
	            } else if (alg.startsWith("PS")) {
	                kty = "PS";
	            } else if (alg.startsWith("ES")) {
	                kty = "EC";
	            } else {
	                _Log2.default.debug("alg not supported: ", alg);
	                return [];
	            }
	
	            _Log2.default.debug("Looking for keys that match kty: ", kty);
	
	            keys = keys.filter(function (key) {
	                return key.kty === kty;
	            });
	
	            _Log2.default.debug("Number of keys that match kty: ", kty, keys.length);
	
	            return keys;
	        }
	    }, {
	        key: '_validateAccessToken',
	        value: function _validateAccessToken(response) {
	            _Log2.default.debug("ResponseValidator._validateAccessToken");
	
	            if (!response.profile) {
	                _Log2.default.error("No profile loaded from id_token");
	                return Promise.reject(new Error("No profile loaded from id_token"));
	            }
	
	            if (!response.profile.at_hash) {
	                _Log2.default.error("No at_hash in id_token");
	                return Promise.reject(new Error("No at_hash in id_token"));
	            }
	
	            if (!response.id_token) {
	                _Log2.default.error("No id_token");
	                return Promise.reject(new Error("No id_token"));
	            }
	
	            var jwt = this._joseUtil.parseJwt(response.id_token);
	            if (!jwt || !jwt.header) {
	                _Log2.default.error("Failed to parse id_token", jwt);
	                return Promise.reject(new Error("Failed to parse id_token"));
	            }
	
	            var hashAlg = jwt.header.alg;
	            if (!hashAlg || hashAlg.length !== 5) {
	                _Log2.default.error("Unsupported alg:", hashAlg);
	                return Promise.reject(new Error("Unsupported alg: " + hashAlg));
	            }
	
	            var hashBits = hashAlg.substr(2, 3);
	            if (!hashBits) {
	                _Log2.default.error("Unsupported alg:", hashAlg, hashBits);
	                return Promise.reject(new Error("Unsupported alg: " + hashAlg));
	            }
	
	            hashBits = parseInt(hashBits);
	            if (hashBits !== 256 && hashBits !== 384 && hashBits !== 512) {
	                _Log2.default.error("Unsupported alg:", hashAlg, hashBits);
	                return Promise.reject(new Error("Unsupported alg: " + hashAlg));
	            }
	
	            var sha = "sha" + hashBits;
	            var hash = this._joseUtil.hashString(response.access_token, sha);
	            if (!hash) {
	                _Log2.default.error("access_token hash failed:", sha);
	                return Promise.reject(new Error("Failed to validate at_hash"));
	            }
	
	            var left = hash.substr(0, hash.length / 2);
	            var left_b64u = this._joseUtil.hexToBase64Url(left);
	            if (left_b64u !== response.profile.at_hash) {
	                _Log2.default.error("Failed to validate at_hash", left_b64u, response.profile.at_hash);
	                return Promise.reject(new Error("Failed to validate at_hash"));
	            }
	
	            return Promise.resolve(response);
	        }
	    }]);
	
	    return ResponseValidator;
	}();
	
	exports.default = ResponseValidator;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _JsonService = __webpack_require__(8);
	
	var _JsonService2 = _interopRequireDefault(_JsonService);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var OidcMetadataUrlPath = '.well-known/openid-configuration';
	
	var MetadataService = function () {
	    function MetadataService(settings) {
	        var JsonServiceCtor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _JsonService2.default;
	
	        _classCallCheck(this, MetadataService);
	
	        if (!settings) {
	            _Log2.default.error("No settings passed to MetadataService");
	            throw new Error("settings");
	        }
	
	        this._settings = settings;
	        this._jsonService = new JsonServiceCtor();
	    }
	
	    _createClass(MetadataService, [{
	        key: 'getMetadata',
	        value: function getMetadata() {
	            var _this = this;
	
	            _Log2.default.debug("MetadataService.getMetadata");
	
	            if (this._settings.metadata) {
	                _Log2.default.debug("Returning metadata from settings");
	                return Promise.resolve(this._settings.metadata);
	            }
	
	            if (!this.metadataUrl) {
	                _Log2.default.error("No authority or metadataUrl configured on settings");
	                return Promise.reject(new Error("No authority or metadataUrl configured on settings"));
	            }
	
	            _Log2.default.debug("getting metadata from", this.metadataUrl);
	
	            return this._jsonService.getJson(this.metadataUrl).then(function (metadata) {
	                _Log2.default.debug("json received");
	                _this._settings.metadata = metadata;
	                return metadata;
	            });
	        }
	    }, {
	        key: 'getIssuer',
	        value: function getIssuer() {
	            _Log2.default.debug("MetadataService.getIssuer");
	            return this._getMetadataProperty("issuer");
	        }
	    }, {
	        key: 'getAuthorizationEndpoint',
	        value: function getAuthorizationEndpoint() {
	            _Log2.default.debug("MetadataService.getAuthorizationEndpoint");
	            return this._getMetadataProperty("authorization_endpoint");
	        }
	    }, {
	        key: 'getUserInfoEndpoint',
	        value: function getUserInfoEndpoint() {
	            _Log2.default.debug("MetadataService.getUserInfoEndpoint");
	            return this._getMetadataProperty("userinfo_endpoint");
	        }
	    }, {
	        key: 'getTokenEndpoint',
	        value: function getTokenEndpoint() {
	            _Log2.default.debug("MetadataService.getTokenEndpoint");
	            return this._getMetadataProperty("token_endpoint", true);
	        }
	    }, {
	        key: 'getCheckSessionIframe',
	        value: function getCheckSessionIframe() {
	            _Log2.default.debug("MetadataService.getCheckSessionIframe");
	            return this._getMetadataProperty("check_session_iframe", true);
	        }
	    }, {
	        key: 'getEndSessionEndpoint',
	        value: function getEndSessionEndpoint() {
	            _Log2.default.debug("MetadataService.getEndSessionEndpoint");
	            return this._getMetadataProperty("end_session_endpoint", true);
	        }
	    }, {
	        key: 'getRevocationEndpoint',
	        value: function getRevocationEndpoint() {
	            _Log2.default.debug("MetadataService.getRevocationEndpoint");
	            return this._getMetadataProperty("revocation_endpoint", true);
	        }
	    }, {
	        key: '_getMetadataProperty',
	        value: function _getMetadataProperty(name) {
	            var optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	            _Log2.default.debug("MetadataService._getMetadataProperty", name);
	
	            return this.getMetadata().then(function (metadata) {
	                _Log2.default.debug("metadata recieved");
	
	                if (metadata[name] === undefined) {
	
	                    if (optional === true) {
	                        _Log2.default.warn("Metadata does not contain optional property " + name);
	                        return undefined;
	                    } else {
	                        _Log2.default.error("Metadata does not contain property " + name);
	                        throw new Error("Metadata does not contain property " + name);
	                    }
	                }
	
	                return metadata[name];
	            });
	        }
	    }, {
	        key: 'getSigningKeys',
	        value: function getSigningKeys() {
	            var _this2 = this;
	
	            _Log2.default.debug("MetadataService.getSigningKeys");
	
	            if (this._settings.signingKeys) {
	                _Log2.default.debug("Returning signingKeys from settings");
	                return Promise.resolve(this._settings.signingKeys);
	            }
	
	            return this._getMetadataProperty("jwks_uri").then(function (jwks_uri) {
	                _Log2.default.debug("jwks_uri received", jwks_uri);
	
	                return _this2._jsonService.getJson(jwks_uri).then(function (keySet) {
	                    _Log2.default.debug("key set received", keySet);
	
	                    if (!keySet.keys) {
	                        _Log2.default.error("Missing keys on keyset");
	                        throw new Error("Missing keys on keyset");
	                    }
	
	                    _this2._settings.signingKeys = keySet.keys;
	                    return _this2._settings.signingKeys;
	                });
	            });
	        }
	    }, {
	        key: 'metadataUrl',
	        get: function get() {
	            if (!this._metadataUrl) {
	                if (this._settings.metadataUrl) {
	                    this._metadataUrl = this._settings.metadataUrl;
	                } else {
	                    this._metadataUrl = this._settings.authority;
	
	                    if (this._metadataUrl && this._metadataUrl.indexOf(OidcMetadataUrlPath) < 0) {
	                        if (this._metadataUrl[this._metadataUrl.length - 1] !== '/') {
	                            this._metadataUrl += '/';
	                        }
	                        this._metadataUrl += OidcMetadataUrlPath;
	                    }
	                }
	            }
	
	            return this._metadataUrl;
	        }
	    }]);
	
	    return MetadataService;
	}();
	
	exports.default = MetadataService;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _Global = __webpack_require__(5);
	
	var _Global2 = _interopRequireDefault(_Global);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var JsonService = function () {
	    function JsonService() {
	        var XMLHttpRequestCtor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _Global2.default.XMLHttpRequest;
	
	        _classCallCheck(this, JsonService);
	
	        this._XMLHttpRequest = XMLHttpRequestCtor;
	    }
	
	    _createClass(JsonService, [{
	        key: 'getJson',
	        value: function getJson(url, token) {
	            var _this = this;
	
	            _Log2.default.debug("JsonService.getJson", url);
	
	            if (!url) {
	                _Log2.default.error("No url passed");
	                throw new Error("url");
	            }
	
	            return new Promise(function (resolve, reject) {
	
	                var req = new _this._XMLHttpRequest();
	                req.open('GET', url);
	
	                req.onload = function () {
	                    _Log2.default.debug("HTTP response received, status", req.status);
	
	                    if (req.status === 200) {
	                        try {
	                            resolve(JSON.parse(req.responseText));
	                        } catch (e) {
	                            _Log2.default.error("Error parsing JSON response", e.message);
	                            reject(e);
	                        }
	                    } else {
	                        reject(Error(req.statusText + " (" + req.status + ")"));
	                    }
	                };
	
	                req.onerror = function () {
	                    _Log2.default.error("network error");
	                    reject(Error("Network Error"));
	                };
	
	                if (token) {
	                    _Log2.default.debug("token passed, setting Authorization header");
	                    req.setRequestHeader("Authorization", "Bearer " + token);
	                }
	
	                req.send();
	            });
	        }
	    }]);
	
	    return JsonService;
	}();
	
	exports.default = JsonService;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _JsonService = __webpack_require__(8);
	
	var _JsonService2 = _interopRequireDefault(_JsonService);
	
	var _MetadataService = __webpack_require__(7);
	
	var _MetadataService2 = _interopRequireDefault(_MetadataService);
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var UserInfoService = function () {
	    function UserInfoService(settings) {
	        var JsonServiceCtor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _JsonService2.default;
	        var MetadataServiceCtor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _MetadataService2.default;
	
	        _classCallCheck(this, UserInfoService);
	
	        if (!settings) {
	            _Log2.default.error("No settings passed to UserInfoService");
	            throw new Error("settings");
	        }
	
	        this._settings = settings;
	        this._jsonService = new JsonServiceCtor();
	        this._metadataService = new MetadataServiceCtor(this._settings);
	    }
	
	    _createClass(UserInfoService, [{
	        key: 'getClaims',
	        value: function getClaims(token) {
	            var _this = this;
	
	            _Log2.default.debug("UserInfoService.getClaims");
	
	            if (!token) {
	                _Log2.default.error("No token passed");
	                return Promise.reject(new Error("A token is required"));
	            }
	
	            return this._metadataService.getUserInfoEndpoint().then(function (url) {
	                _Log2.default.debug("received userinfo url", url);
	
	                return _this._jsonService.getJson(url, token).then(function (claims) {
	                    _Log2.default.debug("claims received", claims);
	                    return claims;
	                });
	            });
	        }
	    }]);
	
	    return UserInfoService;
	}();
	
	exports.default = UserInfoService;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var ErrorResponse = function (_Error) {
	    _inherits(ErrorResponse, _Error);
	
	    function ErrorResponse() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            error = _ref.error,
	            error_description = _ref.error_description,
	            error_uri = _ref.error_uri,
	            state = _ref.state;
	
	        _classCallCheck(this, ErrorResponse);
	
	        if (!error) {
	            _Log2.default.error("No error passed to ErrorResponse");
	            throw new Error("error");
	        }
	
	        var _this = _possibleConstructorReturn(this, (ErrorResponse.__proto__ || Object.getPrototypeOf(ErrorResponse)).call(this, error_description || error));
	
	        _this.name = "ErrorResponse";
	
	        _this.error = error;
	        _this.error_description = error_description;
	        _this.error_uri = error_uri;
	
	        _this.state = state;
	        return _this;
	    }
	
	    return ErrorResponse;
	}(Error);
	
	exports.default = ErrorResponse;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	// import { jws, KEYUTIL as KeyUtil, X509, crypto, hextob64u } from 'jsrsasign';
	
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _idtokenVerifier = __webpack_require__(12);
	
	var _idtokenVerifier2 = _interopRequireDefault(_idtokenVerifier);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var AllowedSigningAlgs = ['RS256', 'RS384', 'RS512', 'PS256', 'PS384', 'PS512', 'ES256', 'ES384', 'ES512'];
	
	var JoseUtil = function () {
	    function JoseUtil() {
	        _classCallCheck(this, JoseUtil);
	    }
	
	    _createClass(JoseUtil, null, [{
	        key: 'parseJwt',
	        value: function parseJwt(jwt) {
	            _Log2.default.debug("JoseUtil.parseJwt");
	            try {
	                var parameters = {
	                    expectedAlg: 'RS256'
	                };
	                var idTokenVerifier = new _idtokenVerifier2.default(parameters);
	
	                var token = idTokenVerifier.decode(jwt);
	                if (token.header && token.payload) {
	                    return {
	                        header: token.header,
	                        payload: token.payload
	                    };
	                }
	            } catch (e) {
	                _Log2.default.error(e);
	            }
	        }
	    }, {
	        key: 'validateJwt',
	        value: function validateJwt(jwt, key, issuer, audience, clockSkew, now, cb) {
	            _Log2.default.debug("JoseUtil.validateJwt");
	
	            try {
	
	                // if (key.kty === "RSA") {
	                //     if (key.e && key.n) {
	                //         key = KeyUtil.getKey(key);
	                //     }
	                //     else if (key.x5c && key.x5c.length) {
	                //         key = KeyUtil.getKey(X509.getPublicKeyFromCertPEM(key.x5c[0]));
	                //     }
	                //     else {
	                //         Log.error("RSA key missing key material", key);
	                //         return Promise.reject(new Error("RSA key missing key material"));
	                //     }
	                // }
	                // else if (key.kty === "EC") {
	                //     if (key.crv && key.x && key.y) {
	                //         key = KeyUtil.getKey(key);
	                //     }
	                //     else {
	                //         Log.error("EC key missing key material", key);
	                //         return Promise.reject(new Error("EC key missing key material"));
	                //     }
	                // }
	                // else {
	                //     Log.error("Unsupported key type", key && key.kty);
	                //     return Promise.reject(new Error("Unsupported key type: " + key && key.kty));
	                // }
	                //
	                return JoseUtil._validateJwt(jwt, key, issuer, audience, clockSkew, now);
	            } catch (e) {
	                _Log2.default.error(e && e.message || e);
	                return Promise.reject("JWT validation failed");
	            }
	        }
	    }, {
	        key: '_validateJwt',
	        value: function _validateJwt(jwt, key, issuer, audience, clockSkew, now) {
	            _Log2.default.debug("JoseUtil._validateJwt");
	            var parameters = {
	                issuer: issuer,
	                audience: audience,
	                leeway: clockSkew,
	                expectedAlg: 'RS256'
	            };
	            var idTokenVerifier = new _idtokenVerifier2.default(parameters);
	
	            if (!clockSkew) {
	                clockSkew = 0;
	            }
	
	            if (!now) {
	                now = parseInt(Date.now() / 1000);
	            }
	
	            var payload = JoseUtil.parseJwt(jwt).payload;
	
	            if (!payload.iss) {
	                _Log2.default.error("issuer was not provided");
	                return Promise.reject(new Error("issuer was not provided"));
	            }
	            if (payload.iss !== issuer) {
	                _Log2.default.error("Invalid issuer in token", payload.iss);
	                return Promise.reject(new Error("Invalid issuer in token: " + payload.iss));
	            }
	
	            if (!payload.aud) {
	                _Log2.default.error("aud was not provided");
	                return Promise.reject(new Error("aud was not provided"));
	            }
	            var validAudience = payload.aud === audience || Array.isArray(payload.aud) && payload.aud.indexOf(audience) >= 0;
	            if (!validAudience) {
	                _Log2.default.error("Invalid audience in token", payload.aud);
	                return Promise.reject(new Error("Invalid audience in token: " + payload.aud));
	            }
	
	            var lowerNow = now + clockSkew;
	            var upperNow = now - clockSkew;
	
	            if (!payload.iat) {
	                _Log2.default.error("iat was not provided");
	                return Promise.reject(new Error("iat was not provided"));
	            }
	            if (lowerNow < payload.iat) {
	                _Log2.default.error("iat is in the future", payload.iat);
	                return Promise.reject(new Error("iat is in the future: " + payload.iat));
	            }
	
	            if (payload.nbf && lowerNow < payload.nbf) {
	                _Log2.default.error("nbf is in the future", payload.nbf);
	                return Promise.reject(new Error("nbf is in the future: " + payload.nbf));
	            }
	
	            if (!payload.exp) {
	                _Log2.default.error("exp was not provided");
	                return Promise.reject(new Error("exp was not provided"));
	            }
	            if (payload.exp < upperNow) {
	                _Log2.default.error("exp is in the past", payload.exp);
	                return Promise.reject(new Error("exp is in the past:" + payload.exp));
	            }
	
	            try {
	                // if (!jws.JWS.verify(jwt, key, AllowedSigningAlgs)) {
	                if (!idTokenVerifier.verify(jwt)) {
	                    return Promise.reject(new Error("signature validation failed"));
	                }
	            } catch (e) {
	                _Log2.default.error(e && e.message || e);
	                return Promise.reject(new Error("signature validation failed"));
	            }
	
	            return Promise.resolve();
	        }
	    }, {
	        key: 'hashString',
	        value: function hashString(value, alg) {
	            _Log2.default.debug("JoseUtil.hashString", value, alg);
	            try {
	                return crypto.Util.hashString(value, alg);
	            } catch (e) {
	                _Log2.default.error(e);
	            }
	        }
	    }, {
	        key: 'hexToBase64Url',
	        value: function hexToBase64Url(value) {
	            _Log2.default.debug("JoseUtil.hexToBase64Url", value);
	            try {
	                return hextob64u(value);
	            } catch (e) {
	                _Log2.default.error(e);
	            }
	        }
	    }]);
	
	    return JoseUtil;
	}();
	
	exports.default = JoseUtil;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var sha256 = __webpack_require__(13);
	var cryptoBase64 = __webpack_require__(15);
	var cryptoHex = __webpack_require__(16);
	
	var RSAVerifier = __webpack_require__(17);
	var base64 = __webpack_require__(19);
	var jwks = __webpack_require__(21);
	var error = __webpack_require__(30);
	var DummyCache = __webpack_require__(31);
	var supportedAlgs = ['RS256'];
	
	/**
	 * Creates a new id_token verifier
	 * @constructor
	 * @param {Object} parameters
	 * @param {String} parameters.issuer name of the issuer of the token
	 * that should match the `iss` claim in the id_token
	 * @param {String} parameters.audience identifies the recipients that the JWT is intended for
	 * and should match the `aud` claim
	 * @param {Object} [parameters.jwksCache] cache for JSON Web Token Keys. By default it has no cache
	 * @param {String} [parameters.jwksURI] A valid, direct URI to fetch the JSON Web Key Set (JWKS).
	 * @param {String} [parameters.expectedAlg='RS256'] algorithm in which the id_token was signed
	 * and will be used to validate
	 * @param {number} [parameters.leeway=0] number of seconds that the clock can be out of sync
	 * while validating expiration of the id_token
	 */
	function IdTokenVerifier(parameters) {
	    var options = parameters || {};
	
	    this.jwksCache = options.jwksCache || new DummyCache();
	    this.expectedAlg = options.expectedAlg || 'RS256';
	    this.issuer = options.issuer;
	    this.audience = options.audience;
	    this.leeway = options.leeway || 0;
	    this.__disableExpirationCheck = options.__disableExpirationCheck || false;
	    this.jwksURI = options.jwksURI;
	
	    if (this.leeway < 0 || this.leeway > 60) {
	        throw new error.ConfigurationError('The leeway should be positive and lower than a minute.');
	    }
	
	    if (supportedAlgs.indexOf(this.expectedAlg) === -1) {
	        throw new error.ConfigurationError('Algorithm ' + this.expectedAlg + ' is not supported. (Expected algs: [' + supportedAlgs.join(',') + '])');
	    }
	}
	
	/**
	 * @param {Error} [err] error returned if the verify cannot be performed
	 * @param {boolean} [status] if the token is valid or not
	 */
	
	/**
	 * Verifies an id_token
	 *
	 * It will validate:
	 * - signature according to the algorithm configured in the verifier.
	 * - if nonce is present and matches the one provided
	 * - if `iss` and `aud` claims matches the configured issuer and audience
	 * - if token is not expired and valid (if the `nbf` claim is in the past)
	 *
	 * @method verify
	 * @param {String} token id_token to verify
	 * @param {String} [nonce] nonce value that should match the one in the id_token claims
	 */
	IdTokenVerifier.prototype.verify = function (token, nonce) {
	    var jwt = this.decode(token);
	
	    if (jwt instanceof Error) {
	        return Promise.reject(jwt);
	    }
	
	    /* eslint-disable vars-on-top */
	    var headAndPayload = jwt.encoded.header + '.' + jwt.encoded.payload;
	    var signature = base64.decodeToHEX(jwt.encoded.signature);
	
	    var alg = jwt.header.alg;
	    var kid = jwt.header.kid;
	
	    var aud = jwt.payload.aud;
	    var iss = jwt.payload.iss;
	    var exp = jwt.payload.exp;
	    var nbf = jwt.payload.nbf;
	    var tnonce = jwt.payload.nonce || null;
	    /* eslint-enable vars-on-top */
	
	    if (this.issuer !== iss) {
	        return Promise.reject(new error.TokenValidationError('Issuer ' + iss + ' is not valid.'), false);
	    }
	
	    if (this.audience !== aud) {
	        return Promise.reject(new error.TokenValidationError('Audience ' + aud + ' is not valid.'), false);
	    }
	
	    if (this.expectedAlg !== alg) {
	        return Promise.reject(new error.TokenValidationError('Algorithm ' + alg + ' is not supported. (Expected algs: [' + supportedAlgs.join(',') + '])'), false);
	    }
	
	    if (tnonce !== nonce) {
	        return Promise.reject(new error.TokenValidationError('Nonce does not match.'), false);
	    }
	
	    var expirationError = this.verifyExpAndNbf(exp, nbf); // eslint-disable-line vars-on-top
	
	    if (expirationError) {
	        return expirationError, false;
	    }
	
	    return this.getRsaVerifier(iss, kid).then(function (rsaVerifier) {
	        if (rsaVerifier.verify(headAndPayload, signature)) {
	            return Promise.resolve(jwt.payload);
	        }
	        return Promise.reject(new error.TokenValidationError('Invalid signature.'));
	    }).catch(function (e) {
	        return Promise.reject(e);
	    });
	};
	
	/**
	 * Verifies that the `exp` and `nbf` claims are valid in the current moment.
	 *
	 * @method verifyExpAndNbf
	 * @param {String} exp value of `exp` claim
	 * @param {String} nbf value of `nbf` claim
	 * @return {boolean} if token is valid according to `exp` and `nbf`
	 */
	IdTokenVerifier.prototype.verifyExpAndNbf = function (exp, nbf) {
	    var now = new Date();
	    var expDate = new Date(0);
	    var nbfDate = new Date(0);
	
	    if (this.__disableExpirationCheck) {
	        return null;
	    }
	
	    expDate.setUTCSeconds(exp + this.leeway);
	
	    if (now > expDate) {
	        return new error.TokenValidationError('Expired token.');
	    }
	
	    if (typeof nbf === 'undefined') {
	        return null;
	    }
	    nbfDate.setUTCSeconds(nbf - this.leeway);
	    if (now < nbfDate) {
	        return new error.TokenValidationError('The token is not valid until later in the future. ' + 'Please check your computed clock.');
	    }
	
	    return null;
	};
	
	/**
	 * Verifies that the `exp` and `iat` claims are valid in the current moment.
	 *
	 * @method verifyExpAndIat
	 * @param {String} exp value of `exp` claim
	 * @param {String} iat value of `iat` claim
	 * @return {boolean} if token is valid according to `exp` and `iat`
	 */
	IdTokenVerifier.prototype.verifyExpAndIat = function (exp, iat) {
	    var now = new Date();
	    var expDate = new Date(0);
	    var iatDate = new Date(0);
	
	    if (this.__disableExpirationCheck) {
	        return null;
	    }
	
	    expDate.setUTCSeconds(exp + this.leeway);
	
	    if (now > expDate) {
	        return new error.TokenValidationError('Expired token.');
	    }
	
	    iatDate.setUTCSeconds(iat - this.leeway);
	
	    if (now < iatDate) {
	        return new error.TokenValidationError('The token was issued in the future. ' + 'Please check your computed clock.');
	    }
	    return null;
	};
	
	IdTokenVerifier.prototype.getRsaVerifier = function (iss, kid) {
	    var _this = this;
	    var cachekey = iss + kid;
	
	    if (!this.jwksCache.has(cachekey)) {
	        jwks.getJWKS({
	            jwksURI: this.jwksURI,
	            iss: iss,
	            kid: kid
	        }).then(function (keyInfo) {
	            _this.jwksCache.set(cachekey, keyInfo);
	            return Promise.resolve(null, new RSAVerifier(keyInfo.modulus, keyInfo.exp));
	        }).catch(function (e) {
	            Promise.reject(e);
	        });
	    } else {
	        var keyInfo = this.jwksCache.get(cachekey); // eslint-disable-line vars-on-top
	        Promise.resolve(null, new RSAVerifier(keyInfo.modulus, keyInfo.exp));
	    }
	};
	
	/**
	 * @typedef DecodedToken
	 * @type {Object}
	 * @property {Object} header - content of the JWT header.
	 * @property {Object} payload - token claims.
	 * @property {Object} encoded - encoded parts of the token.
	 */
	
	/**
	 * Decodes a well formed JWT without any verification
	 *
	 * @method decode
	 * @param {String} token decodes the token
	 * @return {DecodedToken} if token is valid according to `exp` and `nbf`
	 */
	IdTokenVerifier.prototype.decode = function (token) {
	    var parts = token.split('.');
	    var header;
	    var payload;
	
	    if (parts.length !== 3) {
	        return new error.TokenValidationError('Cannot decode a malformed JWT');
	    }
	
	    try {
	        header = JSON.parse(base64.decodeToString(parts[0]));
	        payload = JSON.parse(base64.decodeToString(parts[1]));
	    } catch (e) {
	        return new error.TokenValidationError('Token header or payload is not valid JSON');
	    }
	
	    return {
	        header: header,
	        payload: payload,
	        encoded: {
	            header: parts[0],
	            payload: parts[1],
	            signature: parts[2]
	        }
	    };
	};
	
	/**
	 * @callback validateAccessTokenCallback
	 * @param {Error} [err] error returned if the validation cannot be performed
	 * or the token is invalid. If there is no error, then the access_token is valid.
	 */
	
	/**
	 * Validates an access_token based on {@link http://openid.net/specs/openid-connect-core-1_0.html#ImplicitTokenValidation}.
	 * The id_token from where the alg and atHash parameters are taken,
	 * should be decoded and verified before using thisfunction
	 *
	 * @method validateAccessToken
	 * @param {String} access_token the access_token
	 * @param {String} alg The algorithm defined in the header of the
	 * previously verified id_token under the "alg" claim.
	 * @param {String} atHash The "at_hash" value included in the payload
	 * of the previously verified id_token.
	 * @param {validateAccessTokenCallback} cb callback used to notify the results of the validation.
	 */
	IdTokenVerifier.prototype.validateAccessToken = function (accessToken, alg, atHash) {
	    if (this.expectedAlg !== alg) {
	        return Promise.reject(new error.TokenValidationError('Algorithm ' + alg + ' is not supported. (Expected alg: ' + this.expectedAlg + ')'));
	    }
	    var sha256AccessToken = sha256(accessToken);
	    var hashToHex = cryptoHex.stringify(sha256AccessToken);
	    var hashToHexFirstHalf = hashToHex.substring(0, hashToHex.length / 2);
	    var hashFirstHalfWordArray = cryptoHex.parse(hashToHexFirstHalf);
	    var hashFirstHalfBase64 = cryptoBase64.stringify(hashFirstHalfWordArray);
	    var hashFirstHalfBase64SafeUrl = base64.base64ToBase64Url(hashFirstHalfBase64);
	    if (hashFirstHalfBase64SafeUrl !== atHash) {
	        return Promise.reject(new error.TokenValidationError('Invalid access_token'));
	    }
	    return Promise.resolve(null);
	};
	
	module.exports = IdTokenVerifier;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	;(function (root, factory) {
		if (( false ? "undefined" : _typeof(exports)) === "object") {
			// CommonJS
			module.exports = exports = factory(__webpack_require__(14));
		} else if (true) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(14)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			// Global (browser)
			factory(root.CryptoJS);
		}
	})(undefined, function (CryptoJS) {
	
		(function (Math) {
			// Shortcuts
			var C = CryptoJS;
			var C_lib = C.lib;
			var WordArray = C_lib.WordArray;
			var Hasher = C_lib.Hasher;
			var C_algo = C.algo;
	
			// Initialization and round constants tables
			var H = [];
			var K = [];
	
			// Compute constants
			(function () {
				function isPrime(n) {
					var sqrtN = Math.sqrt(n);
					for (var factor = 2; factor <= sqrtN; factor++) {
						if (!(n % factor)) {
							return false;
						}
					}
	
					return true;
				}
	
				function getFractionalBits(n) {
					return (n - (n | 0)) * 0x100000000 | 0;
				}
	
				var n = 2;
				var nPrime = 0;
				while (nPrime < 64) {
					if (isPrime(n)) {
						if (nPrime < 8) {
							H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
						}
						K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
	
						nPrime++;
					}
	
					n++;
				}
			})();
	
			// Reusable object
			var W = [];
	
			/**
	   * SHA-256 hash algorithm.
	   */
			var SHA256 = C_algo.SHA256 = Hasher.extend({
				_doReset: function _doReset() {
					this._hash = new WordArray.init(H.slice(0));
				},
	
				_doProcessBlock: function _doProcessBlock(M, offset) {
					// Shortcut
					var H = this._hash.words;
	
					// Working variables
					var a = H[0];
					var b = H[1];
					var c = H[2];
					var d = H[3];
					var e = H[4];
					var f = H[5];
					var g = H[6];
					var h = H[7];
	
					// Computation
					for (var i = 0; i < 64; i++) {
						if (i < 16) {
							W[i] = M[offset + i] | 0;
						} else {
							var gamma0x = W[i - 15];
							var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
	
							var gamma1x = W[i - 2];
							var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
	
							W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
						}
	
						var ch = e & f ^ ~e & g;
						var maj = a & b ^ a & c ^ b & c;
	
						var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
						var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
	
						var t1 = h + sigma1 + ch + K[i] + W[i];
						var t2 = sigma0 + maj;
	
						h = g;
						g = f;
						f = e;
						e = d + t1 | 0;
						d = c;
						c = b;
						b = a;
						a = t1 + t2 | 0;
					}
	
					// Intermediate hash value
					H[0] = H[0] + a | 0;
					H[1] = H[1] + b | 0;
					H[2] = H[2] + c | 0;
					H[3] = H[3] + d | 0;
					H[4] = H[4] + e | 0;
					H[5] = H[5] + f | 0;
					H[6] = H[6] + g | 0;
					H[7] = H[7] + h | 0;
				},
	
				_doFinalize: function _doFinalize() {
					// Shortcuts
					var data = this._data;
					var dataWords = data.words;
	
					var nBitsTotal = this._nDataBytes * 8;
					var nBitsLeft = data.sigBytes * 8;
	
					// Add padding
					dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
					dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
					dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
					data.sigBytes = dataWords.length * 4;
	
					// Hash final blocks
					this._process();
	
					// Return final computed hash
					return this._hash;
				},
	
				clone: function clone() {
					var clone = Hasher.clone.call(this);
					clone._hash = this._hash.clone();
	
					return clone;
				}
			});
	
			/**
	   * Shortcut function to the hasher's object interface.
	   *
	   * @param {WordArray|string} message The message to hash.
	   *
	   * @return {WordArray} The hash.
	   *
	   * @static
	   *
	   * @example
	   *
	   *     var hash = CryptoJS.SHA256('message');
	   *     var hash = CryptoJS.SHA256(wordArray);
	   */
			C.SHA256 = Hasher._createHelper(SHA256);
	
			/**
	   * Shortcut function to the HMAC's object interface.
	   *
	   * @param {WordArray|string} message The message to hash.
	   * @param {WordArray|string} key The secret key.
	   *
	   * @return {WordArray} The HMAC.
	   *
	   * @static
	   *
	   * @example
	   *
	   *     var hmac = CryptoJS.HmacSHA256(message, key);
	   */
			C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
		})(Math);
	
		return CryptoJS.SHA256;
	});

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	;(function (root, factory) {
		if (( false ? "undefined" : _typeof(exports)) === "object") {
			// CommonJS
			module.exports = exports = factory();
		} else if (true) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			// Global (browser)
			root.CryptoJS = factory();
		}
	})(undefined, function () {
	
		/**
	  * CryptoJS core components.
	  */
		var CryptoJS = CryptoJS || function (Math, undefined) {
			/*
	   * Local polyfil of Object.create
	   */
			var create = Object.create || function () {
				function F() {};
	
				return function (obj) {
					var subtype;
	
					F.prototype = obj;
	
					subtype = new F();
	
					F.prototype = null;
	
					return subtype;
				};
			}();
	
			/**
	   * CryptoJS namespace.
	   */
			var C = {};
	
			/**
	   * Library namespace.
	   */
			var C_lib = C.lib = {};
	
			/**
	   * Base object for prototypal inheritance.
	   */
			var Base = C_lib.Base = function () {
	
				return {
					/**
	     * Creates a new object that inherits from this object.
	     *
	     * @param {Object} overrides Properties to copy into the new object.
	     *
	     * @return {Object} The new object.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var MyType = CryptoJS.lib.Base.extend({
	     *         field: 'value',
	     *
	     *         method: function () {
	     *         }
	     *     });
	     */
					extend: function extend(overrides) {
						// Spawn
						var subtype = create(this);
	
						// Augment
						if (overrides) {
							subtype.mixIn(overrides);
						}
	
						// Create default initializer
						if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
							subtype.init = function () {
								subtype.$super.init.apply(this, arguments);
							};
						}
	
						// Initializer's prototype is the subtype object
						subtype.init.prototype = subtype;
	
						// Reference supertype
						subtype.$super = this;
	
						return subtype;
					},
	
					/**
	     * Extends this object and runs the init method.
	     * Arguments to create() will be passed to init().
	     *
	     * @return {Object} The new object.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var instance = MyType.create();
	     */
					create: function create() {
						var instance = this.extend();
						instance.init.apply(instance, arguments);
	
						return instance;
					},
	
					/**
	     * Initializes a newly created object.
	     * Override this method to add some logic when your objects are created.
	     *
	     * @example
	     *
	     *     var MyType = CryptoJS.lib.Base.extend({
	     *         init: function () {
	     *             // ...
	     *         }
	     *     });
	     */
					init: function init() {},
	
					/**
	     * Copies properties into this object.
	     *
	     * @param {Object} properties The properties to mix in.
	     *
	     * @example
	     *
	     *     MyType.mixIn({
	     *         field: 'value'
	     *     });
	     */
					mixIn: function mixIn(properties) {
						for (var propertyName in properties) {
							if (properties.hasOwnProperty(propertyName)) {
								this[propertyName] = properties[propertyName];
							}
						}
	
						// IE won't copy toString using the loop above
						if (properties.hasOwnProperty('toString')) {
							this.toString = properties.toString;
						}
					},
	
					/**
	     * Creates a copy of this object.
	     *
	     * @return {Object} The clone.
	     *
	     * @example
	     *
	     *     var clone = instance.clone();
	     */
					clone: function clone() {
						return this.init.prototype.extend(this);
					}
				};
			}();
	
			/**
	   * An array of 32-bit words.
	   *
	   * @property {Array} words The array of 32-bit words.
	   * @property {number} sigBytes The number of significant bytes in this word array.
	   */
			var WordArray = C_lib.WordArray = Base.extend({
				/**
	    * Initializes a newly created word array.
	    *
	    * @param {Array} words (Optional) An array of 32-bit words.
	    * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	    *
	    * @example
	    *
	    *     var wordArray = CryptoJS.lib.WordArray.create();
	    *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	    *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	    */
				init: function init(words, sigBytes) {
					words = this.words = words || [];
	
					if (sigBytes != undefined) {
						this.sigBytes = sigBytes;
					} else {
						this.sigBytes = words.length * 4;
					}
				},
	
				/**
	    * Converts this word array to a string.
	    *
	    * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	    *
	    * @return {string} The stringified word array.
	    *
	    * @example
	    *
	    *     var string = wordArray + '';
	    *     var string = wordArray.toString();
	    *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	    */
				toString: function toString(encoder) {
					return (encoder || Hex).stringify(this);
				},
	
				/**
	    * Concatenates a word array to this word array.
	    *
	    * @param {WordArray} wordArray The word array to append.
	    *
	    * @return {WordArray} This word array.
	    *
	    * @example
	    *
	    *     wordArray1.concat(wordArray2);
	    */
				concat: function concat(wordArray) {
					// Shortcuts
					var thisWords = this.words;
					var thatWords = wordArray.words;
					var thisSigBytes = this.sigBytes;
					var thatSigBytes = wordArray.sigBytes;
	
					// Clamp excess bits
					this.clamp();
	
					// Concat
					if (thisSigBytes % 4) {
						// Copy one byte at a time
						for (var i = 0; i < thatSigBytes; i++) {
							var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
							thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
						}
					} else {
						// Copy one word at a time
						for (var i = 0; i < thatSigBytes; i += 4) {
							thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
						}
					}
					this.sigBytes += thatSigBytes;
	
					// Chainable
					return this;
				},
	
				/**
	    * Removes insignificant bits.
	    *
	    * @example
	    *
	    *     wordArray.clamp();
	    */
				clamp: function clamp() {
					// Shortcuts
					var words = this.words;
					var sigBytes = this.sigBytes;
	
					// Clamp
					words[sigBytes >>> 2] &= 0xffffffff << 32 - sigBytes % 4 * 8;
					words.length = Math.ceil(sigBytes / 4);
				},
	
				/**
	    * Creates a copy of this word array.
	    *
	    * @return {WordArray} The clone.
	    *
	    * @example
	    *
	    *     var clone = wordArray.clone();
	    */
				clone: function clone() {
					var clone = Base.clone.call(this);
					clone.words = this.words.slice(0);
	
					return clone;
				},
	
				/**
	    * Creates a word array filled with random bytes.
	    *
	    * @param {number} nBytes The number of random bytes to generate.
	    *
	    * @return {WordArray} The random word array.
	    *
	    * @static
	    *
	    * @example
	    *
	    *     var wordArray = CryptoJS.lib.WordArray.random(16);
	    */
				random: function random(nBytes) {
					var words = [];
	
					var r = function r(m_w) {
						var m_w = m_w;
						var m_z = 0x3ade68b1;
						var mask = 0xffffffff;
	
						return function () {
							m_z = 0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10) & mask;
							m_w = 0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10) & mask;
							var result = (m_z << 0x10) + m_w & mask;
							result /= 0x100000000;
							result += 0.5;
							return result * (Math.random() > .5 ? 1 : -1);
						};
					};
	
					for (var i = 0, rcache; i < nBytes; i += 4) {
						var _r = r((rcache || Math.random()) * 0x100000000);
	
						rcache = _r() * 0x3ade67b7;
						words.push(_r() * 0x100000000 | 0);
					}
	
					return new WordArray.init(words, nBytes);
				}
			});
	
			/**
	   * Encoder namespace.
	   */
			var C_enc = C.enc = {};
	
			/**
	   * Hex encoding strategy.
	   */
			var Hex = C_enc.Hex = {
				/**
	    * Converts a word array to a hex string.
	    *
	    * @param {WordArray} wordArray The word array.
	    *
	    * @return {string} The hex string.
	    *
	    * @static
	    *
	    * @example
	    *
	    *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	    */
				stringify: function stringify(wordArray) {
					// Shortcuts
					var words = wordArray.words;
					var sigBytes = wordArray.sigBytes;
	
					// Convert
					var hexChars = [];
					for (var i = 0; i < sigBytes; i++) {
						var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
						hexChars.push((bite >>> 4).toString(16));
						hexChars.push((bite & 0x0f).toString(16));
					}
	
					return hexChars.join('');
				},
	
				/**
	    * Converts a hex string to a word array.
	    *
	    * @param {string} hexStr The hex string.
	    *
	    * @return {WordArray} The word array.
	    *
	    * @static
	    *
	    * @example
	    *
	    *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	    */
				parse: function parse(hexStr) {
					// Shortcut
					var hexStrLength = hexStr.length;
	
					// Convert
					var words = [];
					for (var i = 0; i < hexStrLength; i += 2) {
						words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
					}
	
					return new WordArray.init(words, hexStrLength / 2);
				}
			};
	
			/**
	   * Latin1 encoding strategy.
	   */
			var Latin1 = C_enc.Latin1 = {
				/**
	    * Converts a word array to a Latin1 string.
	    *
	    * @param {WordArray} wordArray The word array.
	    *
	    * @return {string} The Latin1 string.
	    *
	    * @static
	    *
	    * @example
	    *
	    *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	    */
				stringify: function stringify(wordArray) {
					// Shortcuts
					var words = wordArray.words;
					var sigBytes = wordArray.sigBytes;
	
					// Convert
					var latin1Chars = [];
					for (var i = 0; i < sigBytes; i++) {
						var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
						latin1Chars.push(String.fromCharCode(bite));
					}
	
					return latin1Chars.join('');
				},
	
				/**
	    * Converts a Latin1 string to a word array.
	    *
	    * @param {string} latin1Str The Latin1 string.
	    *
	    * @return {WordArray} The word array.
	    *
	    * @static
	    *
	    * @example
	    *
	    *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	    */
				parse: function parse(latin1Str) {
					// Shortcut
					var latin1StrLength = latin1Str.length;
	
					// Convert
					var words = [];
					for (var i = 0; i < latin1StrLength; i++) {
						words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << 24 - i % 4 * 8;
					}
	
					return new WordArray.init(words, latin1StrLength);
				}
			};
	
			/**
	   * UTF-8 encoding strategy.
	   */
			var Utf8 = C_enc.Utf8 = {
				/**
	    * Converts a word array to a UTF-8 string.
	    *
	    * @param {WordArray} wordArray The word array.
	    *
	    * @return {string} The UTF-8 string.
	    *
	    * @static
	    *
	    * @example
	    *
	    *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	    */
				stringify: function stringify(wordArray) {
					try {
						return decodeURIComponent(escape(Latin1.stringify(wordArray)));
					} catch (e) {
						throw new Error('Malformed UTF-8 data');
					}
				},
	
				/**
	    * Converts a UTF-8 string to a word array.
	    *
	    * @param {string} utf8Str The UTF-8 string.
	    *
	    * @return {WordArray} The word array.
	    *
	    * @static
	    *
	    * @example
	    *
	    *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	    */
				parse: function parse(utf8Str) {
					return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
				}
			};
	
			/**
	   * Abstract buffered block algorithm template.
	   *
	   * The property blockSize must be implemented in a concrete subtype.
	   *
	   * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	   */
			var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
				/**
	    * Resets this block algorithm's data buffer to its initial state.
	    *
	    * @example
	    *
	    *     bufferedBlockAlgorithm.reset();
	    */
				reset: function reset() {
					// Initial values
					this._data = new WordArray.init();
					this._nDataBytes = 0;
				},
	
				/**
	    * Adds new data to this block algorithm's buffer.
	    *
	    * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	    *
	    * @example
	    *
	    *     bufferedBlockAlgorithm._append('data');
	    *     bufferedBlockAlgorithm._append(wordArray);
	    */
				_append: function _append(data) {
					// Convert string to WordArray, else assume WordArray already
					if (typeof data == 'string') {
						data = Utf8.parse(data);
					}
	
					// Append
					this._data.concat(data);
					this._nDataBytes += data.sigBytes;
				},
	
				/**
	    * Processes available data blocks.
	    *
	    * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	    *
	    * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	    *
	    * @return {WordArray} The processed data.
	    *
	    * @example
	    *
	    *     var processedData = bufferedBlockAlgorithm._process();
	    *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	    */
				_process: function _process(doFlush) {
					// Shortcuts
					var data = this._data;
					var dataWords = data.words;
					var dataSigBytes = data.sigBytes;
					var blockSize = this.blockSize;
					var blockSizeBytes = blockSize * 4;
	
					// Count blocks ready
					var nBlocksReady = dataSigBytes / blockSizeBytes;
					if (doFlush) {
						// Round up to include partial blocks
						nBlocksReady = Math.ceil(nBlocksReady);
					} else {
						// Round down to include only full blocks,
						// less the number of blocks that must remain in the buffer
						nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
					}
	
					// Count words ready
					var nWordsReady = nBlocksReady * blockSize;
	
					// Count bytes ready
					var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
	
					// Process blocks
					if (nWordsReady) {
						for (var offset = 0; offset < nWordsReady; offset += blockSize) {
							// Perform concrete-algorithm logic
							this._doProcessBlock(dataWords, offset);
						}
	
						// Remove processed words
						var processedWords = dataWords.splice(0, nWordsReady);
						data.sigBytes -= nBytesReady;
					}
	
					// Return processed words
					return new WordArray.init(processedWords, nBytesReady);
				},
	
				/**
	    * Creates a copy of this object.
	    *
	    * @return {Object} The clone.
	    *
	    * @example
	    *
	    *     var clone = bufferedBlockAlgorithm.clone();
	    */
				clone: function clone() {
					var clone = Base.clone.call(this);
					clone._data = this._data.clone();
	
					return clone;
				},
	
				_minBufferSize: 0
			});
	
			/**
	   * Abstract hasher template.
	   *
	   * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	   */
			var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
				/**
	    * Configuration options.
	    */
				cfg: Base.extend(),
	
				/**
	    * Initializes a newly created hasher.
	    *
	    * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	    *
	    * @example
	    *
	    *     var hasher = CryptoJS.algo.SHA256.create();
	    */
				init: function init(cfg) {
					// Apply config defaults
					this.cfg = this.cfg.extend(cfg);
	
					// Set initial values
					this.reset();
				},
	
				/**
	    * Resets this hasher to its initial state.
	    *
	    * @example
	    *
	    *     hasher.reset();
	    */
				reset: function reset() {
					// Reset data buffer
					BufferedBlockAlgorithm.reset.call(this);
	
					// Perform concrete-hasher logic
					this._doReset();
				},
	
				/**
	    * Updates this hasher with a message.
	    *
	    * @param {WordArray|string} messageUpdate The message to append.
	    *
	    * @return {Hasher} This hasher.
	    *
	    * @example
	    *
	    *     hasher.update('message');
	    *     hasher.update(wordArray);
	    */
				update: function update(messageUpdate) {
					// Append
					this._append(messageUpdate);
	
					// Update the hash
					this._process();
	
					// Chainable
					return this;
				},
	
				/**
	    * Finalizes the hash computation.
	    * Note that the finalize operation is effectively a destructive, read-once operation.
	    *
	    * @param {WordArray|string} messageUpdate (Optional) A final message update.
	    *
	    * @return {WordArray} The hash.
	    *
	    * @example
	    *
	    *     var hash = hasher.finalize();
	    *     var hash = hasher.finalize('message');
	    *     var hash = hasher.finalize(wordArray);
	    */
				finalize: function finalize(messageUpdate) {
					// Final message update
					if (messageUpdate) {
						this._append(messageUpdate);
					}
	
					// Perform concrete-hasher logic
					var hash = this._doFinalize();
	
					return hash;
				},
	
				blockSize: 512 / 32,
	
				/**
	    * Creates a shortcut function to a hasher's object interface.
	    *
	    * @param {Hasher} hasher The hasher to create a helper for.
	    *
	    * @return {Function} The shortcut function.
	    *
	    * @static
	    *
	    * @example
	    *
	    *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	    */
				_createHelper: function _createHelper(hasher) {
					return function (message, cfg) {
						return new hasher.init(cfg).finalize(message);
					};
				},
	
				/**
	    * Creates a shortcut function to the HMAC's object interface.
	    *
	    * @param {Hasher} hasher The hasher to use in this HMAC helper.
	    *
	    * @return {Function} The shortcut function.
	    *
	    * @static
	    *
	    * @example
	    *
	    *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	    */
				_createHmacHelper: function _createHmacHelper(hasher) {
					return function (message, key) {
						return new C_algo.HMAC.init(hasher, key).finalize(message);
					};
				}
			});
	
			/**
	   * Algorithm namespace.
	   */
			var C_algo = C.algo = {};
	
			return C;
		}(Math);
	
		return CryptoJS;
	});

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	;(function (root, factory) {
		if (( false ? "undefined" : _typeof(exports)) === "object") {
			// CommonJS
			module.exports = exports = factory(__webpack_require__(14));
		} else if (true) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(14)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			// Global (browser)
			factory(root.CryptoJS);
		}
	})(undefined, function (CryptoJS) {
	
		(function () {
			// Shortcuts
			var C = CryptoJS;
			var C_lib = C.lib;
			var WordArray = C_lib.WordArray;
			var C_enc = C.enc;
	
			/**
	   * Base64 encoding strategy.
	   */
			var Base64 = C_enc.Base64 = {
				/**
	    * Converts a word array to a Base64 string.
	    *
	    * @param {WordArray} wordArray The word array.
	    *
	    * @return {string} The Base64 string.
	    *
	    * @static
	    *
	    * @example
	    *
	    *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	    */
				stringify: function stringify(wordArray) {
					// Shortcuts
					var words = wordArray.words;
					var sigBytes = wordArray.sigBytes;
					var map = this._map;
	
					// Clamp excess bits
					wordArray.clamp();
	
					// Convert
					var base64Chars = [];
					for (var i = 0; i < sigBytes; i += 3) {
						var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
						var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 0xff;
						var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 0xff;
	
						var triplet = byte1 << 16 | byte2 << 8 | byte3;
	
						for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
							base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 0x3f));
						}
					}
	
					// Add padding
					var paddingChar = map.charAt(64);
					if (paddingChar) {
						while (base64Chars.length % 4) {
							base64Chars.push(paddingChar);
						}
					}
	
					return base64Chars.join('');
				},
	
				/**
	    * Converts a Base64 string to a word array.
	    *
	    * @param {string} base64Str The Base64 string.
	    *
	    * @return {WordArray} The word array.
	    *
	    * @static
	    *
	    * @example
	    *
	    *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	    */
				parse: function parse(base64Str) {
					// Shortcuts
					var base64StrLength = base64Str.length;
					var map = this._map;
					var reverseMap = this._reverseMap;
	
					if (!reverseMap) {
						reverseMap = this._reverseMap = [];
						for (var j = 0; j < map.length; j++) {
							reverseMap[map.charCodeAt(j)] = j;
						}
					}
	
					// Ignore padding
					var paddingChar = map.charAt(64);
					if (paddingChar) {
						var paddingIndex = base64Str.indexOf(paddingChar);
						if (paddingIndex !== -1) {
							base64StrLength = paddingIndex;
						}
					}
	
					// Convert
					return parseLoop(base64Str, base64StrLength, reverseMap);
				},
	
				_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
			};
	
			function parseLoop(base64Str, base64StrLength, reverseMap) {
				var words = [];
				var nBytes = 0;
				for (var i = 0; i < base64StrLength; i++) {
					if (i % 4) {
						var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
						var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
						words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
						nBytes++;
					}
				}
				return WordArray.create(words, nBytes);
			}
		})();
	
		return CryptoJS.enc.Base64;
	});

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	;(function (root, factory) {
		if (( false ? "undefined" : _typeof(exports)) === "object") {
			// CommonJS
			module.exports = exports = factory(__webpack_require__(14));
		} else if (true) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(14)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			// Global (browser)
			factory(root.CryptoJS);
		}
	})(undefined, function (CryptoJS) {
	
		return CryptoJS.enc.Hex;
	});

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/*
	Based on the work of Tom Wu
	http://www-cs-students.stanford.edu/~tjw/jsbn/
	http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE
	*/
	
	var BigInteger = __webpack_require__(18).BigInteger;
	var SHA256 = __webpack_require__(13);
	
	var DigestInfoHead = {
	  sha1: '3021300906052b0e03021a05000414',
	  sha224: '302d300d06096086480165030402040500041c',
	  sha256: '3031300d060960864801650304020105000420',
	  sha384: '3041300d060960864801650304020205000430',
	  sha512: '3051300d060960864801650304020305000440',
	  md2: '3020300c06082a864886f70d020205000410',
	  md5: '3020300c06082a864886f70d020505000410',
	  ripemd160: '3021300906052b2403020105000414'
	};
	
	var DigestAlgs = {
	  sha256: SHA256
	};
	
	function RSAVerifier(modulus, exp) {
	  this.n = null;
	  this.e = 0;
	
	  if (modulus != null && exp != null && modulus.length > 0 && exp.length > 0) {
	    this.n = new BigInteger(modulus, 16);
	    this.e = parseInt(exp, 16);
	  } else {
	    throw new Error('Invalid key data');
	  }
	}
	
	function getAlgorithmFromDigest(hDigestInfo) {
	  for (var algName in DigestInfoHead) {
	    var head = DigestInfoHead[algName];
	    var len = head.length;
	
	    if (hDigestInfo.substring(0, len) === head) {
	      return {
	        alg: algName,
	        hash: hDigestInfo.substring(len)
	      };
	    }
	  }
	  return [];
	}
	
	RSAVerifier.prototype.verify = function (msg, encsig) {
	  encsig = encsig.replace(/[^0-9a-f]|[\s\n]]/ig, '');
	
	  var sig = new BigInteger(encsig, 16);
	  if (sig.bitLength() > this.n.bitLength()) {
	    throw new Error('Signature does not match with the key modulus.');
	  }
	
	  var decryptedSig = sig.modPowInt(this.e, this.n);
	  var digest = decryptedSig.toString(16).replace(/^1f+00/, '');
	
	  var digestInfo = getAlgorithmFromDigest(digest);
	  if (digestInfo.length === 0) {
	    return false;
	  }
	
	  if (!DigestAlgs.hasOwnProperty(digestInfo.alg)) {
	    throw new Error('Hashing algorithm is not supported.');
	  }
	
	  var msgHash = DigestAlgs[digestInfo.alg](msg).toString();
	  return digestInfo.hash === msgHash;
	};
	
	module.exports = RSAVerifier;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	(function () {
	
	  // Copyright (c) 2005  Tom Wu
	  // All Rights Reserved.
	  // See "LICENSE" for details.
	
	  // Basic JavaScript BN library - subset useful for RSA encryption.
	
	  // Bits per digit
	  var dbits;
	
	  // JavaScript engine analysis
	  var canary = 0xdeadbeefcafe;
	  var j_lm = (canary & 0xffffff) == 0xefcafe;
	
	  // (public) Constructor
	  function BigInteger(a, b, c) {
	    if (a != null) if ("number" == typeof a) this.fromNumber(a, b, c);else if (b == null && "string" != typeof a) this.fromString(a, 256);else this.fromString(a, b);
	  }
	
	  // return new, unset BigInteger
	  function nbi() {
	    return new BigInteger(null);
	  }
	
	  // am: Compute w_j += (x*this_i), propagate carries,
	  // c is initial carry, returns final carry.
	  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
	  // We need to select the fastest one that works in this environment.
	
	  // am1: use a single mult and divide to get the high bits,
	  // max digit bits should be 26 because
	  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
	  function am1(i, x, w, j, c, n) {
	    while (--n >= 0) {
	      var v = x * this[i++] + w[j] + c;
	      c = Math.floor(v / 0x4000000);
	      w[j++] = v & 0x3ffffff;
	    }
	    return c;
	  }
	  // am2 avoids a big mult-and-extract completely.
	  // Max digit bits should be <= 30 because we do bitwise ops
	  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
	  function am2(i, x, w, j, c, n) {
	    var xl = x & 0x7fff,
	        xh = x >> 15;
	    while (--n >= 0) {
	      var l = this[i] & 0x7fff;
	      var h = this[i++] >> 15;
	      var m = xh * l + h * xl;
	      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
	      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
	      w[j++] = l & 0x3fffffff;
	    }
	    return c;
	  }
	  // Alternately, set max digit bits to 28 since some
	  // browsers slow down when dealing with 32-bit numbers.
	  function am3(i, x, w, j, c, n) {
	    var xl = x & 0x3fff,
	        xh = x >> 14;
	    while (--n >= 0) {
	      var l = this[i] & 0x3fff;
	      var h = this[i++] >> 14;
	      var m = xh * l + h * xl;
	      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
	      c = (l >> 28) + (m >> 14) + xh * h;
	      w[j++] = l & 0xfffffff;
	    }
	    return c;
	  }
	  var inBrowser = typeof navigator !== "undefined";
	  if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
	    BigInteger.prototype.am = am2;
	    dbits = 30;
	  } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
	    BigInteger.prototype.am = am1;
	    dbits = 26;
	  } else {
	    // Mozilla/Netscape seems to prefer am3
	    BigInteger.prototype.am = am3;
	    dbits = 28;
	  }
	
	  BigInteger.prototype.DB = dbits;
	  BigInteger.prototype.DM = (1 << dbits) - 1;
	  BigInteger.prototype.DV = 1 << dbits;
	
	  var BI_FP = 52;
	  BigInteger.prototype.FV = Math.pow(2, BI_FP);
	  BigInteger.prototype.F1 = BI_FP - dbits;
	  BigInteger.prototype.F2 = 2 * dbits - BI_FP;
	
	  // Digit conversions
	  var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
	  var BI_RC = new Array();
	  var rr, vv;
	  rr = "0".charCodeAt(0);
	  for (vv = 0; vv <= 9; ++vv) {
	    BI_RC[rr++] = vv;
	  }rr = "a".charCodeAt(0);
	  for (vv = 10; vv < 36; ++vv) {
	    BI_RC[rr++] = vv;
	  }rr = "A".charCodeAt(0);
	  for (vv = 10; vv < 36; ++vv) {
	    BI_RC[rr++] = vv;
	  }function int2char(n) {
	    return BI_RM.charAt(n);
	  }
	  function intAt(s, i) {
	    var c = BI_RC[s.charCodeAt(i)];
	    return c == null ? -1 : c;
	  }
	
	  // (protected) copy this to r
	  function bnpCopyTo(r) {
	    for (var i = this.t - 1; i >= 0; --i) {
	      r[i] = this[i];
	    }r.t = this.t;
	    r.s = this.s;
	  }
	
	  // (protected) set from integer value x, -DV <= x < DV
	  function bnpFromInt(x) {
	    this.t = 1;
	    this.s = x < 0 ? -1 : 0;
	    if (x > 0) this[0] = x;else if (x < -1) this[0] = x + this.DV;else this.t = 0;
	  }
	
	  // return bigint initialized to value
	  function nbv(i) {
	    var r = nbi();r.fromInt(i);return r;
	  }
	
	  // (protected) set from string and radix
	  function bnpFromString(s, b) {
	    var k;
	    if (b == 16) k = 4;else if (b == 8) k = 3;else if (b == 256) k = 8; // byte array
	    else if (b == 2) k = 1;else if (b == 32) k = 5;else if (b == 4) k = 2;else {
	        this.fromRadix(s, b);return;
	      }
	    this.t = 0;
	    this.s = 0;
	    var i = s.length,
	        mi = false,
	        sh = 0;
	    while (--i >= 0) {
	      var x = k == 8 ? s[i] & 0xff : intAt(s, i);
	      if (x < 0) {
	        if (s.charAt(i) == "-") mi = true;
	        continue;
	      }
	      mi = false;
	      if (sh == 0) this[this.t++] = x;else if (sh + k > this.DB) {
	        this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
	        this[this.t++] = x >> this.DB - sh;
	      } else this[this.t - 1] |= x << sh;
	      sh += k;
	      if (sh >= this.DB) sh -= this.DB;
	    }
	    if (k == 8 && (s[0] & 0x80) != 0) {
	      this.s = -1;
	      if (sh > 0) this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
	    }
	    this.clamp();
	    if (mi) BigInteger.ZERO.subTo(this, this);
	  }
	
	  // (protected) clamp off excess high words
	  function bnpClamp() {
	    var c = this.s & this.DM;
	    while (this.t > 0 && this[this.t - 1] == c) {
	      --this.t;
	    }
	  }
	
	  // (public) return string representation in given radix
	  function bnToString(b) {
	    if (this.s < 0) return "-" + this.negate().toString(b);
	    var k;
	    if (b == 16) k = 4;else if (b == 8) k = 3;else if (b == 2) k = 1;else if (b == 32) k = 5;else if (b == 4) k = 2;else return this.toRadix(b);
	    var km = (1 << k) - 1,
	        d,
	        m = false,
	        r = "",
	        i = this.t;
	    var p = this.DB - i * this.DB % k;
	    if (i-- > 0) {
	      if (p < this.DB && (d = this[i] >> p) > 0) {
	        m = true;r = int2char(d);
	      }
	      while (i >= 0) {
	        if (p < k) {
	          d = (this[i] & (1 << p) - 1) << k - p;
	          d |= this[--i] >> (p += this.DB - k);
	        } else {
	          d = this[i] >> (p -= k) & km;
	          if (p <= 0) {
	            p += this.DB;--i;
	          }
	        }
	        if (d > 0) m = true;
	        if (m) r += int2char(d);
	      }
	    }
	    return m ? r : "0";
	  }
	
	  // (public) -this
	  function bnNegate() {
	    var r = nbi();BigInteger.ZERO.subTo(this, r);return r;
	  }
	
	  // (public) |this|
	  function bnAbs() {
	    return this.s < 0 ? this.negate() : this;
	  }
	
	  // (public) return + if this > a, - if this < a, 0 if equal
	  function bnCompareTo(a) {
	    var r = this.s - a.s;
	    if (r != 0) return r;
	    var i = this.t;
	    r = i - a.t;
	    if (r != 0) return this.s < 0 ? -r : r;
	    while (--i >= 0) {
	      if ((r = this[i] - a[i]) != 0) return r;
	    }return 0;
	  }
	
	  // returns bit length of the integer x
	  function nbits(x) {
	    var r = 1,
	        t;
	    if ((t = x >>> 16) != 0) {
	      x = t;r += 16;
	    }
	    if ((t = x >> 8) != 0) {
	      x = t;r += 8;
	    }
	    if ((t = x >> 4) != 0) {
	      x = t;r += 4;
	    }
	    if ((t = x >> 2) != 0) {
	      x = t;r += 2;
	    }
	    if ((t = x >> 1) != 0) {
	      x = t;r += 1;
	    }
	    return r;
	  }
	
	  // (public) return the number of bits in "this"
	  function bnBitLength() {
	    if (this.t <= 0) return 0;
	    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
	  }
	
	  // (protected) r = this << n*DB
	  function bnpDLShiftTo(n, r) {
	    var i;
	    for (i = this.t - 1; i >= 0; --i) {
	      r[i + n] = this[i];
	    }for (i = n - 1; i >= 0; --i) {
	      r[i] = 0;
	    }r.t = this.t + n;
	    r.s = this.s;
	  }
	
	  // (protected) r = this >> n*DB
	  function bnpDRShiftTo(n, r) {
	    for (var i = n; i < this.t; ++i) {
	      r[i - n] = this[i];
	    }r.t = Math.max(this.t - n, 0);
	    r.s = this.s;
	  }
	
	  // (protected) r = this << n
	  function bnpLShiftTo(n, r) {
	    var bs = n % this.DB;
	    var cbs = this.DB - bs;
	    var bm = (1 << cbs) - 1;
	    var ds = Math.floor(n / this.DB),
	        c = this.s << bs & this.DM,
	        i;
	    for (i = this.t - 1; i >= 0; --i) {
	      r[i + ds + 1] = this[i] >> cbs | c;
	      c = (this[i] & bm) << bs;
	    }
	    for (i = ds - 1; i >= 0; --i) {
	      r[i] = 0;
	    }r[ds] = c;
	    r.t = this.t + ds + 1;
	    r.s = this.s;
	    r.clamp();
	  }
	
	  // (protected) r = this >> n
	  function bnpRShiftTo(n, r) {
	    r.s = this.s;
	    var ds = Math.floor(n / this.DB);
	    if (ds >= this.t) {
	      r.t = 0;return;
	    }
	    var bs = n % this.DB;
	    var cbs = this.DB - bs;
	    var bm = (1 << bs) - 1;
	    r[0] = this[ds] >> bs;
	    for (var i = ds + 1; i < this.t; ++i) {
	      r[i - ds - 1] |= (this[i] & bm) << cbs;
	      r[i - ds] = this[i] >> bs;
	    }
	    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
	    r.t = this.t - ds;
	    r.clamp();
	  }
	
	  // (protected) r = this - a
	  function bnpSubTo(a, r) {
	    var i = 0,
	        c = 0,
	        m = Math.min(a.t, this.t);
	    while (i < m) {
	      c += this[i] - a[i];
	      r[i++] = c & this.DM;
	      c >>= this.DB;
	    }
	    if (a.t < this.t) {
	      c -= a.s;
	      while (i < this.t) {
	        c += this[i];
	        r[i++] = c & this.DM;
	        c >>= this.DB;
	      }
	      c += this.s;
	    } else {
	      c += this.s;
	      while (i < a.t) {
	        c -= a[i];
	        r[i++] = c & this.DM;
	        c >>= this.DB;
	      }
	      c -= a.s;
	    }
	    r.s = c < 0 ? -1 : 0;
	    if (c < -1) r[i++] = this.DV + c;else if (c > 0) r[i++] = c;
	    r.t = i;
	    r.clamp();
	  }
	
	  // (protected) r = this * a, r != this,a (HAC 14.12)
	  // "this" should be the larger one if appropriate.
	  function bnpMultiplyTo(a, r) {
	    var x = this.abs(),
	        y = a.abs();
	    var i = x.t;
	    r.t = i + y.t;
	    while (--i >= 0) {
	      r[i] = 0;
	    }for (i = 0; i < y.t; ++i) {
	      r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
	    }r.s = 0;
	    r.clamp();
	    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
	  }
	
	  // (protected) r = this^2, r != this (HAC 14.16)
	  function bnpSquareTo(r) {
	    var x = this.abs();
	    var i = r.t = 2 * x.t;
	    while (--i >= 0) {
	      r[i] = 0;
	    }for (i = 0; i < x.t - 1; ++i) {
	      var c = x.am(i, x[i], r, 2 * i, 0, 1);
	      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
	        r[i + x.t] -= x.DV;
	        r[i + x.t + 1] = 1;
	      }
	    }
	    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
	    r.s = 0;
	    r.clamp();
	  }
	
	  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
	  // r != q, this != m.  q or r may be null.
	  function bnpDivRemTo(m, q, r) {
	    var pm = m.abs();
	    if (pm.t <= 0) return;
	    var pt = this.abs();
	    if (pt.t < pm.t) {
	      if (q != null) q.fromInt(0);
	      if (r != null) this.copyTo(r);
	      return;
	    }
	    if (r == null) r = nbi();
	    var y = nbi(),
	        ts = this.s,
	        ms = m.s;
	    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus
	    if (nsh > 0) {
	      pm.lShiftTo(nsh, y);pt.lShiftTo(nsh, r);
	    } else {
	      pm.copyTo(y);pt.copyTo(r);
	    }
	    var ys = y.t;
	    var y0 = y[ys - 1];
	    if (y0 == 0) return;
	    var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
	    var d1 = this.FV / yt,
	        d2 = (1 << this.F1) / yt,
	        e = 1 << this.F2;
	    var i = r.t,
	        j = i - ys,
	        t = q == null ? nbi() : q;
	    y.dlShiftTo(j, t);
	    if (r.compareTo(t) >= 0) {
	      r[r.t++] = 1;
	      r.subTo(t, r);
	    }
	    BigInteger.ONE.dlShiftTo(ys, t);
	    t.subTo(y, y); // "negative" y so we can replace sub with am later
	    while (y.t < ys) {
	      y[y.t++] = 0;
	    }while (--j >= 0) {
	      // Estimate quotient digit
	      var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
	      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
	        // Try it out
	        y.dlShiftTo(j, t);
	        r.subTo(t, r);
	        while (r[i] < --qd) {
	          r.subTo(t, r);
	        }
	      }
	    }
	    if (q != null) {
	      r.drShiftTo(ys, q);
	      if (ts != ms) BigInteger.ZERO.subTo(q, q);
	    }
	    r.t = ys;
	    r.clamp();
	    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder
	    if (ts < 0) BigInteger.ZERO.subTo(r, r);
	  }
	
	  // (public) this mod a
	  function bnMod(a) {
	    var r = nbi();
	    this.abs().divRemTo(a, null, r);
	    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
	    return r;
	  }
	
	  // Modular reduction using "classic" algorithm
	  function Classic(m) {
	    this.m = m;
	  }
	  function cConvert(x) {
	    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);else return x;
	  }
	  function cRevert(x) {
	    return x;
	  }
	  function cReduce(x) {
	    x.divRemTo(this.m, null, x);
	  }
	  function cMulTo(x, y, r) {
	    x.multiplyTo(y, r);this.reduce(r);
	  }
	  function cSqrTo(x, r) {
	    x.squareTo(r);this.reduce(r);
	  }
	
	  Classic.prototype.convert = cConvert;
	  Classic.prototype.revert = cRevert;
	  Classic.prototype.reduce = cReduce;
	  Classic.prototype.mulTo = cMulTo;
	  Classic.prototype.sqrTo = cSqrTo;
	
	  // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
	  // justification:
	  //         xy == 1 (mod m)
	  //         xy =  1+km
	  //   xy(2-xy) = (1+km)(1-km)
	  // x[y(2-xy)] = 1-k^2m^2
	  // x[y(2-xy)] == 1 (mod m^2)
	  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
	  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
	  // JS multiply "overflows" differently from C/C++, so care is needed here.
	  function bnpInvDigit() {
	    if (this.t < 1) return 0;
	    var x = this[0];
	    if ((x & 1) == 0) return 0;
	    var y = x & 3; // y == 1/x mod 2^2
	    y = y * (2 - (x & 0xf) * y) & 0xf; // y == 1/x mod 2^4
	    y = y * (2 - (x & 0xff) * y) & 0xff; // y == 1/x mod 2^8
	    y = y * (2 - ((x & 0xffff) * y & 0xffff)) & 0xffff; // y == 1/x mod 2^16
	    // last step - calculate inverse mod DV directly;
	    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
	    y = y * (2 - x * y % this.DV) % this.DV; // y == 1/x mod 2^dbits
	    // we really want the negative inverse, and -DV < y < DV
	    return y > 0 ? this.DV - y : -y;
	  }
	
	  // Montgomery reduction
	  function Montgomery(m) {
	    this.m = m;
	    this.mp = m.invDigit();
	    this.mpl = this.mp & 0x7fff;
	    this.mph = this.mp >> 15;
	    this.um = (1 << m.DB - 15) - 1;
	    this.mt2 = 2 * m.t;
	  }
	
	  // xR mod m
	  function montConvert(x) {
	    var r = nbi();
	    x.abs().dlShiftTo(this.m.t, r);
	    r.divRemTo(this.m, null, r);
	    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
	    return r;
	  }
	
	  // x/R mod m
	  function montRevert(x) {
	    var r = nbi();
	    x.copyTo(r);
	    this.reduce(r);
	    return r;
	  }
	
	  // x = x/R mod m (HAC 14.32)
	  function montReduce(x) {
	    while (x.t <= this.mt2) {
	      // pad x so am has enough room later
	      x[x.t++] = 0;
	    }for (var i = 0; i < this.m.t; ++i) {
	      // faster way of calculating u0 = x[i]*mp mod DV
	      var j = x[i] & 0x7fff;
	      var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
	      // use am to combine the multiply-shift-add into one call
	      j = i + this.m.t;
	      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
	      // propagate carry
	      while (x[j] >= x.DV) {
	        x[j] -= x.DV;x[++j]++;
	      }
	    }
	    x.clamp();
	    x.drShiftTo(this.m.t, x);
	    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
	  }
	
	  // r = "x^2/R mod m"; x != r
	  function montSqrTo(x, r) {
	    x.squareTo(r);this.reduce(r);
	  }
	
	  // r = "xy/R mod m"; x,y != r
	  function montMulTo(x, y, r) {
	    x.multiplyTo(y, r);this.reduce(r);
	  }
	
	  Montgomery.prototype.convert = montConvert;
	  Montgomery.prototype.revert = montRevert;
	  Montgomery.prototype.reduce = montReduce;
	  Montgomery.prototype.mulTo = montMulTo;
	  Montgomery.prototype.sqrTo = montSqrTo;
	
	  // (protected) true iff this is even
	  function bnpIsEven() {
	    return (this.t > 0 ? this[0] & 1 : this.s) == 0;
	  }
	
	  // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
	  function bnpExp(e, z) {
	    if (e > 0xffffffff || e < 1) return BigInteger.ONE;
	    var r = nbi(),
	        r2 = nbi(),
	        g = z.convert(this),
	        i = nbits(e) - 1;
	    g.copyTo(r);
	    while (--i >= 0) {
	      z.sqrTo(r, r2);
	      if ((e & 1 << i) > 0) z.mulTo(r2, g, r);else {
	        var t = r;r = r2;r2 = t;
	      }
	    }
	    return z.revert(r);
	  }
	
	  // (public) this^e % m, 0 <= e < 2^32
	  function bnModPowInt(e, m) {
	    var z;
	    if (e < 256 || m.isEven()) z = new Classic(m);else z = new Montgomery(m);
	    return this.exp(e, z);
	  }
	
	  // protected
	  BigInteger.prototype.copyTo = bnpCopyTo;
	  BigInteger.prototype.fromInt = bnpFromInt;
	  BigInteger.prototype.fromString = bnpFromString;
	  BigInteger.prototype.clamp = bnpClamp;
	  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
	  BigInteger.prototype.drShiftTo = bnpDRShiftTo;
	  BigInteger.prototype.lShiftTo = bnpLShiftTo;
	  BigInteger.prototype.rShiftTo = bnpRShiftTo;
	  BigInteger.prototype.subTo = bnpSubTo;
	  BigInteger.prototype.multiplyTo = bnpMultiplyTo;
	  BigInteger.prototype.squareTo = bnpSquareTo;
	  BigInteger.prototype.divRemTo = bnpDivRemTo;
	  BigInteger.prototype.invDigit = bnpInvDigit;
	  BigInteger.prototype.isEven = bnpIsEven;
	  BigInteger.prototype.exp = bnpExp;
	
	  // public
	  BigInteger.prototype.toString = bnToString;
	  BigInteger.prototype.negate = bnNegate;
	  BigInteger.prototype.abs = bnAbs;
	  BigInteger.prototype.compareTo = bnCompareTo;
	  BigInteger.prototype.bitLength = bnBitLength;
	  BigInteger.prototype.mod = bnMod;
	  BigInteger.prototype.modPowInt = bnModPowInt;
	
	  // "constants"
	  BigInteger.ZERO = nbv(0);
	  BigInteger.ONE = nbv(1);
	
	  // Copyright (c) 2005-2009  Tom Wu
	  // All Rights Reserved.
	  // See "LICENSE" for details.
	
	  // Extended JavaScript BN functions, required for RSA private ops.
	
	  // Version 1.1: new BigInteger("0", 10) returns "proper" zero
	  // Version 1.2: square() API, isProbablePrime fix
	
	  // (public)
	  function bnClone() {
	    var r = nbi();this.copyTo(r);return r;
	  }
	
	  // (public) return value as integer
	  function bnIntValue() {
	    if (this.s < 0) {
	      if (this.t == 1) return this[0] - this.DV;else if (this.t == 0) return -1;
	    } else if (this.t == 1) return this[0];else if (this.t == 0) return 0;
	    // assumes 16 < DB < 32
	    return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
	  }
	
	  // (public) return value as byte
	  function bnByteValue() {
	    return this.t == 0 ? this.s : this[0] << 24 >> 24;
	  }
	
	  // (public) return value as short (assumes DB>=16)
	  function bnShortValue() {
	    return this.t == 0 ? this.s : this[0] << 16 >> 16;
	  }
	
	  // (protected) return x s.t. r^x < DV
	  function bnpChunkSize(r) {
	    return Math.floor(Math.LN2 * this.DB / Math.log(r));
	  }
	
	  // (public) 0 if this == 0, 1 if this > 0
	  function bnSigNum() {
	    if (this.s < 0) return -1;else if (this.t <= 0 || this.t == 1 && this[0] <= 0) return 0;else return 1;
	  }
	
	  // (protected) convert to radix string
	  function bnpToRadix(b) {
	    if (b == null) b = 10;
	    if (this.signum() == 0 || b < 2 || b > 36) return "0";
	    var cs = this.chunkSize(b);
	    var a = Math.pow(b, cs);
	    var d = nbv(a),
	        y = nbi(),
	        z = nbi(),
	        r = "";
	    this.divRemTo(d, y, z);
	    while (y.signum() > 0) {
	      r = (a + z.intValue()).toString(b).substr(1) + r;
	      y.divRemTo(d, y, z);
	    }
	    return z.intValue().toString(b) + r;
	  }
	
	  // (protected) convert from radix string
	  function bnpFromRadix(s, b) {
	    this.fromInt(0);
	    if (b == null) b = 10;
	    var cs = this.chunkSize(b);
	    var d = Math.pow(b, cs),
	        mi = false,
	        j = 0,
	        w = 0;
	    for (var i = 0; i < s.length; ++i) {
	      var x = intAt(s, i);
	      if (x < 0) {
	        if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
	        continue;
	      }
	      w = b * w + x;
	      if (++j >= cs) {
	        this.dMultiply(d);
	        this.dAddOffset(w, 0);
	        j = 0;
	        w = 0;
	      }
	    }
	    if (j > 0) {
	      this.dMultiply(Math.pow(b, j));
	      this.dAddOffset(w, 0);
	    }
	    if (mi) BigInteger.ZERO.subTo(this, this);
	  }
	
	  // (protected) alternate constructor
	  function bnpFromNumber(a, b, c) {
	    if ("number" == typeof b) {
	      // new BigInteger(int,int,RNG)
	      if (a < 2) this.fromInt(1);else {
	        this.fromNumber(a, c);
	        if (!this.testBit(a - 1)) // force MSB set
	          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
	        if (this.isEven()) this.dAddOffset(1, 0); // force odd
	        while (!this.isProbablePrime(b)) {
	          this.dAddOffset(2, 0);
	          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
	        }
	      }
	    } else {
	      // new BigInteger(int,RNG)
	      var x = new Array(),
	          t = a & 7;
	      x.length = (a >> 3) + 1;
	      b.nextBytes(x);
	      if (t > 0) x[0] &= (1 << t) - 1;else x[0] = 0;
	      this.fromString(x, 256);
	    }
	  }
	
	  // (public) convert to bigendian byte array
	  function bnToByteArray() {
	    var i = this.t,
	        r = new Array();
	    r[0] = this.s;
	    var p = this.DB - i * this.DB % 8,
	        d,
	        k = 0;
	    if (i-- > 0) {
	      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) r[k++] = d | this.s << this.DB - p;
	      while (i >= 0) {
	        if (p < 8) {
	          d = (this[i] & (1 << p) - 1) << 8 - p;
	          d |= this[--i] >> (p += this.DB - 8);
	        } else {
	          d = this[i] >> (p -= 8) & 0xff;
	          if (p <= 0) {
	            p += this.DB;--i;
	          }
	        }
	        if ((d & 0x80) != 0) d |= -256;
	        if (k == 0 && (this.s & 0x80) != (d & 0x80)) ++k;
	        if (k > 0 || d != this.s) r[k++] = d;
	      }
	    }
	    return r;
	  }
	
	  function bnEquals(a) {
	    return this.compareTo(a) == 0;
	  }
	  function bnMin(a) {
	    return this.compareTo(a) < 0 ? this : a;
	  }
	  function bnMax(a) {
	    return this.compareTo(a) > 0 ? this : a;
	  }
	
	  // (protected) r = this op a (bitwise)
	  function bnpBitwiseTo(a, op, r) {
	    var i,
	        f,
	        m = Math.min(a.t, this.t);
	    for (i = 0; i < m; ++i) {
	      r[i] = op(this[i], a[i]);
	    }if (a.t < this.t) {
	      f = a.s & this.DM;
	      for (i = m; i < this.t; ++i) {
	        r[i] = op(this[i], f);
	      }r.t = this.t;
	    } else {
	      f = this.s & this.DM;
	      for (i = m; i < a.t; ++i) {
	        r[i] = op(f, a[i]);
	      }r.t = a.t;
	    }
	    r.s = op(this.s, a.s);
	    r.clamp();
	  }
	
	  // (public) this & a
	  function op_and(x, y) {
	    return x & y;
	  }
	  function bnAnd(a) {
	    var r = nbi();this.bitwiseTo(a, op_and, r);return r;
	  }
	
	  // (public) this | a
	  function op_or(x, y) {
	    return x | y;
	  }
	  function bnOr(a) {
	    var r = nbi();this.bitwiseTo(a, op_or, r);return r;
	  }
	
	  // (public) this ^ a
	  function op_xor(x, y) {
	    return x ^ y;
	  }
	  function bnXor(a) {
	    var r = nbi();this.bitwiseTo(a, op_xor, r);return r;
	  }
	
	  // (public) this & ~a
	  function op_andnot(x, y) {
	    return x & ~y;
	  }
	  function bnAndNot(a) {
	    var r = nbi();this.bitwiseTo(a, op_andnot, r);return r;
	  }
	
	  // (public) ~this
	  function bnNot() {
	    var r = nbi();
	    for (var i = 0; i < this.t; ++i) {
	      r[i] = this.DM & ~this[i];
	    }r.t = this.t;
	    r.s = ~this.s;
	    return r;
	  }
	
	  // (public) this << n
	  function bnShiftLeft(n) {
	    var r = nbi();
	    if (n < 0) this.rShiftTo(-n, r);else this.lShiftTo(n, r);
	    return r;
	  }
	
	  // (public) this >> n
	  function bnShiftRight(n) {
	    var r = nbi();
	    if (n < 0) this.lShiftTo(-n, r);else this.rShiftTo(n, r);
	    return r;
	  }
	
	  // return index of lowest 1-bit in x, x < 2^31
	  function lbit(x) {
	    if (x == 0) return -1;
	    var r = 0;
	    if ((x & 0xffff) == 0) {
	      x >>= 16;r += 16;
	    }
	    if ((x & 0xff) == 0) {
	      x >>= 8;r += 8;
	    }
	    if ((x & 0xf) == 0) {
	      x >>= 4;r += 4;
	    }
	    if ((x & 3) == 0) {
	      x >>= 2;r += 2;
	    }
	    if ((x & 1) == 0) ++r;
	    return r;
	  }
	
	  // (public) returns index of lowest 1-bit (or -1 if none)
	  function bnGetLowestSetBit() {
	    for (var i = 0; i < this.t; ++i) {
	      if (this[i] != 0) return i * this.DB + lbit(this[i]);
	    }if (this.s < 0) return this.t * this.DB;
	    return -1;
	  }
	
	  // return number of 1 bits in x
	  function cbit(x) {
	    var r = 0;
	    while (x != 0) {
	      x &= x - 1;++r;
	    }
	    return r;
	  }
	
	  // (public) return number of set bits
	  function bnBitCount() {
	    var r = 0,
	        x = this.s & this.DM;
	    for (var i = 0; i < this.t; ++i) {
	      r += cbit(this[i] ^ x);
	    }return r;
	  }
	
	  // (public) true iff nth bit is set
	  function bnTestBit(n) {
	    var j = Math.floor(n / this.DB);
	    if (j >= this.t) return this.s != 0;
	    return (this[j] & 1 << n % this.DB) != 0;
	  }
	
	  // (protected) this op (1<<n)
	  function bnpChangeBit(n, op) {
	    var r = BigInteger.ONE.shiftLeft(n);
	    this.bitwiseTo(r, op, r);
	    return r;
	  }
	
	  // (public) this | (1<<n)
	  function bnSetBit(n) {
	    return this.changeBit(n, op_or);
	  }
	
	  // (public) this & ~(1<<n)
	  function bnClearBit(n) {
	    return this.changeBit(n, op_andnot);
	  }
	
	  // (public) this ^ (1<<n)
	  function bnFlipBit(n) {
	    return this.changeBit(n, op_xor);
	  }
	
	  // (protected) r = this + a
	  function bnpAddTo(a, r) {
	    var i = 0,
	        c = 0,
	        m = Math.min(a.t, this.t);
	    while (i < m) {
	      c += this[i] + a[i];
	      r[i++] = c & this.DM;
	      c >>= this.DB;
	    }
	    if (a.t < this.t) {
	      c += a.s;
	      while (i < this.t) {
	        c += this[i];
	        r[i++] = c & this.DM;
	        c >>= this.DB;
	      }
	      c += this.s;
	    } else {
	      c += this.s;
	      while (i < a.t) {
	        c += a[i];
	        r[i++] = c & this.DM;
	        c >>= this.DB;
	      }
	      c += a.s;
	    }
	    r.s = c < 0 ? -1 : 0;
	    if (c > 0) r[i++] = c;else if (c < -1) r[i++] = this.DV + c;
	    r.t = i;
	    r.clamp();
	  }
	
	  // (public) this + a
	  function bnAdd(a) {
	    var r = nbi();this.addTo(a, r);return r;
	  }
	
	  // (public) this - a
	  function bnSubtract(a) {
	    var r = nbi();this.subTo(a, r);return r;
	  }
	
	  // (public) this * a
	  function bnMultiply(a) {
	    var r = nbi();this.multiplyTo(a, r);return r;
	  }
	
	  // (public) this^2
	  function bnSquare() {
	    var r = nbi();this.squareTo(r);return r;
	  }
	
	  // (public) this / a
	  function bnDivide(a) {
	    var r = nbi();this.divRemTo(a, r, null);return r;
	  }
	
	  // (public) this % a
	  function bnRemainder(a) {
	    var r = nbi();this.divRemTo(a, null, r);return r;
	  }
	
	  // (public) [this/a,this%a]
	  function bnDivideAndRemainder(a) {
	    var q = nbi(),
	        r = nbi();
	    this.divRemTo(a, q, r);
	    return new Array(q, r);
	  }
	
	  // (protected) this *= n, this >= 0, 1 < n < DV
	  function bnpDMultiply(n) {
	    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
	    ++this.t;
	    this.clamp();
	  }
	
	  // (protected) this += n << w words, this >= 0
	  function bnpDAddOffset(n, w) {
	    if (n == 0) return;
	    while (this.t <= w) {
	      this[this.t++] = 0;
	    }this[w] += n;
	    while (this[w] >= this.DV) {
	      this[w] -= this.DV;
	      if (++w >= this.t) this[this.t++] = 0;
	      ++this[w];
	    }
	  }
	
	  // A "null" reducer
	  function NullExp() {}
	  function nNop(x) {
	    return x;
	  }
	  function nMulTo(x, y, r) {
	    x.multiplyTo(y, r);
	  }
	  function nSqrTo(x, r) {
	    x.squareTo(r);
	  }
	
	  NullExp.prototype.convert = nNop;
	  NullExp.prototype.revert = nNop;
	  NullExp.prototype.mulTo = nMulTo;
	  NullExp.prototype.sqrTo = nSqrTo;
	
	  // (public) this^e
	  function bnPow(e) {
	    return this.exp(e, new NullExp());
	  }
	
	  // (protected) r = lower n words of "this * a", a.t <= n
	  // "this" should be the larger one if appropriate.
	  function bnpMultiplyLowerTo(a, n, r) {
	    var i = Math.min(this.t + a.t, n);
	    r.s = 0; // assumes a,this >= 0
	    r.t = i;
	    while (i > 0) {
	      r[--i] = 0;
	    }var j;
	    for (j = r.t - this.t; i < j; ++i) {
	      r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
	    }for (j = Math.min(a.t, n); i < j; ++i) {
	      this.am(0, a[i], r, i, 0, n - i);
	    }r.clamp();
	  }
	
	  // (protected) r = "this * a" without lower n words, n > 0
	  // "this" should be the larger one if appropriate.
	  function bnpMultiplyUpperTo(a, n, r) {
	    --n;
	    var i = r.t = this.t + a.t - n;
	    r.s = 0; // assumes a,this >= 0
	    while (--i >= 0) {
	      r[i] = 0;
	    }for (i = Math.max(n - this.t, 0); i < a.t; ++i) {
	      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
	    }r.clamp();
	    r.drShiftTo(1, r);
	  }
	
	  // Barrett modular reduction
	  function Barrett(m) {
	    // setup Barrett
	    this.r2 = nbi();
	    this.q3 = nbi();
	    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
	    this.mu = this.r2.divide(m);
	    this.m = m;
	  }
	
	  function barrettConvert(x) {
	    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);else if (x.compareTo(this.m) < 0) return x;else {
	      var r = nbi();x.copyTo(r);this.reduce(r);return r;
	    }
	  }
	
	  function barrettRevert(x) {
	    return x;
	  }
	
	  // x = x mod m (HAC 14.42)
	  function barrettReduce(x) {
	    x.drShiftTo(this.m.t - 1, this.r2);
	    if (x.t > this.m.t + 1) {
	      x.t = this.m.t + 1;x.clamp();
	    }
	    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
	    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
	    while (x.compareTo(this.r2) < 0) {
	      x.dAddOffset(1, this.m.t + 1);
	    }x.subTo(this.r2, x);
	    while (x.compareTo(this.m) >= 0) {
	      x.subTo(this.m, x);
	    }
	  }
	
	  // r = x^2 mod m; x != r
	  function barrettSqrTo(x, r) {
	    x.squareTo(r);this.reduce(r);
	  }
	
	  // r = x*y mod m; x,y != r
	  function barrettMulTo(x, y, r) {
	    x.multiplyTo(y, r);this.reduce(r);
	  }
	
	  Barrett.prototype.convert = barrettConvert;
	  Barrett.prototype.revert = barrettRevert;
	  Barrett.prototype.reduce = barrettReduce;
	  Barrett.prototype.mulTo = barrettMulTo;
	  Barrett.prototype.sqrTo = barrettSqrTo;
	
	  // (public) this^e % m (HAC 14.85)
	  function bnModPow(e, m) {
	    var i = e.bitLength(),
	        k,
	        r = nbv(1),
	        z;
	    if (i <= 0) return r;else if (i < 18) k = 1;else if (i < 48) k = 3;else if (i < 144) k = 4;else if (i < 768) k = 5;else k = 6;
	    if (i < 8) z = new Classic(m);else if (m.isEven()) z = new Barrett(m);else z = new Montgomery(m);
	
	    // precomputation
	    var g = new Array(),
	        n = 3,
	        k1 = k - 1,
	        km = (1 << k) - 1;
	    g[1] = z.convert(this);
	    if (k > 1) {
	      var g2 = nbi();
	      z.sqrTo(g[1], g2);
	      while (n <= km) {
	        g[n] = nbi();
	        z.mulTo(g2, g[n - 2], g[n]);
	        n += 2;
	      }
	    }
	
	    var j = e.t - 1,
	        w,
	        is1 = true,
	        r2 = nbi(),
	        t;
	    i = nbits(e[j]) - 1;
	    while (j >= 0) {
	      if (i >= k1) w = e[j] >> i - k1 & km;else {
	        w = (e[j] & (1 << i + 1) - 1) << k1 - i;
	        if (j > 0) w |= e[j - 1] >> this.DB + i - k1;
	      }
	
	      n = k;
	      while ((w & 1) == 0) {
	        w >>= 1;--n;
	      }
	      if ((i -= n) < 0) {
	        i += this.DB;--j;
	      }
	      if (is1) {
	        // ret == 1, don't bother squaring or multiplying it
	        g[w].copyTo(r);
	        is1 = false;
	      } else {
	        while (n > 1) {
	          z.sqrTo(r, r2);z.sqrTo(r2, r);n -= 2;
	        }
	        if (n > 0) z.sqrTo(r, r2);else {
	          t = r;r = r2;r2 = t;
	        }
	        z.mulTo(r2, g[w], r);
	      }
	
	      while (j >= 0 && (e[j] & 1 << i) == 0) {
	        z.sqrTo(r, r2);t = r;r = r2;r2 = t;
	        if (--i < 0) {
	          i = this.DB - 1;--j;
	        }
	      }
	    }
	    return z.revert(r);
	  }
	
	  // (public) gcd(this,a) (HAC 14.54)
	  function bnGCD(a) {
	    var x = this.s < 0 ? this.negate() : this.clone();
	    var y = a.s < 0 ? a.negate() : a.clone();
	    if (x.compareTo(y) < 0) {
	      var t = x;x = y;y = t;
	    }
	    var i = x.getLowestSetBit(),
	        g = y.getLowestSetBit();
	    if (g < 0) return x;
	    if (i < g) g = i;
	    if (g > 0) {
	      x.rShiftTo(g, x);
	      y.rShiftTo(g, y);
	    }
	    while (x.signum() > 0) {
	      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
	      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
	      if (x.compareTo(y) >= 0) {
	        x.subTo(y, x);
	        x.rShiftTo(1, x);
	      } else {
	        y.subTo(x, y);
	        y.rShiftTo(1, y);
	      }
	    }
	    if (g > 0) y.lShiftTo(g, y);
	    return y;
	  }
	
	  // (protected) this % n, n < 2^26
	  function bnpModInt(n) {
	    if (n <= 0) return 0;
	    var d = this.DV % n,
	        r = this.s < 0 ? n - 1 : 0;
	    if (this.t > 0) if (d == 0) r = this[0] % n;else for (var i = this.t - 1; i >= 0; --i) {
	      r = (d * r + this[i]) % n;
	    }return r;
	  }
	
	  // (public) 1/this % m (HAC 14.61)
	  function bnModInverse(m) {
	    var ac = m.isEven();
	    if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;
	    var u = m.clone(),
	        v = this.clone();
	    var a = nbv(1),
	        b = nbv(0),
	        c = nbv(0),
	        d = nbv(1);
	    while (u.signum() != 0) {
	      while (u.isEven()) {
	        u.rShiftTo(1, u);
	        if (ac) {
	          if (!a.isEven() || !b.isEven()) {
	            a.addTo(this, a);b.subTo(m, b);
	          }
	          a.rShiftTo(1, a);
	        } else if (!b.isEven()) b.subTo(m, b);
	        b.rShiftTo(1, b);
	      }
	      while (v.isEven()) {
	        v.rShiftTo(1, v);
	        if (ac) {
	          if (!c.isEven() || !d.isEven()) {
	            c.addTo(this, c);d.subTo(m, d);
	          }
	          c.rShiftTo(1, c);
	        } else if (!d.isEven()) d.subTo(m, d);
	        d.rShiftTo(1, d);
	      }
	      if (u.compareTo(v) >= 0) {
	        u.subTo(v, u);
	        if (ac) a.subTo(c, a);
	        b.subTo(d, b);
	      } else {
	        v.subTo(u, v);
	        if (ac) c.subTo(a, c);
	        d.subTo(b, d);
	      }
	    }
	    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
	    if (d.compareTo(m) >= 0) return d.subtract(m);
	    if (d.signum() < 0) d.addTo(m, d);else return d;
	    if (d.signum() < 0) return d.add(m);else return d;
	  }
	
	  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
	  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
	
	  // (public) test primality with certainty >= 1-.5^t
	  function bnIsProbablePrime(t) {
	    var i,
	        x = this.abs();
	    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
	      for (i = 0; i < lowprimes.length; ++i) {
	        if (x[0] == lowprimes[i]) return true;
	      }return false;
	    }
	    if (x.isEven()) return false;
	    i = 1;
	    while (i < lowprimes.length) {
	      var m = lowprimes[i],
	          j = i + 1;
	      while (j < lowprimes.length && m < lplim) {
	        m *= lowprimes[j++];
	      }m = x.modInt(m);
	      while (i < j) {
	        if (m % lowprimes[i++] == 0) return false;
	      }
	    }
	    return x.millerRabin(t);
	  }
	
	  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
	  function bnpMillerRabin(t) {
	    var n1 = this.subtract(BigInteger.ONE);
	    var k = n1.getLowestSetBit();
	    if (k <= 0) return false;
	    var r = n1.shiftRight(k);
	    t = t + 1 >> 1;
	    if (t > lowprimes.length) t = lowprimes.length;
	    var a = nbi();
	    for (var i = 0; i < t; ++i) {
	      //Pick bases at random, instead of starting at 2
	      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
	      var y = a.modPow(r, this);
	      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
	        var j = 1;
	        while (j++ < k && y.compareTo(n1) != 0) {
	          y = y.modPowInt(2, this);
	          if (y.compareTo(BigInteger.ONE) == 0) return false;
	        }
	        if (y.compareTo(n1) != 0) return false;
	      }
	    }
	    return true;
	  }
	
	  // protected
	  BigInteger.prototype.chunkSize = bnpChunkSize;
	  BigInteger.prototype.toRadix = bnpToRadix;
	  BigInteger.prototype.fromRadix = bnpFromRadix;
	  BigInteger.prototype.fromNumber = bnpFromNumber;
	  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
	  BigInteger.prototype.changeBit = bnpChangeBit;
	  BigInteger.prototype.addTo = bnpAddTo;
	  BigInteger.prototype.dMultiply = bnpDMultiply;
	  BigInteger.prototype.dAddOffset = bnpDAddOffset;
	  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
	  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
	  BigInteger.prototype.modInt = bnpModInt;
	  BigInteger.prototype.millerRabin = bnpMillerRabin;
	
	  // public
	  BigInteger.prototype.clone = bnClone;
	  BigInteger.prototype.intValue = bnIntValue;
	  BigInteger.prototype.byteValue = bnByteValue;
	  BigInteger.prototype.shortValue = bnShortValue;
	  BigInteger.prototype.signum = bnSigNum;
	  BigInteger.prototype.toByteArray = bnToByteArray;
	  BigInteger.prototype.equals = bnEquals;
	  BigInteger.prototype.min = bnMin;
	  BigInteger.prototype.max = bnMax;
	  BigInteger.prototype.and = bnAnd;
	  BigInteger.prototype.or = bnOr;
	  BigInteger.prototype.xor = bnXor;
	  BigInteger.prototype.andNot = bnAndNot;
	  BigInteger.prototype.not = bnNot;
	  BigInteger.prototype.shiftLeft = bnShiftLeft;
	  BigInteger.prototype.shiftRight = bnShiftRight;
	  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
	  BigInteger.prototype.bitCount = bnBitCount;
	  BigInteger.prototype.testBit = bnTestBit;
	  BigInteger.prototype.setBit = bnSetBit;
	  BigInteger.prototype.clearBit = bnClearBit;
	  BigInteger.prototype.flipBit = bnFlipBit;
	  BigInteger.prototype.add = bnAdd;
	  BigInteger.prototype.subtract = bnSubtract;
	  BigInteger.prototype.multiply = bnMultiply;
	  BigInteger.prototype.divide = bnDivide;
	  BigInteger.prototype.remainder = bnRemainder;
	  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
	  BigInteger.prototype.modPow = bnModPow;
	  BigInteger.prototype.modInverse = bnModInverse;
	  BigInteger.prototype.pow = bnPow;
	  BigInteger.prototype.gcd = bnGCD;
	  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
	
	  // JSBN-specific extension
	  BigInteger.prototype.square = bnSquare;
	
	  // Expose the Barrett function
	  BigInteger.prototype.Barrett = Barrett;
	
	  // BigInteger interfaces not implemented in jsbn:
	
	  // BigInteger(int signum, byte[] magnitude)
	  // double doubleValue()
	  // float floatValue()
	  // int hashCode()
	  // long longValue()
	  // static BigInteger valueOf(long val)
	
	  // Random number generator - requires a PRNG backend, e.g. prng4.js
	
	  // For best results, put code like
	  // <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>
	  // in your main HTML document.
	
	  var rng_state;
	  var rng_pool;
	  var rng_pptr;
	
	  // Mix in a 32-bit integer into the pool
	  function rng_seed_int(x) {
	    rng_pool[rng_pptr++] ^= x & 255;
	    rng_pool[rng_pptr++] ^= x >> 8 & 255;
	    rng_pool[rng_pptr++] ^= x >> 16 & 255;
	    rng_pool[rng_pptr++] ^= x >> 24 & 255;
	    if (rng_pptr >= rng_psize) rng_pptr -= rng_psize;
	  }
	
	  // Mix in the current time (w/milliseconds) into the pool
	  function rng_seed_time() {
	    rng_seed_int(new Date().getTime());
	  }
	
	  // Initialize the pool with junk if needed.
	  if (rng_pool == null) {
	    rng_pool = new Array();
	    rng_pptr = 0;
	    var t;
	    if (typeof window !== "undefined" && window.crypto) {
	      if (window.crypto.getRandomValues) {
	        // Use webcrypto if available
	        var ua = new Uint8Array(32);
	        window.crypto.getRandomValues(ua);
	        for (t = 0; t < 32; ++t) {
	          rng_pool[rng_pptr++] = ua[t];
	        }
	      } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
	        // Extract entropy (256 bits) from NS4 RNG if available
	        var z = window.crypto.random(32);
	        for (t = 0; t < z.length; ++t) {
	          rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
	        }
	      }
	    }
	    while (rng_pptr < rng_psize) {
	      // extract some randomness from Math.random()
	      t = Math.floor(65536 * Math.random());
	      rng_pool[rng_pptr++] = t >>> 8;
	      rng_pool[rng_pptr++] = t & 255;
	    }
	    rng_pptr = 0;
	    rng_seed_time();
	    //rng_seed_int(window.screenX);
	    //rng_seed_int(window.screenY);
	  }
	
	  function rng_get_byte() {
	    if (rng_state == null) {
	      rng_seed_time();
	      rng_state = prng_newstate();
	      rng_state.init(rng_pool);
	      for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {
	        rng_pool[rng_pptr] = 0;
	      }rng_pptr = 0;
	      //rng_pool = null;
	    }
	    // TODO: allow reseeding after first request
	    return rng_state.next();
	  }
	
	  function rng_get_bytes(ba) {
	    var i;
	    for (i = 0; i < ba.length; ++i) {
	      ba[i] = rng_get_byte();
	    }
	  }
	
	  function SecureRandom() {}
	
	  SecureRandom.prototype.nextBytes = rng_get_bytes;
	
	  // prng4.js - uses Arcfour as a PRNG
	
	  function Arcfour() {
	    this.i = 0;
	    this.j = 0;
	    this.S = new Array();
	  }
	
	  // Initialize arcfour context from key, an array of ints, each from [0..255]
	  function ARC4init(key) {
	    var i, j, t;
	    for (i = 0; i < 256; ++i) {
	      this.S[i] = i;
	    }j = 0;
	    for (i = 0; i < 256; ++i) {
	      j = j + this.S[i] + key[i % key.length] & 255;
	      t = this.S[i];
	      this.S[i] = this.S[j];
	      this.S[j] = t;
	    }
	    this.i = 0;
	    this.j = 0;
	  }
	
	  function ARC4next() {
	    var t;
	    this.i = this.i + 1 & 255;
	    this.j = this.j + this.S[this.i] & 255;
	    t = this.S[this.i];
	    this.S[this.i] = this.S[this.j];
	    this.S[this.j] = t;
	    return this.S[t + this.S[this.i] & 255];
	  }
	
	  Arcfour.prototype.init = ARC4init;
	  Arcfour.prototype.next = ARC4next;
	
	  // Plug in your RNG constructor here
	  function prng_newstate() {
	    return new Arcfour();
	  }
	
	  // Pool size must be a multiple of 4 and greater than 32.
	  // An array of bytes the size of the pool will be passed to init()
	  var rng_psize = 256;
	
	  BigInteger.SecureRandom = SecureRandom;
	  BigInteger.BigInteger = BigInteger;
	  if (true) {
	    exports = module.exports = BigInteger;
	  } else {
	    this.BigInteger = BigInteger;
	    this.SecureRandom = SecureRandom;
	  }
	}).call(undefined);

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var base64 = __webpack_require__(20);
	
	function padding(str) {
	  var mod = str.length % 4;
	  var pad = 4 - mod;
	
	  if (mod === 0) {
	    return str;
	  }
	
	  return str + new Array(1 + pad).join('=');
	}
	
	function byteArrayToString(array) {
	  var result = "";
	  for (var i = 0; i < array.length; i++) {
	    result += String.fromCharCode(array[i]);
	  }
	  return result;
	}
	
	function stringToByteArray(str) {
	  var arr = new Array(str.length);
	  for (var a = 0; a < str.length; a++) {
	    arr[a] = str.charCodeAt(a);
	  }
	  return arr;
	}
	
	function byteArrayToHex(raw) {
	  var HEX = '';
	
	  for (var i = 0; i < raw.length; i++) {
	    var _hex = raw[i].toString(16);
	    HEX += _hex.length === 2 ? _hex : '0' + _hex;
	  }
	
	  return HEX;
	}
	
	function encodeString(str) {
	  return base64.fromByteArray(stringToByteArray(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p1) {
	    return String.fromCharCode('0x' + p1);
	  }))).replace(/\+/g, '-') // Convert '+' to '-'
	  .replace(/\//g, '_'); // Convert '/' to '_';
	}
	
	function decodeToString(str) {
	  str = padding(str).replace(/\-/g, '+') // Convert '-' to '+'
	  .replace(/_/g, '/'); // Convert '_' to '/'
	
	  return decodeURIComponent(byteArrayToString(base64.toByteArray(str)).split('').map(function (c) {
	    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
	  }).join(''));
	}
	
	function decodeToHEX(str) {
	  return byteArrayToHex(base64.toByteArray(padding(str)));
	}
	
	function base64ToBase64Url(base64String) {
	  var SAFE_URL_ENCODING_MAPPING = {
	    "+": "-",
	    "/": "_",
	    "=": ""
	  };
	
	  return base64String.replace(/[+/=]/g, function (m) {
	    return SAFE_URL_ENCODING_MAPPING[m];
	  });
	}
	
	module.exports = {
	  encodeString: encodeString,
	  decodeToString: decodeToString,
	  byteArrayToString: byteArrayToString,
	  stringToByteArray: stringToByteArray,
	  padding: padding,
	  byteArrayToHex: byteArrayToHex,
	  decodeToHEX: decodeToHEX,
	  base64ToBase64Url: base64ToBase64Url
	};

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	'use strict';
	
	exports.byteLength = byteLength;
	exports.toByteArray = toByteArray;
	exports.fromByteArray = fromByteArray;
	
	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i];
	  revLookup[code.charCodeAt(i)] = i;
	}
	
	revLookup['-'.charCodeAt(0)] = 62;
	revLookup['_'.charCodeAt(0)] = 63;
	
	function placeHoldersCount(b64) {
	  var len = b64.length;
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4');
	  }
	
	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
	}
	
	function byteLength(b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return b64.length * 3 / 4 - placeHoldersCount(b64);
	}
	
	function toByteArray(b64) {
	  var i, j, l, tmp, placeHolders, arr;
	  var len = b64.length;
	  placeHolders = placeHoldersCount(b64);
	
	  arr = new Arr(len * 3 / 4 - placeHolders);
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len;
	
	  var L = 0;
	
	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
	    arr[L++] = tmp >> 16 & 0xFF;
	    arr[L++] = tmp >> 8 & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }
	
	  if (placeHolders === 2) {
	    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
	    arr[L++] = tmp & 0xFF;
	  } else if (placeHolders === 1) {
	    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
	    arr[L++] = tmp >> 8 & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }
	
	  return arr;
	}
	
	function tripletToBase64(num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
	}
	
	function encodeChunk(uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('');
	}
	
	function fromByteArray(uint8) {
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var output = '';
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    output += lookup[tmp >> 2];
	    output += lookup[tmp << 4 & 0x3F];
	    output += '==';
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
	    output += lookup[tmp >> 10];
	    output += lookup[tmp >> 4 & 0x3F];
	    output += lookup[tmp << 2 & 0x3F];
	    output += '=';
	  }
	
	  parts.push(output);
	
	  return parts.join('');
	}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var urljoin = __webpack_require__(22);
	var base64 = __webpack_require__(19);
	var request = __webpack_require__(23);
	
	function process(jwks) {
	  var modulus = base64.decodeToHEX(jwks.n);
	  var exp = base64.decodeToHEX(jwks.e);
	
	  return {
	    modulus: modulus,
	    exp: exp
	  };
	}
	
	function getJWKS(options) {
	  var url = options.jwksURI || urljoin(options.iss, '.well-known', 'jwks.json');
	
	  return request.get(url).end(function (err, data) {
	    var matchingKey = null;
	    var a;
	    var key;
	
	    if (err) {
	      return Promise.reject(err);
	    }
	
	    // eslint-disable-next-line no-plusplus
	    for (a = 0; a < data.body.keys.length && matchingKey === null; a++) {
	      key = data.body.keys[a];
	      if (key.kid === options.kid) {
	        matchingKey = key;
	      }
	    }
	
	    return Promise.resolve(process(matchingKey));
	  });
	}
	
	module.exports = {
	  process: process,
	  getJWKS: getJWKS
	};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	(function (name, context, definition) {
	  if (typeof module !== 'undefined' && module.exports) module.exports = definition();else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else context[name] = definition();
	})('urljoin', undefined, function () {
	
	  function normalize(str, options) {
	
	    // make sure protocol is followed by two slashes
	    str = str.replace(/:\//g, '://');
	
	    // remove consecutive slashes
	    str = str.replace(/([^:\s])\/+/g, '$1/');
	
	    // remove trailing slash before parameters or hash
	    str = str.replace(/\/(\?|&|#[^!])/g, '$1');
	
	    // replace ? in parameters with &
	    str = str.replace(/(\?.+)\?/g, '$1&');
	
	    return str;
	  }
	
	  return function () {
	    var input = arguments;
	    var options = {};
	
	    if (_typeof(arguments[0]) === 'object') {
	      // new syntax with array and options
	      input = arguments[0];
	      options = arguments[1] || {};
	    }
	
	    var joined = [].slice.call(input, 0).join('/');
	    return normalize(joined, options);
	  };
	});

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * Root reference for iframes.
	 */
	
	var root;
	if (typeof window !== 'undefined') {
	  // Browser window
	  root = window;
	} else if (typeof self !== 'undefined') {
	  // Web Worker
	  root = self;
	} else {
	  // Other environments
	  console.warn("Using browser-only version of superagent in non-browser environment");
	  root = undefined;
	}
	
	var Emitter = __webpack_require__(24);
	var RequestBase = __webpack_require__(25);
	var isObject = __webpack_require__(26);
	var ResponseBase = __webpack_require__(27);
	var Agent = __webpack_require__(29);
	
	/**
	 * Noop.
	 */
	
	function noop() {};
	
	/**
	 * Expose `request`.
	 */
	
	var request = exports = module.exports = function (method, url) {
	  // callback
	  if ('function' == typeof url) {
	    return new exports.Request('GET', method).end(url);
	  }
	
	  // url first
	  if (1 == arguments.length) {
	    return new exports.Request('GET', method);
	  }
	
	  return new exports.Request(method, url);
	};
	
	exports.Request = Request;
	
	/**
	 * Determine XHR.
	 */
	
	request.getXHR = function () {
	  if (root.XMLHttpRequest && (!root.location || 'file:' != root.location.protocol || !root.ActiveXObject)) {
	    return new XMLHttpRequest();
	  } else {
	    try {
	      return new ActiveXObject('Microsoft.XMLHTTP');
	    } catch (e) {}
	    try {
	      return new ActiveXObject('Msxml2.XMLHTTP.6.0');
	    } catch (e) {}
	    try {
	      return new ActiveXObject('Msxml2.XMLHTTP.3.0');
	    } catch (e) {}
	    try {
	      return new ActiveXObject('Msxml2.XMLHTTP');
	    } catch (e) {}
	  }
	  throw Error("Browser-only version of superagent could not find XHR");
	};
	
	/**
	 * Removes leading and trailing whitespace, added to support IE.
	 *
	 * @param {String} s
	 * @return {String}
	 * @api private
	 */
	
	var trim = ''.trim ? function (s) {
	  return s.trim();
	} : function (s) {
	  return s.replace(/(^\s*|\s*$)/g, '');
	};
	
	/**
	 * Serialize the given `obj`.
	 *
	 * @param {Object} obj
	 * @return {String}
	 * @api private
	 */
	
	function serialize(obj) {
	  if (!isObject(obj)) return obj;
	  var pairs = [];
	  for (var key in obj) {
	    pushEncodedKeyValuePair(pairs, key, obj[key]);
	  }
	  return pairs.join('&');
	}
	
	/**
	 * Helps 'serialize' with serializing arrays.
	 * Mutates the pairs array.
	 *
	 * @param {Array} pairs
	 * @param {String} key
	 * @param {Mixed} val
	 */
	
	function pushEncodedKeyValuePair(pairs, key, val) {
	  if (val != null) {
	    if (Array.isArray(val)) {
	      val.forEach(function (v) {
	        pushEncodedKeyValuePair(pairs, key, v);
	      });
	    } else if (isObject(val)) {
	      for (var subkey in val) {
	        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
	      }
	    } else {
	      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
	    }
	  } else if (val === null) {
	    pairs.push(encodeURIComponent(key));
	  }
	}
	
	/**
	 * Expose serialization method.
	 */
	
	request.serializeObject = serialize;
	
	/**
	  * Parse the given x-www-form-urlencoded `str`.
	  *
	  * @param {String} str
	  * @return {Object}
	  * @api private
	  */
	
	function parseString(str) {
	  var obj = {};
	  var pairs = str.split('&');
	  var pair;
	  var pos;
	
	  for (var i = 0, len = pairs.length; i < len; ++i) {
	    pair = pairs[i];
	    pos = pair.indexOf('=');
	    if (pos == -1) {
	      obj[decodeURIComponent(pair)] = '';
	    } else {
	      obj[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
	    }
	  }
	
	  return obj;
	}
	
	/**
	 * Expose parser.
	 */
	
	request.parseString = parseString;
	
	/**
	 * Default MIME type map.
	 *
	 *     superagent.types.xml = 'application/xml';
	 *
	 */
	
	request.types = {
	  html: 'text/html',
	  json: 'application/json',
	  xml: 'text/xml',
	  urlencoded: 'application/x-www-form-urlencoded',
	  'form': 'application/x-www-form-urlencoded',
	  'form-data': 'application/x-www-form-urlencoded'
	};
	
	/**
	 * Default serialization map.
	 *
	 *     superagent.serialize['application/xml'] = function(obj){
	 *       return 'generated xml here';
	 *     };
	 *
	 */
	
	request.serialize = {
	  'application/x-www-form-urlencoded': serialize,
	  'application/json': JSON.stringify
	};
	
	/**
	  * Default parsers.
	  *
	  *     superagent.parse['application/xml'] = function(str){
	  *       return { object parsed from str };
	  *     };
	  *
	  */
	
	request.parse = {
	  'application/x-www-form-urlencoded': parseString,
	  'application/json': JSON.parse
	};
	
	/**
	 * Parse the given header `str` into
	 * an object containing the mapped fields.
	 *
	 * @param {String} str
	 * @return {Object}
	 * @api private
	 */
	
	function parseHeader(str) {
	  var lines = str.split(/\r?\n/);
	  var fields = {};
	  var index;
	  var line;
	  var field;
	  var val;
	
	  for (var i = 0, len = lines.length; i < len; ++i) {
	    line = lines[i];
	    index = line.indexOf(':');
	    if (index === -1) {
	      // could be empty line, just skip it
	      continue;
	    }
	    field = line.slice(0, index).toLowerCase();
	    val = trim(line.slice(index + 1));
	    fields[field] = val;
	  }
	
	  return fields;
	}
	
	/**
	 * Check if `mime` is json or has +json structured syntax suffix.
	 *
	 * @param {String} mime
	 * @return {Boolean}
	 * @api private
	 */
	
	function isJSON(mime) {
	  // should match /json or +json
	  // but not /json-seq
	  return (/[\/+]json($|[^-\w])/.test(mime)
	  );
	}
	
	/**
	 * Initialize a new `Response` with the given `xhr`.
	 *
	 *  - set flags (.ok, .error, etc)
	 *  - parse header
	 *
	 * Examples:
	 *
	 *  Aliasing `superagent` as `request` is nice:
	 *
	 *      request = superagent;
	 *
	 *  We can use the promise-like API, or pass callbacks:
	 *
	 *      request.get('/').end(function(res){});
	 *      request.get('/', function(res){});
	 *
	 *  Sending data can be chained:
	 *
	 *      request
	 *        .post('/user')
	 *        .send({ name: 'tj' })
	 *        .end(function(res){});
	 *
	 *  Or passed to `.send()`:
	 *
	 *      request
	 *        .post('/user')
	 *        .send({ name: 'tj' }, function(res){});
	 *
	 *  Or passed to `.post()`:
	 *
	 *      request
	 *        .post('/user', { name: 'tj' })
	 *        .end(function(res){});
	 *
	 * Or further reduced to a single call for simple cases:
	 *
	 *      request
	 *        .post('/user', { name: 'tj' }, function(res){});
	 *
	 * @param {XMLHTTPRequest} xhr
	 * @param {Object} options
	 * @api private
	 */
	
	function Response(req) {
	  this.req = req;
	  this.xhr = this.req.xhr;
	  // responseText is accessible only if responseType is '' or 'text' and on older browsers
	  this.text = this.req.method != 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text') || typeof this.xhr.responseType === 'undefined' ? this.xhr.responseText : null;
	  this.statusText = this.req.xhr.statusText;
	  var status = this.xhr.status;
	  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
	  if (status === 1223) {
	    status = 204;
	  }
	  this._setStatusProperties(status);
	  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
	  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
	  // getResponseHeader still works. so we get content-type even if getting
	  // other headers fails.
	  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
	  this._setHeaderProperties(this.header);
	
	  if (null === this.text && req._responseType) {
	    this.body = this.xhr.response;
	  } else {
	    this.body = this.req.method != 'HEAD' ? this._parseBody(this.text ? this.text : this.xhr.response) : null;
	  }
	}
	
	ResponseBase(Response.prototype);
	
	/**
	 * Parse the given body `str`.
	 *
	 * Used for auto-parsing of bodies. Parsers
	 * are defined on the `superagent.parse` object.
	 *
	 * @param {String} str
	 * @return {Mixed}
	 * @api private
	 */
	
	Response.prototype._parseBody = function (str) {
	  var parse = request.parse[this.type];
	  if (this.req._parser) {
	    return this.req._parser(this, str);
	  }
	  if (!parse && isJSON(this.type)) {
	    parse = request.parse['application/json'];
	  }
	  return parse && str && (str.length || str instanceof Object) ? parse(str) : null;
	};
	
	/**
	 * Return an `Error` representative of this response.
	 *
	 * @return {Error}
	 * @api public
	 */
	
	Response.prototype.toError = function () {
	  var req = this.req;
	  var method = req.method;
	  var url = req.url;
	
	  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
	  var err = new Error(msg);
	  err.status = this.status;
	  err.method = method;
	  err.url = url;
	
	  return err;
	};
	
	/**
	 * Expose `Response`.
	 */
	
	request.Response = Response;
	
	/**
	 * Initialize a new `Request` with the given `method` and `url`.
	 *
	 * @param {String} method
	 * @param {String} url
	 * @api public
	 */
	
	function Request(method, url) {
	  var self = this;
	  this._query = this._query || [];
	  this.method = method;
	  this.url = url;
	  this.header = {}; // preserves header name case
	  this._header = {}; // coerces header names to lowercase
	  this.on('end', function () {
	    var err = null;
	    var res = null;
	
	    try {
	      res = new Response(self);
	    } catch (e) {
	      err = new Error('Parser is unable to parse the response');
	      err.parse = true;
	      err.original = e;
	      // issue #675: return the raw response if the response parsing fails
	      if (self.xhr) {
	        // ie9 doesn't have 'response' property
	        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
	        // issue #876: return the http status code if the response parsing fails
	        err.status = self.xhr.status ? self.xhr.status : null;
	        err.statusCode = err.status; // backwards-compat only
	      } else {
	        err.rawResponse = null;
	        err.status = null;
	      }
	
	      return self.callback(err);
	    }
	
	    self.emit('response', res);
	
	    var new_err;
	    try {
	      if (!self._isResponseOK(res)) {
	        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
	      }
	    } catch (custom_err) {
	      new_err = custom_err; // ok() callback can throw
	    }
	
	    // #1000 don't catch errors from the callback to avoid double calling it
	    if (new_err) {
	      new_err.original = err;
	      new_err.response = res;
	      new_err.status = res.status;
	      self.callback(new_err, res);
	    } else {
	      self.callback(null, res);
	    }
	  });
	}
	
	/**
	 * Mixin `Emitter` and `RequestBase`.
	 */
	
	Emitter(Request.prototype);
	RequestBase(Request.prototype);
	
	/**
	 * Set Content-Type to `type`, mapping values from `request.types`.
	 *
	 * Examples:
	 *
	 *      superagent.types.xml = 'application/xml';
	 *
	 *      request.post('/')
	 *        .type('xml')
	 *        .send(xmlstring)
	 *        .end(callback);
	 *
	 *      request.post('/')
	 *        .type('application/xml')
	 *        .send(xmlstring)
	 *        .end(callback);
	 *
	 * @param {String} type
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.type = function (type) {
	  this.set('Content-Type', request.types[type] || type);
	  return this;
	};
	
	/**
	 * Set Accept to `type`, mapping values from `request.types`.
	 *
	 * Examples:
	 *
	 *      superagent.types.json = 'application/json';
	 *
	 *      request.get('/agent')
	 *        .accept('json')
	 *        .end(callback);
	 *
	 *      request.get('/agent')
	 *        .accept('application/json')
	 *        .end(callback);
	 *
	 * @param {String} accept
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.accept = function (type) {
	  this.set('Accept', request.types[type] || type);
	  return this;
	};
	
	/**
	 * Set Authorization field value with `user` and `pass`.
	 *
	 * @param {String} user
	 * @param {String} [pass] optional in case of using 'bearer' as type
	 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.auth = function (user, pass, options) {
	  if (1 === arguments.length) pass = '';
	  if ((typeof pass === 'undefined' ? 'undefined' : _typeof(pass)) === 'object' && pass !== null) {
	    // pass is optional and can be replaced with options
	    options = pass;
	    pass = '';
	  }
	  if (!options) {
	    options = {
	      type: 'function' === typeof btoa ? 'basic' : 'auto'
	    };
	  }
	
	  var encoder = function encoder(string) {
	    if ('function' === typeof btoa) {
	      return btoa(string);
	    }
	    throw new Error('Cannot use basic auth, btoa is not a function');
	  };
	
	  return this._auth(user, pass, options, encoder);
	};
	
	/**
	 * Add query-string `val`.
	 *
	 * Examples:
	 *
	 *   request.get('/shoes')
	 *     .query('size=10')
	 *     .query({ color: 'blue' })
	 *
	 * @param {Object|String} val
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.query = function (val) {
	  if ('string' != typeof val) val = serialize(val);
	  if (val) this._query.push(val);
	  return this;
	};
	
	/**
	 * Queue the given `file` as an attachment to the specified `field`,
	 * with optional `options` (or filename).
	 *
	 * ``` js
	 * request.post('/upload')
	 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
	 *   .end(callback);
	 * ```
	 *
	 * @param {String} field
	 * @param {Blob|File} file
	 * @param {String|Object} options
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.attach = function (field, file, options) {
	  if (file) {
	    if (this._data) {
	      throw Error("superagent can't mix .send() and .attach()");
	    }
	
	    this._getFormData().append(field, file, options || file.name);
	  }
	  return this;
	};
	
	Request.prototype._getFormData = function () {
	  if (!this._formData) {
	    this._formData = new root.FormData();
	  }
	  return this._formData;
	};
	
	/**
	 * Invoke the callback with `err` and `res`
	 * and handle arity check.
	 *
	 * @param {Error} err
	 * @param {Response} res
	 * @api private
	 */
	
	Request.prototype.callback = function (err, res) {
	  if (this._shouldRetry(err, res)) {
	    return this._retry();
	  }
	
	  var fn = this._callback;
	  this.clearTimeout();
	
	  if (err) {
	    if (this._maxRetries) err.retries = this._retries - 1;
	    this.emit('error', err);
	  }
	
	  fn(err, res);
	};
	
	/**
	 * Invoke callback with x-domain error.
	 *
	 * @api private
	 */
	
	Request.prototype.crossDomainError = function () {
	  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
	  err.crossDomain = true;
	
	  err.status = this.status;
	  err.method = this.method;
	  err.url = this.url;
	
	  this.callback(err);
	};
	
	// This only warns, because the request is still likely to work
	Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function () {
	  console.warn("This is not supported in browser version of superagent");
	  return this;
	};
	
	// This throws, because it can't send/receive data as expected
	Request.prototype.pipe = Request.prototype.write = function () {
	  throw Error("Streaming is not supported in browser version of superagent");
	};
	
	/**
	 * Check if `obj` is a host object,
	 * we don't want to serialize these :)
	 *
	 * @param {Object} obj
	 * @return {Boolean}
	 * @api private
	 */
	Request.prototype._isHost = function _isHost(obj) {
	  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
	  return obj && 'object' === (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
	};
	
	/**
	 * Initiate request, invoking callback `fn(res)`
	 * with an instanceof `Response`.
	 *
	 * @param {Function} fn
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.end = function (fn) {
	  if (this._endCalled) {
	    console.warn("Warning: .end() was called twice. This is not supported in superagent");
	  }
	  this._endCalled = true;
	
	  // store callback
	  this._callback = fn || noop;
	
	  // querystring
	  this._finalizeQueryString();
	
	  return this._end();
	};
	
	Request.prototype._end = function () {
	  var self = this;
	  var xhr = this.xhr = request.getXHR();
	  var data = this._formData || this._data;
	
	  this._setTimeouts();
	
	  // state change
	  xhr.onreadystatechange = function () {
	    var readyState = xhr.readyState;
	    if (readyState >= 2 && self._responseTimeoutTimer) {
	      clearTimeout(self._responseTimeoutTimer);
	    }
	    if (4 != readyState) {
	      return;
	    }
	
	    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
	    // result in the error "Could not complete the operation due to error c00c023f"
	    var status;
	    try {
	      status = xhr.status;
	    } catch (e) {
	      status = 0;
	    }
	
	    if (!status) {
	      if (self.timedout || self._aborted) return;
	      return self.crossDomainError();
	    }
	    self.emit('end');
	  };
	
	  // progress
	  var handleProgress = function handleProgress(direction, e) {
	    if (e.total > 0) {
	      e.percent = e.loaded / e.total * 100;
	    }
	    e.direction = direction;
	    self.emit('progress', e);
	  };
	  if (this.hasListeners('progress')) {
	    try {
	      xhr.onprogress = handleProgress.bind(null, 'download');
	      if (xhr.upload) {
	        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
	      }
	    } catch (e) {
	      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
	      // Reported here:
	      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
	    }
	  }
	
	  // initiate request
	  try {
	    if (this.username && this.password) {
	      xhr.open(this.method, this.url, true, this.username, this.password);
	    } else {
	      xhr.open(this.method, this.url, true);
	    }
	  } catch (err) {
	    // see #1149
	    return this.callback(err);
	  }
	
	  // CORS
	  if (this._withCredentials) xhr.withCredentials = true;
	
	  // body
	  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
	    // serialize stuff
	    var contentType = this._header['content-type'];
	    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
	    if (!serialize && isJSON(contentType)) {
	      serialize = request.serialize['application/json'];
	    }
	    if (serialize) data = serialize(data);
	  }
	
	  // set header fields
	  for (var field in this.header) {
	    if (null == this.header[field]) continue;
	
	    if (this.header.hasOwnProperty(field)) xhr.setRequestHeader(field, this.header[field]);
	  }
	
	  if (this._responseType) {
	    xhr.responseType = this._responseType;
	  }
	
	  // send stuff
	  this.emit('request', this);
	
	  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
	  // We need null here if data is undefined
	  xhr.send(typeof data !== 'undefined' ? data : null);
	  return this;
	};
	
	request.agent = function () {
	  return new Agent();
	};
	
	["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function (method) {
	  Agent.prototype[method.toLowerCase()] = function (url, fn) {
	    var req = new request.Request(method, url);
	    this._setDefaults(req);
	    if (fn) {
	      req.end(fn);
	    }
	    return req;
	  };
	});
	
	Agent.prototype.del = Agent.prototype['delete'];
	
	/**
	 * GET `url` with optional callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed|Function} [data] or fn
	 * @param {Function} [fn]
	 * @return {Request}
	 * @api public
	 */
	
	request.get = function (url, data, fn) {
	  var req = request('GET', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.query(data);
	  if (fn) req.end(fn);
	  return req;
	};
	
	/**
	 * HEAD `url` with optional callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed|Function} [data] or fn
	 * @param {Function} [fn]
	 * @return {Request}
	 * @api public
	 */
	
	request.head = function (url, data, fn) {
	  var req = request('HEAD', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.query(data);
	  if (fn) req.end(fn);
	  return req;
	};
	
	/**
	 * OPTIONS query to `url` with optional callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed|Function} [data] or fn
	 * @param {Function} [fn]
	 * @return {Request}
	 * @api public
	 */
	
	request.options = function (url, data, fn) {
	  var req = request('OPTIONS', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.send(data);
	  if (fn) req.end(fn);
	  return req;
	};
	
	/**
	 * DELETE `url` with optional `data` and callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed} [data]
	 * @param {Function} [fn]
	 * @return {Request}
	 * @api public
	 */
	
	function del(url, data, fn) {
	  var req = request('DELETE', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.send(data);
	  if (fn) req.end(fn);
	  return req;
	}
	
	request['del'] = del;
	request['delete'] = del;
	
	/**
	 * PATCH `url` with optional `data` and callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed} [data]
	 * @param {Function} [fn]
	 * @return {Request}
	 * @api public
	 */
	
	request.patch = function (url, data, fn) {
	  var req = request('PATCH', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.send(data);
	  if (fn) req.end(fn);
	  return req;
	};
	
	/**
	 * POST `url` with optional `data` and callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed} [data]
	 * @param {Function} [fn]
	 * @return {Request}
	 * @api public
	 */
	
	request.post = function (url, data, fn) {
	  var req = request('POST', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.send(data);
	  if (fn) req.end(fn);
	  return req;
	};
	
	/**
	 * PUT `url` with optional `data` and callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed|Function} [data] or fn
	 * @param {Function} [fn]
	 * @return {Request}
	 * @api public
	 */
	
	request.put = function (url, data, fn) {
	  var req = request('PUT', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.send(data);
	  if (fn) req.end(fn);
	  return req;
	};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Expose `Emitter`.
	 */
	
	if (true) {
	  module.exports = Emitter;
	}
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function (event, fn) {
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function (event) {
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1),
	      callbacks = this._callbacks['$' + event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function (event) {
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function (event) {
	  return !!this.listeners(event).length;
	};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Module of mixed-in functions shared between node and client code
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var isObject = __webpack_require__(26);
	
	/**
	 * Expose `RequestBase`.
	 */
	
	module.exports = RequestBase;
	
	/**
	 * Initialize a new `RequestBase`.
	 *
	 * @api public
	 */
	
	function RequestBase(obj) {
	  if (obj) return mixin(obj);
	}
	
	/**
	 * Mixin the prototype properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in RequestBase.prototype) {
	    obj[key] = RequestBase.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Clear previous timeout.
	 *
	 * @return {Request} for chaining
	 * @api public
	 */
	
	RequestBase.prototype.clearTimeout = function _clearTimeout() {
	  clearTimeout(this._timer);
	  clearTimeout(this._responseTimeoutTimer);
	  delete this._timer;
	  delete this._responseTimeoutTimer;
	  return this;
	};
	
	/**
	 * Override default response body parser
	 *
	 * This function will be called to convert incoming data into request.body
	 *
	 * @param {Function}
	 * @api public
	 */
	
	RequestBase.prototype.parse = function parse(fn) {
	  this._parser = fn;
	  return this;
	};
	
	/**
	 * Set format of binary response body.
	 * In browser valid formats are 'blob' and 'arraybuffer',
	 * which return Blob and ArrayBuffer, respectively.
	 *
	 * In Node all values result in Buffer.
	 *
	 * Examples:
	 *
	 *      req.get('/')
	 *        .responseType('blob')
	 *        .end(callback);
	 *
	 * @param {String} val
	 * @return {Request} for chaining
	 * @api public
	 */
	
	RequestBase.prototype.responseType = function (val) {
	  this._responseType = val;
	  return this;
	};
	
	/**
	 * Override default request body serializer
	 *
	 * This function will be called to convert data set via .send or .attach into payload to send
	 *
	 * @param {Function}
	 * @api public
	 */
	
	RequestBase.prototype.serialize = function serialize(fn) {
	  this._serializer = fn;
	  return this;
	};
	
	/**
	 * Set timeouts.
	 *
	 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
	 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
	 *
	 * Value of 0 or false means no timeout.
	 *
	 * @param {Number|Object} ms or {response, deadline}
	 * @return {Request} for chaining
	 * @api public
	 */
	
	RequestBase.prototype.timeout = function timeout(options) {
	  if (!options || 'object' !== (typeof options === 'undefined' ? 'undefined' : _typeof(options))) {
	    this._timeout = options;
	    this._responseTimeout = 0;
	    return this;
	  }
	
	  for (var option in options) {
	    switch (option) {
	      case 'deadline':
	        this._timeout = options.deadline;
	        break;
	      case 'response':
	        this._responseTimeout = options.response;
	        break;
	      default:
	        console.warn("Unknown timeout option", option);
	    }
	  }
	  return this;
	};
	
	/**
	 * Set number of retry attempts on error.
	 *
	 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
	 *
	 * @param {Number} count
	 * @param {Function} [fn]
	 * @return {Request} for chaining
	 * @api public
	 */
	
	RequestBase.prototype.retry = function retry(count, fn) {
	  // Default to 1 if no count passed or true
	  if (arguments.length === 0 || count === true) count = 1;
	  if (count <= 0) count = 0;
	  this._maxRetries = count;
	  this._retries = 0;
	  this._retryCallback = fn;
	  return this;
	};
	
	var ERROR_CODES = ['ECONNRESET', 'ETIMEDOUT', 'EADDRINFO', 'ESOCKETTIMEDOUT'];
	
	/**
	 * Determine if a request should be retried.
	 * (Borrowed from segmentio/superagent-retry)
	 *
	 * @param {Error} err
	 * @param {Response} [res]
	 * @returns {Boolean}
	 */
	RequestBase.prototype._shouldRetry = function (err, res) {
	  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
	    return false;
	  }
	  if (this._retryCallback) {
	    try {
	      var override = this._retryCallback(err, res);
	      if (override === true) return true;
	      if (override === false) return false;
	      // undefined falls back to defaults
	    } catch (e) {
	      console.error(e);
	    }
	  }
	  if (res && res.status && res.status >= 500 && res.status != 501) return true;
	  if (err) {
	    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
	    // Superagent timeout
	    if (err.timeout && err.code == 'ECONNABORTED') return true;
	    if (err.crossDomain) return true;
	  }
	  return false;
	};
	
	/**
	 * Retry request
	 *
	 * @return {Request} for chaining
	 * @api private
	 */
	
	RequestBase.prototype._retry = function () {
	
	  this.clearTimeout();
	
	  // node
	  if (this.req) {
	    this.req = null;
	    this.req = this.request();
	  }
	
	  this._aborted = false;
	  this.timedout = false;
	
	  return this._end();
	};
	
	/**
	 * Promise support
	 *
	 * @param {Function} resolve
	 * @param {Function} [reject]
	 * @return {Request}
	 */
	
	RequestBase.prototype.then = function then(resolve, reject) {
	  if (!this._fullfilledPromise) {
	    var self = this;
	    if (this._endCalled) {
	      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
	    }
	    this._fullfilledPromise = new Promise(function (innerResolve, innerReject) {
	      self.end(function (err, res) {
	        if (err) innerReject(err);else innerResolve(res);
	      });
	    });
	  }
	  return this._fullfilledPromise.then(resolve, reject);
	};
	
	RequestBase.prototype.catch = function (cb) {
	  return this.then(undefined, cb);
	};
	
	/**
	 * Allow for extension
	 */
	
	RequestBase.prototype.use = function use(fn) {
	  fn(this);
	  return this;
	};
	
	RequestBase.prototype.ok = function (cb) {
	  if ('function' !== typeof cb) throw Error("Callback required");
	  this._okCallback = cb;
	  return this;
	};
	
	RequestBase.prototype._isResponseOK = function (res) {
	  if (!res) {
	    return false;
	  }
	
	  if (this._okCallback) {
	    return this._okCallback(res);
	  }
	
	  return res.status >= 200 && res.status < 300;
	};
	
	/**
	 * Get request header `field`.
	 * Case-insensitive.
	 *
	 * @param {String} field
	 * @return {String}
	 * @api public
	 */
	
	RequestBase.prototype.get = function (field) {
	  return this._header[field.toLowerCase()];
	};
	
	/**
	 * Get case-insensitive header `field` value.
	 * This is a deprecated internal API. Use `.get(field)` instead.
	 *
	 * (getHeader is no longer used internally by the superagent code base)
	 *
	 * @param {String} field
	 * @return {String}
	 * @api private
	 * @deprecated
	 */
	
	RequestBase.prototype.getHeader = RequestBase.prototype.get;
	
	/**
	 * Set header `field` to `val`, or multiple fields with one object.
	 * Case-insensitive.
	 *
	 * Examples:
	 *
	 *      req.get('/')
	 *        .set('Accept', 'application/json')
	 *        .set('X-API-Key', 'foobar')
	 *        .end(callback);
	 *
	 *      req.get('/')
	 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
	 *        .end(callback);
	 *
	 * @param {String|Object} field
	 * @param {String} val
	 * @return {Request} for chaining
	 * @api public
	 */
	
	RequestBase.prototype.set = function (field, val) {
	  if (isObject(field)) {
	    for (var key in field) {
	      this.set(key, field[key]);
	    }
	    return this;
	  }
	  this._header[field.toLowerCase()] = val;
	  this.header[field] = val;
	  return this;
	};
	
	/**
	 * Remove header `field`.
	 * Case-insensitive.
	 *
	 * Example:
	 *
	 *      req.get('/')
	 *        .unset('User-Agent')
	 *        .end(callback);
	 *
	 * @param {String} field
	 */
	RequestBase.prototype.unset = function (field) {
	  delete this._header[field.toLowerCase()];
	  delete this.header[field];
	  return this;
	};
	
	/**
	 * Write the field `name` and `val`, or multiple fields with one object
	 * for "multipart/form-data" request bodies.
	 *
	 * ``` js
	 * request.post('/upload')
	 *   .field('foo', 'bar')
	 *   .end(callback);
	 *
	 * request.post('/upload')
	 *   .field({ foo: 'bar', baz: 'qux' })
	 *   .end(callback);
	 * ```
	 *
	 * @param {String|Object} name
	 * @param {String|Blob|File|Buffer|fs.ReadStream} val
	 * @return {Request} for chaining
	 * @api public
	 */
	RequestBase.prototype.field = function (name, val) {
	  // name should be either a string or an object.
	  if (null === name || undefined === name) {
	    throw new Error('.field(name, val) name can not be empty');
	  }
	
	  if (this._data) {
	    console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
	  }
	
	  if (isObject(name)) {
	    for (var key in name) {
	      this.field(key, name[key]);
	    }
	    return this;
	  }
	
	  if (Array.isArray(val)) {
	    for (var i in val) {
	      this.field(name, val[i]);
	    }
	    return this;
	  }
	
	  // val should be defined now
	  if (null === val || undefined === val) {
	    throw new Error('.field(name, val) val can not be empty');
	  }
	  if ('boolean' === typeof val) {
	    val = '' + val;
	  }
	  this._getFormData().append(name, val);
	  return this;
	};
	
	/**
	 * Abort the request, and clear potential timeout.
	 *
	 * @return {Request}
	 * @api public
	 */
	RequestBase.prototype.abort = function () {
	  if (this._aborted) {
	    return this;
	  }
	  this._aborted = true;
	  this.xhr && this.xhr.abort(); // browser
	  this.req && this.req.abort(); // node
	  this.clearTimeout();
	  this.emit('abort');
	  return this;
	};
	
	RequestBase.prototype._auth = function (user, pass, options, base64Encoder) {
	  switch (options.type) {
	    case 'basic':
	      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));
	      break;
	
	    case 'auto':
	      this.username = user;
	      this.password = pass;
	      break;
	
	    case 'bearer':
	      // usage would be .auth(accessToken, { type: 'bearer' })
	      this.set('Authorization', 'Bearer ' + user);
	      break;
	  }
	  return this;
	};
	
	/**
	 * Enable transmission of cookies with x-domain requests.
	 *
	 * Note that for this to work the origin must not be
	 * using "Access-Control-Allow-Origin" with a wildcard,
	 * and also must set "Access-Control-Allow-Credentials"
	 * to "true".
	 *
	 * @api public
	 */
	
	RequestBase.prototype.withCredentials = function (on) {
	  // This is browser-only functionality. Node side is no-op.
	  if (on == undefined) on = true;
	  this._withCredentials = on;
	  return this;
	};
	
	/**
	 * Set the max redirects to `n`. Does noting in browser XHR implementation.
	 *
	 * @param {Number} n
	 * @return {Request} for chaining
	 * @api public
	 */
	
	RequestBase.prototype.redirects = function (n) {
	  this._maxRedirects = n;
	  return this;
	};
	
	/**
	 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
	 * Default 200MB.
	 *
	 * @param {Number} n
	 * @return {Request} for chaining
	 */
	RequestBase.prototype.maxResponseSize = function (n) {
	  if ('number' !== typeof n) {
	    throw TypeError("Invalid argument");
	  }
	  this._maxResponseSize = n;
	  return this;
	};
	
	/**
	 * Convert to a plain javascript object (not JSON string) of scalar properties.
	 * Note as this method is designed to return a useful non-this value,
	 * it cannot be chained.
	 *
	 * @return {Object} describing method, url, and data of this request
	 * @api public
	 */
	
	RequestBase.prototype.toJSON = function () {
	  return {
	    method: this.method,
	    url: this.url,
	    data: this._data,
	    headers: this._header
	  };
	};
	
	/**
	 * Send `data` as the request body, defaulting the `.type()` to "json" when
	 * an object is given.
	 *
	 * Examples:
	 *
	 *       // manual json
	 *       request.post('/user')
	 *         .type('json')
	 *         .send('{"name":"tj"}')
	 *         .end(callback)
	 *
	 *       // auto json
	 *       request.post('/user')
	 *         .send({ name: 'tj' })
	 *         .end(callback)
	 *
	 *       // manual x-www-form-urlencoded
	 *       request.post('/user')
	 *         .type('form')
	 *         .send('name=tj')
	 *         .end(callback)
	 *
	 *       // auto x-www-form-urlencoded
	 *       request.post('/user')
	 *         .type('form')
	 *         .send({ name: 'tj' })
	 *         .end(callback)
	 *
	 *       // defaults to x-www-form-urlencoded
	 *      request.post('/user')
	 *        .send('name=tobi')
	 *        .send('species=ferret')
	 *        .end(callback)
	 *
	 * @param {String|Object} data
	 * @return {Request} for chaining
	 * @api public
	 */
	
	RequestBase.prototype.send = function (data) {
	  var isObj = isObject(data);
	  var type = this._header['content-type'];
	
	  if (this._formData) {
	    console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
	  }
	
	  if (isObj && !this._data) {
	    if (Array.isArray(data)) {
	      this._data = [];
	    } else if (!this._isHost(data)) {
	      this._data = {};
	    }
	  } else if (data && this._data && this._isHost(this._data)) {
	    throw Error("Can't merge these send calls");
	  }
	
	  // merge
	  if (isObj && isObject(this._data)) {
	    for (var key in data) {
	      this._data[key] = data[key];
	    }
	  } else if ('string' == typeof data) {
	    // default to x-www-form-urlencoded
	    if (!type) this.type('form');
	    type = this._header['content-type'];
	    if ('application/x-www-form-urlencoded' == type) {
	      this._data = this._data ? this._data + '&' + data : data;
	    } else {
	      this._data = (this._data || '') + data;
	    }
	  } else {
	    this._data = data;
	  }
	
	  if (!isObj || this._isHost(data)) {
	    return this;
	  }
	
	  // default to json
	  if (!type) this.type('json');
	  return this;
	};
	
	/**
	 * Sort `querystring` by the sort function
	 *
	 *
	 * Examples:
	 *
	 *       // default order
	 *       request.get('/user')
	 *         .query('name=Nick')
	 *         .query('search=Manny')
	 *         .sortQuery()
	 *         .end(callback)
	 *
	 *       // customized sort function
	 *       request.get('/user')
	 *         .query('name=Nick')
	 *         .query('search=Manny')
	 *         .sortQuery(function(a, b){
	 *           return a.length - b.length;
	 *         })
	 *         .end(callback)
	 *
	 *
	 * @param {Function} sort
	 * @return {Request} for chaining
	 * @api public
	 */
	
	RequestBase.prototype.sortQuery = function (sort) {
	  // _sort default to true but otherwise can be a function or boolean
	  this._sort = typeof sort === 'undefined' ? true : sort;
	  return this;
	};
	
	/**
	 * Compose querystring to append to req.url
	 *
	 * @api private
	 */
	RequestBase.prototype._finalizeQueryString = function () {
	  var query = this._query.join('&');
	  if (query) {
	    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
	  }
	  this._query.length = 0; // Makes the call idempotent
	
	  if (this._sort) {
	    var index = this.url.indexOf('?');
	    if (index >= 0) {
	      var queryArr = this.url.substring(index + 1).split('&');
	      if ('function' === typeof this._sort) {
	        queryArr.sort(this._sort);
	      } else {
	        queryArr.sort();
	      }
	      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
	    }
	  }
	};
	
	// For backwards compat only
	RequestBase.prototype._appendQueryString = function () {
	  console.trace("Unsupported");
	};
	
	/**
	 * Invoke callback with timeout error.
	 *
	 * @api private
	 */
	
	RequestBase.prototype._timeoutError = function (reason, timeout, errno) {
	  if (this._aborted) {
	    return;
	  }
	  var err = new Error(reason + timeout + 'ms exceeded');
	  err.timeout = timeout;
	  err.code = 'ECONNABORTED';
	  err.errno = errno;
	  this.timedout = true;
	  this.abort();
	  this.callback(err);
	};
	
	RequestBase.prototype._setTimeouts = function () {
	  var self = this;
	
	  // deadline
	  if (this._timeout && !this._timer) {
	    this._timer = setTimeout(function () {
	      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
	    }, this._timeout);
	  }
	  // response timeout
	  if (this._responseTimeout && !this._responseTimeoutTimer) {
	    this._responseTimeoutTimer = setTimeout(function () {
	      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
	    }, this._responseTimeout);
	  }
	};

/***/ }),
/* 26 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * Check if `obj` is an object.
	 *
	 * @param {Object} obj
	 * @return {Boolean}
	 * @api private
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function isObject(obj) {
	  return null !== obj && 'object' === (typeof obj === 'undefined' ? 'undefined' : _typeof(obj));
	}
	
	module.exports = isObject;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var utils = __webpack_require__(28);
	
	/**
	 * Expose `ResponseBase`.
	 */
	
	module.exports = ResponseBase;
	
	/**
	 * Initialize a new `ResponseBase`.
	 *
	 * @api public
	 */
	
	function ResponseBase(obj) {
	  if (obj) return mixin(obj);
	}
	
	/**
	 * Mixin the prototype properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in ResponseBase.prototype) {
	    obj[key] = ResponseBase.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Get case-insensitive `field` value.
	 *
	 * @param {String} field
	 * @return {String}
	 * @api public
	 */
	
	ResponseBase.prototype.get = function (field) {
	  return this.header[field.toLowerCase()];
	};
	
	/**
	 * Set header related properties:
	 *
	 *   - `.type` the content type without params
	 *
	 * A response of "Content-Type: text/plain; charset=utf-8"
	 * will provide you with a `.type` of "text/plain".
	 *
	 * @param {Object} header
	 * @api private
	 */
	
	ResponseBase.prototype._setHeaderProperties = function (header) {
	  // TODO: moar!
	  // TODO: make this a util
	
	  // content-type
	  var ct = header['content-type'] || '';
	  this.type = utils.type(ct);
	
	  // params
	  var params = utils.params(ct);
	  for (var key in params) {
	    this[key] = params[key];
	  }this.links = {};
	
	  // links
	  try {
	    if (header.link) {
	      this.links = utils.parseLinks(header.link);
	    }
	  } catch (err) {
	    // ignore
	  }
	};
	
	/**
	 * Set flags such as `.ok` based on `status`.
	 *
	 * For example a 2xx response will give you a `.ok` of __true__
	 * whereas 5xx will be __false__ and `.error` will be __true__. The
	 * `.clientError` and `.serverError` are also available to be more
	 * specific, and `.statusType` is the class of error ranging from 1..5
	 * sometimes useful for mapping respond colors etc.
	 *
	 * "sugar" properties are also defined for common cases. Currently providing:
	 *
	 *   - .noContent
	 *   - .badRequest
	 *   - .unauthorized
	 *   - .notAcceptable
	 *   - .notFound
	 *
	 * @param {Number} status
	 * @api private
	 */
	
	ResponseBase.prototype._setStatusProperties = function (status) {
	  var type = status / 100 | 0;
	
	  // status / class
	  this.status = this.statusCode = status;
	  this.statusType = type;
	
	  // basics
	  this.info = 1 == type;
	  this.ok = 2 == type;
	  this.redirect = 3 == type;
	  this.clientError = 4 == type;
	  this.serverError = 5 == type;
	  this.error = 4 == type || 5 == type ? this.toError() : false;
	
	  // sugar
	  this.accepted = 202 == status;
	  this.noContent = 204 == status;
	  this.badRequest = 400 == status;
	  this.unauthorized = 401 == status;
	  this.notAcceptable = 406 == status;
	  this.forbidden = 403 == status;
	  this.notFound = 404 == status;
	};

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * Return the mime type for the given `str`.
	 *
	 * @param {String} str
	 * @return {String}
	 * @api private
	 */
	
	exports.type = function (str) {
	  return str.split(/ *; */).shift();
	};
	
	/**
	 * Return header field parameters.
	 *
	 * @param {String} str
	 * @return {Object}
	 * @api private
	 */
	
	exports.params = function (str) {
	  return str.split(/ *; */).reduce(function (obj, str) {
	    var parts = str.split(/ *= */);
	    var key = parts.shift();
	    var val = parts.shift();
	
	    if (key && val) obj[key] = val;
	    return obj;
	  }, {});
	};
	
	/**
	 * Parse Link header fields.
	 *
	 * @param {String} str
	 * @return {Object}
	 * @api private
	 */
	
	exports.parseLinks = function (str) {
	  return str.split(/ *, */).reduce(function (obj, str) {
	    var parts = str.split(/ *; */);
	    var url = parts[0].slice(1, -1);
	    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
	    obj[rel] = url;
	    return obj;
	  }, {});
	};
	
	/**
	 * Strip content related fields from `header`.
	 *
	 * @param {Object} header
	 * @return {Object} header
	 * @api private
	 */
	
	exports.cleanHeader = function (header, changesOrigin) {
	  delete header['content-type'];
	  delete header['content-length'];
	  delete header['transfer-encoding'];
	  delete header['host'];
	  // secuirty
	  if (changesOrigin) {
	    delete header['authorization'];
	    delete header['cookie'];
	  }
	  return header;
	};

/***/ }),
/* 29 */
/***/ (function(module, exports) {

	"use strict";
	
	function Agent() {
	  this._defaults = [];
	}
	
	["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(function (fn) {
	  /** Default setting for all requests from this agent */
	  Agent.prototype[fn] = function () /*varargs*/{
	    this._defaults.push({ fn: fn, arguments: arguments });
	    return this;
	  };
	});
	
	Agent.prototype._setDefaults = function (req) {
	  this._defaults.forEach(function (def) {
	    req[def.fn].apply(req, def.arguments);
	  });
	};
	
	module.exports = Agent;

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	'use strict';
	
	function ConfigurationError(message) {
	  this.name = 'ConfigurationError';
	  this.message = message || '';
	}
	ConfigurationError.prototype = Error.prototype;
	
	function TokenValidationError(message) {
	  this.name = 'TokenValidationError';
	  this.message = message || '';
	}
	TokenValidationError.prototype = Error.prototype;
	
	module.exports = {
	  ConfigurationError: ConfigurationError,
	  TokenValidationError: TokenValidationError
	};

/***/ }),
/* 31 */
/***/ (function(module, exports) {

	"use strict";
	
	function DummyCache() {}
	
	DummyCache.prototype.get = function () {
	  return null;
	};
	
	DummyCache.prototype.has = function () {
	  return false;
	};
	
	DummyCache.prototype.set = function () {};
	
	module.exports = DummyCache;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _UrlUtility = __webpack_require__(33);
	
	var _UrlUtility2 = _interopRequireDefault(_UrlUtility);
	
	var _SigninState = __webpack_require__(34);
	
	var _SigninState2 = _interopRequireDefault(_SigninState);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SigninRequest = function () {
	    function SigninRequest(_ref) {
	        var url = _ref.url,
	            client_id = _ref.client_id,
	            redirect_uri = _ref.redirect_uri,
	            response_type = _ref.response_type,
	            scope = _ref.scope,
	            authority = _ref.authority,
	            data = _ref.data,
	            prompt = _ref.prompt,
	            display = _ref.display,
	            max_age = _ref.max_age,
	            ui_locales = _ref.ui_locales,
	            id_token_hint = _ref.id_token_hint,
	            login_hint = _ref.login_hint,
	            acr_values = _ref.acr_values,
	            resource = _ref.resource,
	            request = _ref.request,
	            request_uri = _ref.request_uri,
	            extraQueryParams = _ref.extraQueryParams;
	
	        _classCallCheck(this, SigninRequest);
	
	        if (!url) {
	            _Log2.default.error("No url passed to SigninRequest");
	            throw new Error("url");
	        }
	        if (!client_id) {
	            _Log2.default.error("No client_id passed to SigninRequest");
	            throw new Error("client_id");
	        }
	        if (!redirect_uri) {
	            _Log2.default.error("No redirect_uri passed to SigninRequest");
	            throw new Error("redirect_uri");
	        }
	        if (!response_type) {
	            _Log2.default.error("No response_type passed to SigninRequest");
	            throw new Error("response_type");
	        }
	        if (!scope) {
	            _Log2.default.error("No scope passed to SigninRequest");
	            throw new Error("scope");
	        }
	        if (!authority) {
	            _Log2.default.error("No authority passed to SigninRequest");
	            throw new Error("authority");
	        }
	
	        var oidc = SigninRequest.isOidc(response_type);
	        this.state = new _SigninState2.default({ nonce: oidc, data: data, client_id: client_id, authority: authority });
	
	        url = _UrlUtility2.default.addQueryParam(url, "client_id", client_id);
	        url = _UrlUtility2.default.addQueryParam(url, "redirect_uri", redirect_uri);
	        url = _UrlUtility2.default.addQueryParam(url, "response_type", response_type);
	        url = _UrlUtility2.default.addQueryParam(url, "scope", scope);
	
	        url = _UrlUtility2.default.addQueryParam(url, "state", this.state.id);
	        if (oidc) {
	            url = _UrlUtility2.default.addQueryParam(url, "nonce", this.state.nonce);
	        }
	
	        var optional = { prompt: prompt, display: display, max_age: max_age, ui_locales: ui_locales, id_token_hint: id_token_hint, login_hint: login_hint, acr_values: acr_values, resource: resource, request: request, request_uri: request_uri };
	        for (var key in optional) {
	            if (optional[key]) {
	                url = _UrlUtility2.default.addQueryParam(url, key, optional[key]);
	            }
	        }
	
	        for (var _key in extraQueryParams) {
	            url = _UrlUtility2.default.addQueryParam(url, _key, extraQueryParams[_key]);
	        }
	
	        this.url = url;
	    }
	
	    _createClass(SigninRequest, null, [{
	        key: 'isOidc',
	        value: function isOidc(response_type) {
	            var result = response_type.split(/\s+/g).filter(function (item) {
	                return item === "id_token";
	            });
	            return !!result[0];
	        }
	    }, {
	        key: 'isOAuth',
	        value: function isOAuth(response_type) {
	            var result = response_type.split(/\s+/g).filter(function (item) {
	                return item === "token";
	            });
	            return !!result[0];
	        }
	    }]);
	
	    return SigninRequest;
	}();
	
	exports.default = SigninRequest;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _Global = __webpack_require__(5);
	
	var _Global2 = _interopRequireDefault(_Global);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var UrlUtility = function () {
	    function UrlUtility() {
	        _classCallCheck(this, UrlUtility);
	    }
	
	    _createClass(UrlUtility, null, [{
	        key: 'addQueryParam',
	        value: function addQueryParam(url, name, value) {
	            if (url.indexOf('?') < 0) {
	                url += "?";
	            }
	
	            if (url[url.length - 1] !== "?") {
	                url += "&";
	            }
	
	            url += encodeURIComponent(name);
	            url += "=";
	            url += encodeURIComponent(value);
	
	            return url;
	        }
	    }, {
	        key: 'parseUrlFragment',
	        value: function parseUrlFragment(value) {
	            var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "#";
	            var global = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _Global2.default;
	
	            _Log2.default.debug("UrlUtility.parseUrlFragment");
	
	            if (typeof value !== 'string') {
	                value = global.location.href;
	            }
	
	            var idx = value.lastIndexOf(delimiter);
	            if (idx >= 0) {
	                value = value.substr(idx + 1);
	            }
	
	            var params = {},
	                regex = /([^&=]+)=([^&]*)/g,
	                m;
	
	            var counter = 0;
	            while (m = regex.exec(value)) {
	                params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
	                if (counter++ > 50) {
	                    _Log2.default.error("response exceeded expected number of parameters", value);
	                    return {
	                        error: "Response exceeded expected number of parameters"
	                    };
	                }
	            }
	
	            for (var prop in params) {
	                return params;
	            }
	
	            return {};
	        }
	    }]);
	
	    return UrlUtility;
	}();
	
	exports.default = UrlUtility;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _State2 = __webpack_require__(35);
	
	var _State3 = _interopRequireDefault(_State2);
	
	var _random = __webpack_require__(36);
	
	var _random2 = _interopRequireDefault(_random);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var SigninState = function (_State) {
	    _inherits(SigninState, _State);
	
	    function SigninState() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            nonce = _ref.nonce,
	            authority = _ref.authority,
	            client_id = _ref.client_id;
	
	        _classCallCheck(this, SigninState);
	
	        var _this = _possibleConstructorReturn(this, (SigninState.__proto__ || Object.getPrototypeOf(SigninState)).call(this, arguments[0]));
	
	        if (nonce === true) {
	            _this._nonce = (0, _random2.default)();
	        } else if (nonce) {
	            _this._nonce = nonce;
	        }
	
	        _this._authority = authority;
	        _this._client_id = client_id;
	        return _this;
	    }
	
	    _createClass(SigninState, [{
	        key: 'toStorageString',
	        value: function toStorageString() {
	            _Log2.default.debug("SigninState.toStorageString");
	            return JSON.stringify({
	                id: this.id,
	                data: this.data,
	                created: this.created,
	                nonce: this.nonce,
	                authority: this.authority,
	                client_id: this.client_id
	            });
	        }
	    }, {
	        key: 'nonce',
	        get: function get() {
	            return this._nonce;
	        }
	    }, {
	        key: 'authority',
	        get: function get() {
	            return this._authority;
	        }
	    }, {
	        key: 'client_id',
	        get: function get() {
	            return this._client_id;
	        }
	    }], [{
	        key: 'fromStorageString',
	        value: function fromStorageString(storageString) {
	            _Log2.default.debug("SigninState.fromStorageString");
	            var data = JSON.parse(storageString);
	            return new SigninState(data);
	        }
	    }]);
	
	    return SigninState;
	}(_State3.default);
	
	exports.default = SigninState;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _random = __webpack_require__(36);
	
	var _random2 = _interopRequireDefault(_random);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var State = function () {
	    function State() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            id = _ref.id,
	            data = _ref.data,
	            created = _ref.created;
	
	        _classCallCheck(this, State);
	
	        this._id = id || (0, _random2.default)();
	        this._data = data;
	
	        if (typeof created === 'number' && created > 0) {
	            this._created = created;
	        } else {
	            this._created = parseInt(Date.now() / 1000);
	        }
	    }
	
	    _createClass(State, [{
	        key: 'toStorageString',
	        value: function toStorageString() {
	            _Log2.default.debug("State.toStorageString");
	            return JSON.stringify({
	                id: this.id,
	                data: this.data,
	                created: this.created
	            });
	        }
	    }, {
	        key: 'id',
	        get: function get() {
	            return this._id;
	        }
	    }, {
	        key: 'data',
	        get: function get() {
	            return this._data;
	        }
	    }, {
	        key: 'created',
	        get: function get() {
	            return this._created;
	        }
	    }], [{
	        key: 'fromStorageString',
	        value: function fromStorageString(storageString) {
	            _Log2.default.debug("State.fromStorageString");
	            return new State(JSON.parse(storageString));
	        }
	    }, {
	        key: 'clearStaleState',
	        value: function clearStaleState(storage, age) {
	            _Log2.default.debug("State.clearStaleState");
	
	            var cutoff = Date.now() / 1000 - age;
	
	            return storage.getAllKeys().then(function (keys) {
	                _Log2.default.debug("got keys", keys);
	
	                var promises = [];
	
	                var _loop = function _loop(i) {
	                    var key = keys[i];
	                    p = storage.get(key).then(function (item) {
	                        var remove = false;
	
	                        if (item) {
	                            try {
	                                var state = State.fromStorageString(item);
	
	                                _Log2.default.debug("got item from key: ", key, state.created);
	
	                                if (state.created <= cutoff) {
	                                    remove = true;
	                                }
	                            } catch (e) {
	                                _Log2.default.error("Error parsing state for key", key, e.message);
	                                remove = true;
	                            }
	                        } else {
	                            _Log2.default.debug("no item in storage for key: ", key);
	                            remove = true;
	                        }
	
	                        if (remove) {
	                            _Log2.default.debug("removed item for key: ", key);
	                            return storage.remove(key);
	                        }
	                    });
	
	
	                    promises.push(p);
	                };
	
	                for (var i = 0; i < keys.length; i++) {
	                    var p;
	
	                    _loop(i);
	                }
	
	                _Log2.default.debug("waiting on promise count:", promises.length);
	                return Promise.all(promises);
	            });
	        }
	    }]);
	
	    return State;
	}();
	
	exports.default = State;

/***/ }),
/* 36 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = random;
	// NOTICE: the code in this file originally developed by Microsoft
	// original source: https://github.com/AzureAD/azure-activedirectory-library-for-js/blob/master/lib/adal.js#L1029
	//----------------------------------------------------------------------
	// AdalJS v1.0.8
	// @preserve Copyright (c) Microsoft Open Technologies, Inc.
	// All Rights Reserved
	// Apache License 2.0
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//----------------------------------------------------------------------
	
	function random() {
	    var guidHolder = 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx';
	    var hex = '0123456789abcdef';
	    var r = 0;
	    var guidResponse = "";
	    for (var i = 0; i < guidHolder.length; i++) {
	        if (guidHolder[i] !== '-' && guidHolder[i] !== '4') {
	            // each x and y needs to be random
	            r = Math.random() * 16 | 0;
	        }
	
	        if (guidHolder[i] === 'x') {
	            guidResponse += hex[r];
	        } else if (guidHolder[i] === 'y') {
	            // clock-seq-and-reserved first hex is filtered and remaining hex values are random
	            r &= 0x3; // bit and with 0011 to set pos 2 to zero ?0??
	            r |= 0x8; // set pos 3 to 1 as 1???
	            guidResponse += hex[r];
	        } else {
	            guidResponse += guidHolder[i];
	        }
	    }
	    return guidResponse;
	}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _UrlUtility = __webpack_require__(33);
	
	var _UrlUtility2 = _interopRequireDefault(_UrlUtility);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var OidcScope = "openid";
	
	var SigninResponse = function () {
	    function SigninResponse(url) {
	        _classCallCheck(this, SigninResponse);
	
	        var values = _UrlUtility2.default.parseUrlFragment(url, "#");
	
	        this.error = values.error;
	        this.error_description = values.error_description;
	        this.error_uri = values.error_uri;
	
	        this.state = values.state;
	        this.id_token = values.id_token;
	        this.session_state = values.session_state;
	        this.access_token = values.access_token;
	        this.token_type = values.token_type;
	        this.scope = values.scope;
	        this.profile = undefined; // will be set from ResponseValidator
	
	        var expires_in = parseInt(values.expires_in);
	        if (typeof expires_in === 'number' && expires_in > 0) {
	            var now = parseInt(Date.now() / 1000);
	            this.expires_at = now + expires_in;
	        }
	    }
	
	    _createClass(SigninResponse, [{
	        key: "expires_in",
	        get: function get() {
	            if (this.expires_at) {
	                var now = parseInt(Date.now() / 1000);
	                return this.expires_at - now;
	            }
	            return undefined;
	        }
	    }, {
	        key: "expired",
	        get: function get() {
	            var expires_in = this.expires_in;
	            if (expires_in !== undefined) {
	                return expires_in <= 0;
	            }
	            return undefined;
	        }
	    }, {
	        key: "scopes",
	        get: function get() {
	            return (this.scope || "").split(" ");
	        }
	    }, {
	        key: "isOpenIdConnect",
	        get: function get() {
	            return this.scopes.indexOf(OidcScope) >= 0 || !!this.id_token;
	        }
	    }]);
	
	    return SigninResponse;
	}();
	
	exports.default = SigninResponse;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _UrlUtility = __webpack_require__(33);
	
	var _UrlUtility2 = _interopRequireDefault(_UrlUtility);
	
	var _State = __webpack_require__(35);
	
	var _State2 = _interopRequireDefault(_State);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var SignoutRequest = function SignoutRequest(_ref) {
	    var url = _ref.url,
	        id_token_hint = _ref.id_token_hint,
	        post_logout_redirect_uri = _ref.post_logout_redirect_uri,
	        data = _ref.data;
	
	    _classCallCheck(this, SignoutRequest);
	
	    if (!url) {
	        _Log2.default.error("No url passed to SignoutRequest");
	        throw new Error("url");
	    }
	
	    if (id_token_hint) {
	        url = _UrlUtility2.default.addQueryParam(url, "id_token_hint", id_token_hint);
	    }
	
	    if (post_logout_redirect_uri) {
	        url = _UrlUtility2.default.addQueryParam(url, "post_logout_redirect_uri", post_logout_redirect_uri);
	
	        if (data) {
	            this.state = new _State2.default({ data: data });
	
	            url = _UrlUtility2.default.addQueryParam(url, "state", this.state.id);
	        }
	    }
	
	    this.url = url;
	};
	
	exports.default = SignoutRequest;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _UrlUtility = __webpack_require__(33);
	
	var _UrlUtility2 = _interopRequireDefault(_UrlUtility);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var SignoutResponse = function SignoutResponse(url) {
	    _classCallCheck(this, SignoutResponse);
	
	    var values = _UrlUtility2.default.parseUrlFragment(url, "?");
	
	    this.error = values.error;
	    this.error_description = values.error_description;
	    this.error_uri = values.error_uri;
	
	    this.state = values.state;
	};
	
	exports.default = SignoutResponse;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var InMemoryWebStorage = function () {
	    function InMemoryWebStorage() {
	        _classCallCheck(this, InMemoryWebStorage);
	
	        this._data = {};
	    }
	
	    _createClass(InMemoryWebStorage, [{
	        key: "getItem",
	        value: function getItem(key) {
	            _Log2.default.debug("InMemoryWebStorage.getItem", key);
	            return this._data[key];
	        }
	    }, {
	        key: "setItem",
	        value: function setItem(key, value) {
	            _Log2.default.debug("InMemoryWebStorage.setItem", key);
	            this._data[key] = value;
	        }
	    }, {
	        key: "removeItem",
	        value: function removeItem(key) {
	            _Log2.default.debug("InMemoryWebStorage.removeItem", key);
	            delete this._data[key];
	        }
	    }, {
	        key: "key",
	        value: function key(index) {
	            return Object.getOwnPropertyNames(this._data)[index];
	        }
	    }, {
	        key: "length",
	        get: function get() {
	            return Object.getOwnPropertyNames(this._data).length;
	        }
	    }]);
	
	    return InMemoryWebStorage;
	}();
	
	exports.default = InMemoryWebStorage;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _OidcClient2 = __webpack_require__(2);
	
	var _OidcClient3 = _interopRequireDefault(_OidcClient2);
	
	var _UserManagerSettings = __webpack_require__(42);
	
	var _UserManagerSettings2 = _interopRequireDefault(_UserManagerSettings);
	
	var _User = __webpack_require__(48);
	
	var _User2 = _interopRequireDefault(_User);
	
	var _UserManagerEvents = __webpack_require__(49);
	
	var _UserManagerEvents2 = _interopRequireDefault(_UserManagerEvents);
	
	var _SilentRenewService = __webpack_require__(53);
	
	var _SilentRenewService2 = _interopRequireDefault(_SilentRenewService);
	
	var _SessionMonitor = __webpack_require__(54);
	
	var _SessionMonitor2 = _interopRequireDefault(_SessionMonitor);
	
	var _TokenRevocationClient = __webpack_require__(56);
	
	var _TokenRevocationClient2 = _interopRequireDefault(_TokenRevocationClient);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var UserManager = function (_OidcClient) {
	    _inherits(UserManager, _OidcClient);
	
	    function UserManager() {
	        var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	        var SilentRenewServiceCtor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _SilentRenewService2.default;
	        var SessionMonitorCtor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _SessionMonitor2.default;
	        var TokenRevocationClientCtor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _TokenRevocationClient2.default;
	
	        _classCallCheck(this, UserManager);
	
	        if (!(settings instanceof _UserManagerSettings2.default)) {
	            settings = new _UserManagerSettings2.default(settings);
	        }
	
	        var _this = _possibleConstructorReturn(this, (UserManager.__proto__ || Object.getPrototypeOf(UserManager)).call(this, settings));
	
	        _this._events = new _UserManagerEvents2.default(settings);
	        _this._silentRenewService = new SilentRenewServiceCtor(_this);
	
	        // order is important for the following properties; these services depend upon the events.
	        if (_this.settings.automaticSilentRenew) {
	            _Log2.default.debug("automaticSilentRenew is configured, setting up silent renew");
	            _this.startSilentRenew();
	        }
	
	        if (_this.settings.monitorSession) {
	            _Log2.default.debug("monitorSession is configured, setting up session monitor");
	            _this._sessionMonitor = new SessionMonitorCtor(_this);
	        }
	
	        _this._tokenRevocationClient = new TokenRevocationClientCtor(_this._settings);
	        return _this;
	    }
	
	    _createClass(UserManager, [{
	        key: 'getUser',
	        value: function getUser() {
	            var _this2 = this;
	
	            _Log2.default.debug("UserManager.getUser");
	
	            return this._loadUser().then(function (user) {
	                if (user) {
	                    _Log2.default.info("user loaded");
	
	                    _this2._events.load(user, false);
	
	                    return user;
	                } else {
	                    _Log2.default.info("user not found in storage");
	                    return null;
	                }
	            });
	        }
	    }, {
	        key: 'removeUser',
	        value: function removeUser() {
	            var _this3 = this;
	
	            _Log2.default.debug("UserManager.removeUser");
	
	            return this.storeUser(null).then(function () {
	                _Log2.default.info("user removed from storage");
	                _this3._events.unload();
	            });
	        }
	    }, {
	        key: 'signinRedirect',
	        value: function signinRedirect(args) {
	            _Log2.default.debug("UserManager.signinRedirect");
	            return this._signinStart(args, this._redirectNavigator).then(function () {
	                _Log2.default.info("signinRedirect successful");
	            });
	        }
	    }, {
	        key: 'signinRedirectCallback',
	        value: function signinRedirectCallback(url) {
	            _Log2.default.debug("UserManager.signinRedirectCallback");
	            return this._signinEnd(url || this._redirectNavigator.url).then(function (user) {
	                if (user) {
	                    if (user.profile && user.profile.sub) {
	                        _Log2.default.info("signinRedirectCallback successful, signed in sub: ", user.profile.sub);
	                    } else {
	                        _Log2.default.info("signinRedirectCallback successful");
	                    }
	                }
	
	                return user;
	            });
	        }
	    }, {
	        key: 'signinPopup',
	        value: function signinPopup() {
	            var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	            _Log2.default.debug("UserManager.signinPopup");
	
	            var url = args.redirect_uri || this.settings.popup_redirect_uri || this.settings.redirect_uri;
	            if (!url) {
	                _Log2.default.error("No popup_redirect_uri or redirect_uri configured");
	                return Promise.reject(new Error("No popup_redirect_uri or redirect_uri configured"));
	            }
	
	            args.redirect_uri = url;
	            args.display = "popup";
	
	            return this._signin(args, this._popupNavigator, {
	                startUrl: url,
	                popupWindowFeatures: args.popupWindowFeatures || this.settings.popupWindowFeatures,
	                popupWindowTarget: args.popupWindowTarget || this.settings.popupWindowTarget
	            }).then(function (user) {
	                if (user) {
	                    if (user.profile && user.profile.sub) {
	                        _Log2.default.info("signinPopup successful, signed in sub: ", user.profile.sub);
	                    } else {
	                        _Log2.default.info("signinPopup successful");
	                    }
	                }
	
	                return user;
	            });
	        }
	    }, {
	        key: 'signinPopupCallback',
	        value: function signinPopupCallback(url) {
	            _Log2.default.debug("UserManager.signinPopupCallback");
	            return this._signinCallback(url, this._popupNavigator).then(function (user) {
	                if (user) {
	                    if (user.profile && user.profile.sub) {
	                        _Log2.default.info("signinPopupCallback successful, signed in sub: ", user.profile.sub);
	                    } else {
	                        _Log2.default.info("signinPopupCallback successful");
	                    }
	                }
	
	                return user;
	            });
	        }
	    }, {
	        key: 'signinSilent',
	        value: function signinSilent() {
	            var _this4 = this;
	
	            var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	            _Log2.default.debug("UserManager.signinSilent");
	
	            var url = args.redirect_uri || this.settings.silent_redirect_uri;
	            if (!url) {
	                _Log2.default.error("No silent_redirect_uri configured");
	                return Promise.reject(new Error("No silent_redirect_uri configured"));
	            }
	
	            args.redirect_uri = url;
	            args.prompt = "none";
	
	            var setIdToken = void 0;
	            if (args.id_token_hint || !this.settings.includeIdTokenInSilentRenew) {
	                setIdToken = Promise.resolve();
	            } else {
	                setIdToken = this._loadUser().then(function (user) {
	                    args.id_token_hint = user && user.id_token;
	                });
	            }
	
	            return setIdToken.then(function () {
	                return _this4._signin(args, _this4._iframeNavigator, {
	                    startUrl: url,
	                    silentRequestTimeout: args.silentRequestTimeout || _this4.settings.silentRequestTimeout
	                });
	            }).then(function (user) {
	                if (user) {
	                    if (user.profile && user.profile.sub) {
	                        _Log2.default.info("signinSilent successful, signed in sub: ", user.profile.sub);
	                    } else {
	                        _Log2.default.info("signinSilent successful");
	                    }
	                }
	
	                return user;
	            });
	        }
	    }, {
	        key: 'signinSilentCallback',
	        value: function signinSilentCallback(url) {
	            _Log2.default.debug("UserManager.signinSilentCallback");
	            return this._signinCallback(url, this._iframeNavigator).then(function (user) {
	                if (user) {
	                    if (user.profile && user.profile.sub) {
	                        _Log2.default.info("signinSilentCallback successful, signed in sub: ", user.profile.sub);
	                    } else {
	                        _Log2.default.info("signinSilentCallback successful");
	                    }
	                }
	
	                return user;
	            });
	        }
	    }, {
	        key: 'querySessionStatus',
	        value: function querySessionStatus() {
	            var _this5 = this;
	
	            var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	            _Log2.default.debug("UserManager.querySessionStatus");
	
	            var url = args.redirect_uri || this.settings.silent_redirect_uri;
	            if (!url) {
	                _Log2.default.error("No silent_redirect_uri configured");
	                return Promise.reject(new Error("No silent_redirect_uri configured"));
	            }
	
	            args.redirect_uri = url;
	            args.prompt = "none";
	            args.response_type = "id_token";
	            args.scope = "openid";
	
	            return this._signinStart(args, this._iframeNavigator, {
	                startUrl: url,
	                silentRequestTimeout: args.silentRequestTimeout || this.settings.silentRequestTimeout
	            }).then(function (navResponse) {
	                return _this5.processSigninResponse(navResponse.url).then(function (signinResponse) {
	                    _Log2.default.debug("got signin response");
	
	                    if (signinResponse.session_state && signinResponse.profile.sub && signinResponse.profile.sid) {
	                        _Log2.default.info("querySessionStatus success for sub: ", signinResponse.profile.sub);
	                        return {
	                            session_state: signinResponse.session_state,
	                            sub: signinResponse.profile.sub,
	                            sid: signinResponse.profile.sid
	                        };
	                    } else {
	                        _Log2.default.info("querySessionStatus successful, user not authenticated");
	                    }
	                });
	            });
	        }
	    }, {
	        key: '_signin',
	        value: function _signin(args, navigator) {
	            var _this6 = this;
	
	            var navigatorParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	            _Log2.default.debug("_signin");
	            return this._signinStart(args, navigator, navigatorParams).then(function (navResponse) {
	                return _this6._signinEnd(navResponse.url);
	            });
	        }
	    }, {
	        key: '_signinStart',
	        value: function _signinStart(args, navigator) {
	            var _this7 = this;
	
	            var navigatorParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	            _Log2.default.debug("_signinStart");
	
	            return navigator.prepare(navigatorParams).then(function (handle) {
	                _Log2.default.debug("got navigator window handle");
	
	                return _this7.createSigninRequest(args).then(function (signinRequest) {
	                    _Log2.default.debug("got signin request");
	
	                    navigatorParams.url = signinRequest.url;
	                    navigatorParams.id = signinRequest.state.id;
	
	                    return handle.navigate(navigatorParams);
	                }).catch(function (err) {
	                    if (handle.close) {
	                        _Log2.default.debug("Error after preparing navigator, closing navigator window");
	                        handle.close();
	                    }
	                    throw err;
	                });
	            });
	        }
	    }, {
	        key: '_signinEnd',
	        value: function _signinEnd(url) {
	            var _this8 = this;
	
	            _Log2.default.debug("_signinEnd");
	
	            return this.processSigninResponse(url).then(function (signinResponse) {
	                _Log2.default.debug("got signin response");
	
	                var user = new _User2.default(signinResponse);
	
	                return _this8.storeUser(user).then(function () {
	                    _Log2.default.debug("user stored");
	
	                    _this8._events.load(user);
	
	                    return user;
	                });
	            });
	        }
	    }, {
	        key: '_signinCallback',
	        value: function _signinCallback(url, navigator) {
	            _Log2.default.debug("_signinCallback");
	            return navigator.callback(url);
	        }
	    }, {
	        key: 'signoutRedirect',
	        value: function signoutRedirect() {
	            var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	            _Log2.default.debug("UserManager.signoutRedirect");
	            var postLogoutRedirectUri = args.post_logout_redirect_uri || this.settings.post_logout_redirect_uri;
	            if (postLogoutRedirectUri) {
	                args.post_logout_redirect_uri = postLogoutRedirectUri;
	            }
	            return this._signoutStart(args, this._redirectNavigator).then(function () {
	                _Log2.default.info("signoutRedirect successful");
	            });
	        }
	    }, {
	        key: 'signoutRedirectCallback',
	        value: function signoutRedirectCallback(url) {
	            _Log2.default.debug("UserManager.signoutRedirectCallback");
	            return this._signoutEnd(url || this._redirectNavigator.url).then(function (response) {
	                _Log2.default.info("signoutRedirectCallback successful");
	                return response;
	            });
	        }
	    }, {
	        key: 'signoutPopup',
	        value: function signoutPopup() {
	            var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	            _Log2.default.debug("UserManager.signinPopup");
	
	            var url = args.post_logout_redirect_uri || this.settings.popup_post_logout_redirect_uri || this.settings.post_logout_redirect_uri;
	            args.post_logout_redirect_uri = url;
	            args.display = "popup";
	            if (args.post_logout_redirect_uri) {
	                // we're putting a dummy entry in here because we 
	                // need a unique id from the state for notification
	                // to the parent window, which is necessary if we
	                // plan to return back to the client after signout
	                // and so we can close the popup after signout
	                args.state = args.state || {};
	            }
	
	            return this._signout(args, this._popupNavigator, {
	                startUrl: url,
	                popupWindowFeatures: args.popupWindowFeatures || this.settings.popupWindowFeatures,
	                popupWindowTarget: args.popupWindowTarget || this.settings.popupWindowTarget
	            }).then(function () {
	                _Log2.default.info("signoutPopup successful");
	            });
	        }
	    }, {
	        key: 'signoutPopupCallback',
	        value: function signoutPopupCallback(url, keepOpen) {
	            if (typeof keepOpen === 'undefined' && typeof url === 'boolean') {
	                url = null;
	                keepOpen = true;
	            }
	            _Log2.default.debug("UserManager.signoutPopupCallback");
	            var delimiter = '?';
	            return this._popupNavigator.callback(url, keepOpen, delimiter).then(function () {
	                _Log2.default.info("signoutPopupCallback successful");
	            });
	        }
	    }, {
	        key: '_signout',
	        value: function _signout(args, navigator) {
	            var _this9 = this;
	
	            var navigatorParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	            _Log2.default.debug("_signout");
	            return this._signoutStart(args, navigator, navigatorParams).then(function (navResponse) {
	                return _this9._signoutEnd(navResponse.url);
	            });
	        }
	    }, {
	        key: '_signoutStart',
	        value: function _signoutStart() {
	            var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	            var _this10 = this;
	
	            var navigator = arguments[1];
	            var navigatorParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	            _Log2.default.debug("_signoutStart");
	
	            return navigator.prepare(navigatorParams).then(function (handle) {
	                _Log2.default.debug("got navigator window handle");
	
	                return _this10._loadUser().then(function (user) {
	                    _Log2.default.debug("loaded current user from storage");
	
	                    var revokePromise = _this10._settings.revokeAccessTokenOnSignout ? _this10._revokeInternal(user) : Promise.resolve();
	                    return revokePromise.then(function () {
	
	                        var id_token = args.id_token_hint || user && user.id_token;
	                        if (id_token) {
	                            _Log2.default.debug("Setting id_token into signout request");
	                            args.id_token_hint = id_token;
	                        }
	
	                        return _this10.removeUser().then(function () {
	                            _Log2.default.debug("user removed, creating signout request");
	
	                            return _this10.createSignoutRequest(args).then(function (signoutRequest) {
	                                _Log2.default.debug("got signout request");
	
	                                navigatorParams.url = signoutRequest.url;
	                                if (signoutRequest.state) {
	                                    navigatorParams.id = signoutRequest.state.id;
	                                }
	                                return handle.navigate(navigatorParams);
	                            });
	                        });
	                    });
	                }).catch(function (err) {
	                    if (handle.close) {
	                        _Log2.default.debug("Error after preparing navigator, closing navigator window");
	                        handle.close();
	                    }
	                    throw err;
	                });
	            });
	        }
	    }, {
	        key: '_signoutEnd',
	        value: function _signoutEnd(url) {
	            _Log2.default.debug("_signoutEnd");
	
	            return this.processSignoutResponse(url).then(function (signoutResponse) {
	                _Log2.default.debug("got signout response");
	
	                return signoutResponse;
	            });
	        }
	    }, {
	        key: 'revokeAccessToken',
	        value: function revokeAccessToken() {
	            var _this11 = this;
	
	            _Log2.default.debug("UserManager.revokeAccessToken");
	
	            return this._loadUser().then(function (user) {
	                return _this11._revokeInternal(user, true).then(function (success) {
	                    if (success) {
	                        _Log2.default.debug("removing token properties from user and re-storing");
	
	                        user.access_token = null;
	                        user.expires_at = null;
	                        user.token_type = null;
	
	                        return _this11.storeUser(user).then(function () {
	                            _Log2.default.debug("user stored");
	                            _this11._events.load(user);
	                        });
	                    }
	                });
	            }).then(function () {
	                _Log2.default.info("access token revoked successfully");
	            });
	        }
	    }, {
	        key: '_revokeInternal',
	        value: function _revokeInternal(user, required) {
	            _Log2.default.debug("checking if token revocation is necessary");
	
	            var access_token = user && user.access_token;
	
	            // check for JWT vs. reference token
	            if (!access_token || access_token.indexOf('.') >= 0) {
	                _Log2.default.debug("no need to revoke due to no user, token, or JWT format");
	                return Promise.resolve(false);
	            }
	
	            return this._tokenRevocationClient.revoke(access_token, required).then(function () {
	                return true;
	            });
	        }
	    }, {
	        key: 'startSilentRenew',
	        value: function startSilentRenew() {
	            this._silentRenewService.start();
	        }
	    }, {
	        key: 'stopSilentRenew',
	        value: function stopSilentRenew() {
	            this._silentRenewService.stop();
	        }
	    }, {
	        key: '_loadUser',
	        value: function _loadUser() {
	            _Log2.default.debug("_loadUser");
	
	            return this._userStore.get(this._userStoreKey).then(function (storageString) {
	                if (storageString) {
	                    _Log2.default.debug("user storageString loaded");
	                    return _User2.default.fromStorageString(storageString);
	                }
	
	                _Log2.default.debug("no user storageString");
	                return null;
	            });
	        }
	    }, {
	        key: 'storeUser',
	        value: function storeUser(user) {
	            if (user) {
	                _Log2.default.debug("storeUser storing user");
	
	                var storageString = user.toStorageString();
	                return this._userStore.set(this._userStoreKey, storageString);
	            } else {
	                _Log2.default.debug("storeUser removing user storage");
	                return this._userStore.remove(this._userStoreKey);
	            }
	        }
	    }, {
	        key: '_redirectNavigator',
	        get: function get() {
	            return this.settings.redirectNavigator;
	        }
	    }, {
	        key: '_popupNavigator',
	        get: function get() {
	            return this.settings.popupNavigator;
	        }
	    }, {
	        key: '_iframeNavigator',
	        get: function get() {
	            return this.settings.iframeNavigator;
	        }
	    }, {
	        key: '_userStore',
	        get: function get() {
	            return this.settings.userStore;
	        }
	    }, {
	        key: 'events',
	        get: function get() {
	            return this._events;
	        }
	    }, {
	        key: '_userStoreKey',
	        get: function get() {
	            return 'user:' + this.settings.authority + ':' + this.settings.client_id;
	        }
	    }]);
	
	    return UserManager;
	}(_OidcClient3.default);
	
	exports.default = UserManager;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _OidcClientSettings2 = __webpack_require__(3);
	
	var _OidcClientSettings3 = _interopRequireDefault(_OidcClientSettings2);
	
	var _RedirectNavigator = __webpack_require__(43);
	
	var _RedirectNavigator2 = _interopRequireDefault(_RedirectNavigator);
	
	var _PopupNavigator = __webpack_require__(44);
	
	var _PopupNavigator2 = _interopRequireDefault(_PopupNavigator);
	
	var _IFrameNavigator = __webpack_require__(46);
	
	var _IFrameNavigator2 = _interopRequireDefault(_IFrameNavigator);
	
	var _WebStorageStateStore = __webpack_require__(4);
	
	var _WebStorageStateStore2 = _interopRequireDefault(_WebStorageStateStore);
	
	var _Global = __webpack_require__(5);
	
	var _Global2 = _interopRequireDefault(_Global);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var DefaultAccessTokenExpiringNotificationTime = 60;
	var DefaultCheckSessionInterval = 2000;
	
	var UserManagerSettings = function (_OidcClientSettings) {
	    _inherits(UserManagerSettings, _OidcClientSettings);
	
	    function UserManagerSettings() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            popup_redirect_uri = _ref.popup_redirect_uri,
	            popup_post_logout_redirect_uri = _ref.popup_post_logout_redirect_uri,
	            popupWindowFeatures = _ref.popupWindowFeatures,
	            popupWindowTarget = _ref.popupWindowTarget,
	            silent_redirect_uri = _ref.silent_redirect_uri,
	            silentRequestTimeout = _ref.silentRequestTimeout,
	            _ref$automaticSilentR = _ref.automaticSilentRenew,
	            automaticSilentRenew = _ref$automaticSilentR === undefined ? false : _ref$automaticSilentR,
	            _ref$includeIdTokenIn = _ref.includeIdTokenInSilentRenew,
	            includeIdTokenInSilentRenew = _ref$includeIdTokenIn === undefined ? true : _ref$includeIdTokenIn,
	            _ref$monitorSession = _ref.monitorSession,
	            monitorSession = _ref$monitorSession === undefined ? true : _ref$monitorSession,
	            _ref$checkSessionInte = _ref.checkSessionInterval,
	            checkSessionInterval = _ref$checkSessionInte === undefined ? DefaultCheckSessionInterval : _ref$checkSessionInte,
	            _ref$revokeAccessToke = _ref.revokeAccessTokenOnSignout,
	            revokeAccessTokenOnSignout = _ref$revokeAccessToke === undefined ? false : _ref$revokeAccessToke,
	            _ref$accessTokenExpir = _ref.accessTokenExpiringNotificationTime,
	            accessTokenExpiringNotificationTime = _ref$accessTokenExpir === undefined ? DefaultAccessTokenExpiringNotificationTime : _ref$accessTokenExpir,
	            _ref$redirectNavigato = _ref.redirectNavigator,
	            redirectNavigator = _ref$redirectNavigato === undefined ? new _RedirectNavigator2.default() : _ref$redirectNavigato,
	            _ref$popupNavigator = _ref.popupNavigator,
	            popupNavigator = _ref$popupNavigator === undefined ? new _PopupNavigator2.default() : _ref$popupNavigator,
	            _ref$iframeNavigator = _ref.iframeNavigator,
	            iframeNavigator = _ref$iframeNavigator === undefined ? new _IFrameNavigator2.default() : _ref$iframeNavigator,
	            _ref$userStore = _ref.userStore,
	            userStore = _ref$userStore === undefined ? new _WebStorageStateStore2.default({ store: _Global2.default.sessionStorage }) : _ref$userStore;
	
	        _classCallCheck(this, UserManagerSettings);
	
	        var _this = _possibleConstructorReturn(this, (UserManagerSettings.__proto__ || Object.getPrototypeOf(UserManagerSettings)).call(this, arguments[0]));
	
	        _this._popup_redirect_uri = popup_redirect_uri;
	        _this._popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;
	        _this._popupWindowFeatures = popupWindowFeatures;
	        _this._popupWindowTarget = popupWindowTarget;
	
	        _this._silent_redirect_uri = silent_redirect_uri;
	        _this._silentRequestTimeout = silentRequestTimeout;
	        _this._automaticSilentRenew = !!automaticSilentRenew;
	        _this._includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;
	        _this._accessTokenExpiringNotificationTime = accessTokenExpiringNotificationTime;
	
	        _this._monitorSession = monitorSession;
	        _this._checkSessionInterval = checkSessionInterval;
	        _this._revokeAccessTokenOnSignout = revokeAccessTokenOnSignout;
	
	        _this._redirectNavigator = redirectNavigator;
	        _this._popupNavigator = popupNavigator;
	        _this._iframeNavigator = iframeNavigator;
	
	        _this._userStore = userStore;
	        return _this;
	    }
	
	    _createClass(UserManagerSettings, [{
	        key: 'popup_redirect_uri',
	        get: function get() {
	            return this._popup_redirect_uri;
	        }
	    }, {
	        key: 'popup_post_logout_redirect_uri',
	        get: function get() {
	            return this._popup_post_logout_redirect_uri;
	        }
	    }, {
	        key: 'popupWindowFeatures',
	        get: function get() {
	            return this._popupWindowFeatures;
	        }
	    }, {
	        key: 'popupWindowTarget',
	        get: function get() {
	            return this._popupWindowTarget;
	        }
	    }, {
	        key: 'silent_redirect_uri',
	        get: function get() {
	            return this._silent_redirect_uri;
	        }
	    }, {
	        key: 'silentRequestTimeout',
	        get: function get() {
	            return this._silentRequestTimeout;
	        }
	    }, {
	        key: 'automaticSilentRenew',
	        get: function get() {
	            return !!(this.silent_redirect_uri && this._automaticSilentRenew);
	        }
	    }, {
	        key: 'includeIdTokenInSilentRenew',
	        get: function get() {
	            return this._includeIdTokenInSilentRenew;
	        }
	    }, {
	        key: 'accessTokenExpiringNotificationTime',
	        get: function get() {
	            return this._accessTokenExpiringNotificationTime;
	        }
	    }, {
	        key: 'monitorSession',
	        get: function get() {
	            return this._monitorSession;
	        }
	    }, {
	        key: 'checkSessionInterval',
	        get: function get() {
	            return this._checkSessionInterval;
	        }
	    }, {
	        key: 'revokeAccessTokenOnSignout',
	        get: function get() {
	            return this._revokeAccessTokenOnSignout;
	        }
	    }, {
	        key: 'redirectNavigator',
	        get: function get() {
	            return this._redirectNavigator;
	        }
	    }, {
	        key: 'popupNavigator',
	        get: function get() {
	            return this._popupNavigator;
	        }
	    }, {
	        key: 'iframeNavigator',
	        get: function get() {
	            return this._iframeNavigator;
	        }
	    }, {
	        key: 'userStore',
	        get: function get() {
	            return this._userStore;
	        }
	    }]);
	
	    return UserManagerSettings;
	}(_OidcClientSettings3.default);
	
	exports.default = UserManagerSettings;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var RedirectNavigator = function () {
	    function RedirectNavigator() {
	        _classCallCheck(this, RedirectNavigator);
	    }
	
	    _createClass(RedirectNavigator, [{
	        key: "prepare",
	        value: function prepare() {
	            return Promise.resolve(this);
	        }
	    }, {
	        key: "navigate",
	        value: function navigate(params) {
	            _Log2.default.debug("RedirectNavigator.navigate");
	
	            if (!params || !params.url) {
	                _Log2.default.error("No url provided");
	                return Promise.reject(new Error("No url provided"));
	            }
	
	            window.location = params.url;
	
	            return Promise.resolve();
	        }
	    }, {
	        key: "url",
	        get: function get() {
	            _Log2.default.debug("RedirectNavigator.url");
	            return window.location.href;
	        }
	    }]);
	
	    return RedirectNavigator;
	}();
	
	exports.default = RedirectNavigator;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _PopupWindow = __webpack_require__(45);
	
	var _PopupWindow2 = _interopRequireDefault(_PopupWindow);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var PopupNavigator = function () {
	    function PopupNavigator() {
	        _classCallCheck(this, PopupNavigator);
	    }
	
	    _createClass(PopupNavigator, [{
	        key: 'prepare',
	        value: function prepare(params) {
	            var popup = new _PopupWindow2.default(params);
	            return Promise.resolve(popup);
	        }
	    }, {
	        key: 'callback',
	        value: function callback(url, keepOpen, delimiter) {
	            _Log2.default.debug("PopupNavigator.callback");
	
	            try {
	                _PopupWindow2.default.notifyOpener(url, keepOpen, delimiter);
	                return Promise.resolve();
	            } catch (e) {
	                return Promise.reject(e);
	            }
	        }
	    }]);
	
	    return PopupNavigator;
	}();
	
	exports.default = PopupNavigator;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _UrlUtility = __webpack_require__(33);
	
	var _UrlUtility2 = _interopRequireDefault(_UrlUtility);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var CheckForPopupClosedInterval = 500;
	var DefaultPopupFeatures = 'location=no,toolbar=no,width=500,height=500,left=100,top=100;';
	//const DefaultPopupFeatures = 'location=no,toolbar=no,width=500,height=500,left=100,top=100;resizable=yes';
	
	var DefaultPopupTarget = "_blank";
	
	var PopupWindow = function () {
	    function PopupWindow(params) {
	        var _this = this;
	
	        _classCallCheck(this, PopupWindow);
	
	        _Log2.default.debug("PopupWindow.ctor");
	
	        this._promise = new Promise(function (resolve, reject) {
	            _this._resolve = resolve;
	            _this._reject = reject;
	        });
	
	        var target = params.popupWindowTarget || DefaultPopupTarget;
	        var features = params.popupWindowFeatures || DefaultPopupFeatures;
	
	        this._popup = window.open('', target, features);
	        if (this._popup) {
	            _Log2.default.debug("popup successfully created");
	            this._checkForPopupClosedTimer = window.setInterval(this._checkForPopupClosed.bind(this), CheckForPopupClosedInterval);
	        }
	    }
	
	    _createClass(PopupWindow, [{
	        key: 'navigate',
	        value: function navigate(params) {
	            _Log2.default.debug("PopupWindow.navigate");
	
	            if (!this._popup) {
	                this._error("Error opening popup window");
	            } else if (!params || !params.url) {
	                this._error("No url provided");
	            } else {
	                _Log2.default.debug("Setting URL in popup");
	
	                this._id = params.id;
	                if (this._id) {
	                    window["popupCallback_" + params.id] = this._callback.bind(this);
	                }
	
	                this._popup.focus();
	                this._popup.window.location = params.url;
	            }
	
	            return this.promise;
	        }
	    }, {
	        key: '_success',
	        value: function _success(data) {
	            this._cleanup();
	
	            _Log2.default.debug("Successful response from popup window");
	            this._resolve(data);
	        }
	    }, {
	        key: '_error',
	        value: function _error(message) {
	            this._cleanup();
	
	            _Log2.default.error(message);
	            this._reject(new Error(message));
	        }
	    }, {
	        key: 'close',
	        value: function close() {
	            this._cleanup(false);
	        }
	    }, {
	        key: '_cleanup',
	        value: function _cleanup(keepOpen) {
	            _Log2.default.debug("PopupWindow._cleanup");
	
	            window.clearInterval(this._checkForPopupClosedTimer);
	            this._checkForPopupClosedTimer = null;
	
	            delete window["popupCallback_" + this._id];
	
	            if (this._popup && !keepOpen) {
	                this._popup.close();
	            }
	            this._popup = null;
	        }
	    }, {
	        key: '_checkForPopupClosed',
	        value: function _checkForPopupClosed() {
	            _Log2.default.debug("PopupWindow._checkForPopupClosed");
	
	            if (!this._popup || this._popup.closed) {
	                this._error("Popup window closed");
	            }
	        }
	    }, {
	        key: '_callback',
	        value: function _callback(url, keepOpen) {
	            _Log2.default.debug("PopupWindow._callback");
	
	            this._cleanup(keepOpen);
	
	            if (url) {
	                this._success({ url: url });
	            } else {
	                this._error("Invalid response from popup");
	            }
	        }
	    }, {
	        key: 'promise',
	        get: function get() {
	            return this._promise;
	        }
	    }], [{
	        key: 'notifyOpener',
	        value: function notifyOpener(url, keepOpen, delimiter) {
	            _Log2.default.debug("PopupWindow.notifyOpener");
	
	            if (window.opener) {
	                url = url || window.location.href;
	                if (url) {
	
	                    var data = _UrlUtility2.default.parseUrlFragment(url, delimiter);
	
	                    if (data.state) {
	                        var name = "popupCallback_" + data.state;
	                        var callback = window.opener[name];
	                        if (callback) {
	                            _Log2.default.debug("passing url message to opener");
	                            callback(url, keepOpen);
	                        } else {
	                            _Log2.default.warn("no matching callback found on opener");
	                        }
	                    } else {
	                        _Log2.default.warn("no state found in response url");
	                    }
	                }
	            }
	        }
	    }]);
	
	    return PopupWindow;
	}();
	
	exports.default = PopupWindow;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _IFrameWindow = __webpack_require__(47);
	
	var _IFrameWindow2 = _interopRequireDefault(_IFrameWindow);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var IFrameNavigator = function () {
	    function IFrameNavigator() {
	        _classCallCheck(this, IFrameNavigator);
	    }
	
	    _createClass(IFrameNavigator, [{
	        key: 'prepare',
	        value: function prepare(params) {
	            var frame = new _IFrameWindow2.default(params);
	            return Promise.resolve(frame);
	        }
	    }, {
	        key: 'callback',
	        value: function callback(url) {
	            _Log2.default.debug("IFrameNavigator.callback");
	
	            try {
	                _IFrameWindow2.default.notifyParent(url);
	                return Promise.resolve();
	            } catch (e) {
	                return Promise.reject(e);
	            }
	        }
	    }]);
	
	    return IFrameNavigator;
	}();
	
	exports.default = IFrameNavigator;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var DefaultTimeout = 10000;
	
	var IFrameWindow = function () {
	    function IFrameWindow(params) {
	        var _this = this;
	
	        _classCallCheck(this, IFrameWindow);
	
	        _Log2.default.debug("IFrameWindow.ctor");
	
	        this._promise = new Promise(function (resolve, reject) {
	            _this._resolve = resolve;
	            _this._reject = reject;
	        });
	
	        this._boundMessageEvent = this._message.bind(this);
	        window.addEventListener("message", this._boundMessageEvent, false);
	
	        this._frame = window.document.createElement("iframe");
	
	        // shotgun approach
	        this._frame.style.visibility = "hidden";
	        this._frame.style.position = "absolute";
	        this._frame.style.display = "none";
	        this._frame.style.width = 0;
	        this._frame.style.height = 0;
	
	        window.document.body.appendChild(this._frame);
	    }
	
	    _createClass(IFrameWindow, [{
	        key: "navigate",
	        value: function navigate(params) {
	            _Log2.default.debug("IFrameWindow.navigate");
	
	            if (!params || !params.url) {
	                this._error("No url provided");
	            } else {
	                var timeout = params.silentRequestTimeout || DefaultTimeout;
	                _Log2.default.debug("Using timeout of:", timeout);
	                this._timer = window.setTimeout(this._timeout.bind(this), timeout);
	                this._frame.src = params.url;
	            }
	
	            return this.promise;
	        }
	    }, {
	        key: "_success",
	        value: function _success(data) {
	            this._cleanup();
	
	            _Log2.default.debug("Successful response from frame window");
	            this._resolve(data);
	        }
	    }, {
	        key: "_error",
	        value: function _error(message) {
	            this._cleanup();
	
	            _Log2.default.error(message);
	            this._reject(new Error(message));
	        }
	    }, {
	        key: "close",
	        value: function close() {
	            this._cleanup();
	        }
	    }, {
	        key: "_cleanup",
	        value: function _cleanup() {
	            if (this._frame) {
	                _Log2.default.debug("IFrameWindow._cleanup");
	
	                window.removeEventListener("message", this._boundMessageEvent, false);
	                window.clearTimeout(this._timer);
	                window.document.body.removeChild(this._frame);
	
	                this._timer = null;
	                this._frame = null;
	                this._boundMessageEvent = null;
	            }
	        }
	    }, {
	        key: "_timeout",
	        value: function _timeout() {
	            _Log2.default.debug("IFrameWindow._timeout");
	            this._error("Frame window timed out");
	        }
	    }, {
	        key: "_message",
	        value: function _message(e) {
	            _Log2.default.debug("IFrameWindow._message");
	
	            if (this._timer && e.origin === this._origin && e.source === this._frame.contentWindow) {
	                var url = e.data;
	                if (url) {
	                    this._success({ url: url });
	                } else {
	                    this._error("Invalid response from frame");
	                }
	            }
	        }
	    }, {
	        key: "promise",
	        get: function get() {
	            return this._promise;
	        }
	    }, {
	        key: "_origin",
	        get: function get() {
	            return location.protocol + "//" + location.host;
	        }
	    }], [{
	        key: "notifyParent",
	        value: function notifyParent(url) {
	            _Log2.default.debug("IFrameWindow.notifyParent");
	
	            if (window.parent && window !== window.parent) {
	                url = url || window.location.href;
	                if (url) {
	                    _Log2.default.debug("posting url message to parent");
	                    window.parent.postMessage(url, location.protocol + "//" + location.host);
	                }
	            }
	        }
	    }]);
	
	    return IFrameWindow;
	}();
	
	exports.default = IFrameWindow;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var User = function () {
	    function User(_ref) {
	        var id_token = _ref.id_token,
	            session_state = _ref.session_state,
	            access_token = _ref.access_token,
	            token_type = _ref.token_type,
	            scope = _ref.scope,
	            profile = _ref.profile,
	            expires_at = _ref.expires_at,
	            state = _ref.state;
	
	        _classCallCheck(this, User);
	
	        this.id_token = id_token;
	        this.session_state = session_state;
	        this.access_token = access_token;
	        this.token_type = token_type;
	        this.scope = scope;
	        this.profile = profile;
	        this.expires_at = expires_at;
	        this.state = state;
	    }
	
	    _createClass(User, [{
	        key: "toStorageString",
	        value: function toStorageString() {
	            _Log2.default.debug("User.toStorageString");
	            return JSON.stringify({
	                id_token: this.id_token,
	                session_state: this.session_state,
	                access_token: this.access_token,
	                token_type: this.token_type,
	                scope: this.scope,
	                profile: this.profile,
	                expires_at: this.expires_at
	            });
	        }
	    }, {
	        key: "expires_in",
	        get: function get() {
	            if (this.expires_at) {
	                var now = parseInt(Date.now() / 1000);
	                return this.expires_at - now;
	            }
	            return undefined;
	        }
	    }, {
	        key: "expired",
	        get: function get() {
	            var expires_in = this.expires_in;
	            if (expires_in !== undefined) {
	                return expires_in <= 0;
	            }
	            return undefined;
	        }
	    }, {
	        key: "scopes",
	        get: function get() {
	            return (this.scope || "").split(" ");
	        }
	    }], [{
	        key: "fromStorageString",
	        value: function fromStorageString(storageString) {
	            _Log2.default.debug("User.fromStorageString");
	            return new User(JSON.parse(storageString));
	        }
	    }]);
	
	    return User;
	}();
	
	exports.default = User;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _AccessTokenEvents2 = __webpack_require__(50);
	
	var _AccessTokenEvents3 = _interopRequireDefault(_AccessTokenEvents2);
	
	var _Event = __webpack_require__(52);
	
	var _Event2 = _interopRequireDefault(_Event);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var UserManagerEvents = function (_AccessTokenEvents) {
	    _inherits(UserManagerEvents, _AccessTokenEvents);
	
	    function UserManagerEvents(settings) {
	        _classCallCheck(this, UserManagerEvents);
	
	        var _this = _possibleConstructorReturn(this, (UserManagerEvents.__proto__ || Object.getPrototypeOf(UserManagerEvents)).call(this, settings));
	
	        _this._userLoaded = new _Event2.default("User loaded");
	        _this._userUnloaded = new _Event2.default("User unloaded");
	        _this._silentRenewError = new _Event2.default("Silent renew error");
	        _this._userSignedOut = new _Event2.default("User signed out");
	        _this._userSessionChanged = new _Event2.default("User session changed");
	        return _this;
	    }
	
	    _createClass(UserManagerEvents, [{
	        key: 'load',
	        value: function load(user) {
	            var raiseEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	            _Log2.default.debug("UserManagerEvents.load");
	            _get(UserManagerEvents.prototype.__proto__ || Object.getPrototypeOf(UserManagerEvents.prototype), 'load', this).call(this, user);
	            if (raiseEvent) {
	                this._userLoaded.raise(user);
	            }
	        }
	    }, {
	        key: 'unload',
	        value: function unload() {
	            _Log2.default.debug("UserManagerEvents.unload");
	            _get(UserManagerEvents.prototype.__proto__ || Object.getPrototypeOf(UserManagerEvents.prototype), 'unload', this).call(this);
	            this._userUnloaded.raise();
	        }
	    }, {
	        key: 'addUserLoaded',
	        value: function addUserLoaded(cb) {
	            this._userLoaded.addHandler(cb);
	        }
	    }, {
	        key: 'removeUserLoaded',
	        value: function removeUserLoaded(cb) {
	            this._userLoaded.removeHandler(cb);
	        }
	    }, {
	        key: 'addUserUnloaded',
	        value: function addUserUnloaded(cb) {
	            this._userUnloaded.addHandler(cb);
	        }
	    }, {
	        key: 'removeUserUnloaded',
	        value: function removeUserUnloaded(cb) {
	            this._userUnloaded.removeHandler(cb);
	        }
	    }, {
	        key: 'addSilentRenewError',
	        value: function addSilentRenewError(cb) {
	            this._silentRenewError.addHandler(cb);
	        }
	    }, {
	        key: 'removeSilentRenewError',
	        value: function removeSilentRenewError(cb) {
	            this._silentRenewError.removeHandler(cb);
	        }
	    }, {
	        key: '_raiseSilentRenewError',
	        value: function _raiseSilentRenewError(e) {
	            _Log2.default.debug("UserManagerEvents._raiseSilentRenewError", e.message);
	            this._silentRenewError.raise(e);
	        }
	    }, {
	        key: 'addUserSignedOut',
	        value: function addUserSignedOut(cb) {
	            this._userSignedOut.addHandler(cb);
	        }
	    }, {
	        key: 'removeUserSignedOut',
	        value: function removeUserSignedOut(cb) {
	            this._userSignedOut.removeHandler(cb);
	        }
	    }, {
	        key: '_raiseUserSignedOut',
	        value: function _raiseUserSignedOut(e) {
	            _Log2.default.debug("UserManagerEvents._raiseUserSignedOut");
	            this._userSignedOut.raise(e);
	        }
	    }, {
	        key: 'addUserSessionChanged',
	        value: function addUserSessionChanged(cb) {
	            this._userSessionChanged.addHandler(cb);
	        }
	    }, {
	        key: 'removeUserSessionChanged',
	        value: function removeUserSessionChanged(cb) {
	            this._userSessionChanged.removeHandler(cb);
	        }
	    }, {
	        key: '_raiseUserSessionChanged',
	        value: function _raiseUserSessionChanged(e) {
	            _Log2.default.debug("UserManagerEvents._raiseUserSessionChanged");
	            this._userSessionChanged.raise(e);
	        }
	    }]);
	
	    return UserManagerEvents;
	}(_AccessTokenEvents3.default);
	
	exports.default = UserManagerEvents;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _Timer = __webpack_require__(51);
	
	var _Timer2 = _interopRequireDefault(_Timer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var DefaultAccessTokenExpiringNotificationTime = 60; // seconds
	
	var AccessTokenEvents = function () {
	    function AccessTokenEvents() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            _ref$accessTokenExpir = _ref.accessTokenExpiringNotificationTime,
	            accessTokenExpiringNotificationTime = _ref$accessTokenExpir === undefined ? DefaultAccessTokenExpiringNotificationTime : _ref$accessTokenExpir,
	            _ref$accessTokenExpir2 = _ref.accessTokenExpiringTimer,
	            accessTokenExpiringTimer = _ref$accessTokenExpir2 === undefined ? new _Timer2.default("Access token expiring") : _ref$accessTokenExpir2,
	            _ref$accessTokenExpir3 = _ref.accessTokenExpiredTimer,
	            accessTokenExpiredTimer = _ref$accessTokenExpir3 === undefined ? new _Timer2.default("Access token expired") : _ref$accessTokenExpir3;
	
	        _classCallCheck(this, AccessTokenEvents);
	
	        this._accessTokenExpiringNotificationTime = accessTokenExpiringNotificationTime;
	
	        this._accessTokenExpiring = accessTokenExpiringTimer;
	        this._accessTokenExpired = accessTokenExpiredTimer;
	    }
	
	    _createClass(AccessTokenEvents, [{
	        key: 'load',
	        value: function load(container) {
	            _Log2.default.debug("AccessTokenEvents.load");
	
	            this._cancelTimers();
	
	            // only register events if there's an access token where we care about expiration
	            if (container.access_token) {
	                var duration = container.expires_in;
	                _Log2.default.debug("access token present, remaining duration:", duration);
	
	                if (duration > 0) {
	                    // only register expiring if we still have time
	                    var expiring = duration - this._accessTokenExpiringNotificationTime;
	                    if (expiring <= 0) {
	                        expiring = 1;
	                    }
	                    _Log2.default.debug("registering expiring timer in:", expiring);
	                    this._accessTokenExpiring.init(expiring);
	                }
	
	                // always register expired. if it's negative, it will still fire
	                var expired = duration + 1;
	                _Log2.default.debug("registering expired timer in:", expired);
	                this._accessTokenExpired.init(expired);
	            }
	        }
	    }, {
	        key: 'unload',
	        value: function unload() {
	            _Log2.default.debug("AccessTokenEvents.unload");
	            this._cancelTimers();
	        }
	    }, {
	        key: '_cancelTimers',
	        value: function _cancelTimers() {
	            _Log2.default.debug("canceling existing access token timers");
	            this._accessTokenExpiring.cancel();
	            this._accessTokenExpired.cancel();
	        }
	    }, {
	        key: 'addAccessTokenExpiring',
	        value: function addAccessTokenExpiring(cb) {
	            this._accessTokenExpiring.addHandler(cb);
	        }
	    }, {
	        key: 'removeAccessTokenExpiring',
	        value: function removeAccessTokenExpiring(cb) {
	            this._accessTokenExpiring.removeHandler(cb);
	        }
	    }, {
	        key: 'addAccessTokenExpired',
	        value: function addAccessTokenExpired(cb) {
	            this._accessTokenExpired.addHandler(cb);
	        }
	    }, {
	        key: 'removeAccessTokenExpired',
	        value: function removeAccessTokenExpired(cb) {
	            this._accessTokenExpired.removeHandler(cb);
	        }
	    }]);
	
	    return AccessTokenEvents;
	}();
	
	exports.default = AccessTokenEvents;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _Global = __webpack_require__(5);
	
	var _Global2 = _interopRequireDefault(_Global);
	
	var _Event2 = __webpack_require__(52);
	
	var _Event3 = _interopRequireDefault(_Event2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var TimerDuration = 5; // seconds
	
	var Timer = function (_Event) {
	    _inherits(Timer, _Event);
	
	    function Timer(name) {
	        var timer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _Global2.default.timer;
	
	        _classCallCheck(this, Timer);
	
	        var _this = _possibleConstructorReturn(this, (Timer.__proto__ || Object.getPrototypeOf(Timer)).call(this, name));
	
	        _this._timer = timer;
	        _this._nowFunc = function () {
	            return Date.now() / 1000;
	        };
	        return _this;
	    }
	
	    _createClass(Timer, [{
	        key: 'init',
	        value: function init(duration) {
	            this.cancel();
	
	            if (duration <= 0) {
	                duration = 1;
	            }
	            duration = parseInt(duration);
	
	            _Log2.default.debug("Timer.init timer " + this._name + " for duration:", duration);
	            this._expiration = this.now + duration;
	
	            // we're using a fairly short timer and then checking the expiration in the 
	            // callback to handle scenarios where the browser device sleeps, and then 
	            // the timers end up getting delayed.
	            var timerDuration = TimerDuration;
	            if (duration < timerDuration) {
	                timerDuration = duration;
	            }
	            this._timerHandle = this._timer.setInterval(this._callback.bind(this), timerDuration * 1000);
	        }
	    }, {
	        key: 'cancel',
	        value: function cancel() {
	            if (this._timerHandle) {
	                _Log2.default.debug("Timer.cancel: ", this._name);
	                this._timer.clearInterval(this._timerHandle);
	                this._timerHandle = null;
	            }
	        }
	    }, {
	        key: '_callback',
	        value: function _callback() {
	            var diff = this._expiration - this.now;
	            _Log2.default.debug("Timer._callback; " + this._name + " timer expires in:", diff);
	
	            if (this._expiration <= this.now) {
	                this.cancel();
	                _get(Timer.prototype.__proto__ || Object.getPrototypeOf(Timer.prototype), 'raise', this).call(this);
	            }
	        }
	    }, {
	        key: 'now',
	        get: function get() {
	            return parseInt(this._nowFunc());
	        }
	    }]);
	
	    return Timer;
	}(_Event3.default);
	
	exports.default = Timer;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Event = function () {
	    function Event(name) {
	        _classCallCheck(this, Event);
	
	        this._name = name;
	        this._callbacks = [];
	    }
	
	    _createClass(Event, [{
	        key: "addHandler",
	        value: function addHandler(cb) {
	            this._callbacks.push(cb);
	        }
	    }, {
	        key: "removeHandler",
	        value: function removeHandler(cb) {
	            var idx = this._callbacks.findIndex(function (item) {
	                return item === cb;
	            });
	            if (idx >= 0) {
	                this._callbacks.splice(idx, 1);
	            }
	        }
	    }, {
	        key: "raise",
	        value: function raise() {
	            _Log2.default.debug("Raising event: " + this._name);
	            for (var i = 0; i < this._callbacks.length; i++) {
	                var _callbacks;
	
	                (_callbacks = this._callbacks)[i].apply(_callbacks, arguments);
	            }
	        }
	    }]);
	
	    return Event;
	}();
	
	exports.default = Event;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SilentRenewService = function () {
	    function SilentRenewService(userManager) {
	        _classCallCheck(this, SilentRenewService);
	
	        this._userManager = userManager;
	    }
	
	    _createClass(SilentRenewService, [{
	        key: "start",
	        value: function start() {
	            if (!this._callback) {
	                this._callback = this._tokenExpiring.bind(this);
	                this._userManager.events.addAccessTokenExpiring(this._callback);
	
	                // this will trigger loading of the user so the expiring events can be initialized
	                this._userManager.getUser().then(function (user) {
	                    // deliberate nop
	                }).catch(function (err) {
	                    // catch to suppress errors since we're in a ctor
	                    _Log2.default.error("Error from getUser:", err.message);
	                });
	            }
	        }
	    }, {
	        key: "stop",
	        value: function stop() {
	            if (this._callback) {
	                this._userManager.events.removeAccessTokenExpiring(this._callback);
	                delete this._callback;
	            }
	        }
	    }, {
	        key: "_tokenExpiring",
	        value: function _tokenExpiring() {
	            var _this = this;
	
	            _Log2.default.debug("SilentRenewService automatically renewing access token");
	
	            this._userManager.signinSilent().then(function (user) {
	                _Log2.default.debug("Silent token renewal successful");
	            }, function (err) {
	                _Log2.default.error("Error from signinSilent:", err.message);
	                _this._userManager.events._raiseSilentRenewError(err);
	            });
	        }
	    }]);
	
	    return SilentRenewService;
	}();
	
	exports.default = SilentRenewService;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _CheckSessionIFrame = __webpack_require__(55);
	
	var _CheckSessionIFrame2 = _interopRequireDefault(_CheckSessionIFrame);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SessionMonitor = function () {
	    function SessionMonitor(userManager) {
	        var _this = this;
	
	        var CheckSessionIFrameCtor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _CheckSessionIFrame2.default;
	
	        _classCallCheck(this, SessionMonitor);
	
	        if (!userManager) {
	            _Log2.default.error("No user manager passed to SessionMonitor");
	            throw new Error("userManager");
	        }
	
	        this._userManager = userManager;
	        this._CheckSessionIFrameCtor = CheckSessionIFrameCtor;
	
	        this._userManager.events.addUserLoaded(this._start.bind(this));
	        this._userManager.events.addUserUnloaded(this._stop.bind(this));
	
	        this._userManager.getUser().then(function (user) {
	            if (user) {
	                _this._start(user);
	            }
	        }).catch(function (err) {
	            // catch to suppress errors since we're in a ctor
	            _Log2.default.error("SessionMonitor ctor; error from getUser:", err.message);
	        });
	    }
	
	    _createClass(SessionMonitor, [{
	        key: '_start',
	        value: function _start(user) {
	            var _this2 = this;
	
	            var session_state = user.session_state;
	
	            if (session_state) {
	                this._sub = user.profile.sub;
	                this._sid = user.profile.sid;
	                _Log2.default.debug("SessionMonitor._start; session_state:", session_state, ", sub:", this._sub);
	
	                if (!this._checkSessionIFrame) {
	                    this._metadataService.getCheckSessionIframe().then(function (url) {
	                        if (url) {
	                            _Log2.default.debug("Initializing check session iframe");
	
	                            var client_id = _this2._client_id;
	                            var interval = _this2._checkSessionInterval;
	
	                            _this2._checkSessionIFrame = new _this2._CheckSessionIFrameCtor(_this2._callback.bind(_this2), client_id, url, interval);
	                            _this2._checkSessionIFrame.load().then(function () {
	                                _this2._checkSessionIFrame.start(session_state);
	                            });
	                        } else {
	                            _Log2.default.warn("No check session iframe found in the metadata");
	                        }
	                    }).catch(function (err) {
	                        // catch to suppress errors since we're in non-promise callback
	                        _Log2.default.error("Error from getCheckSessionIframe:", err.message);
	                    });
	                } else {
	                    this._checkSessionIFrame.start(session_state);
	                }
	            }
	        }
	    }, {
	        key: '_stop',
	        value: function _stop() {
	            _Log2.default.debug("SessionMonitor._stop");
	
	            this._sub = null;
	            this._sid = null;
	
	            if (this._checkSessionIFrame) {
	                this._checkSessionIFrame.stop();
	            }
	        }
	    }, {
	        key: '_callback',
	        value: function _callback() {
	            var _this3 = this;
	
	            _Log2.default.debug("SessionMonitor._callback");
	
	            this._userManager.querySessionStatus().then(function (session) {
	                var raiseUserSignedOutEvent = true;
	
	                if (session) {
	                    if (session.sub === _this3._sub) {
	                        raiseUserSignedOutEvent = false;
	                        _this3._checkSessionIFrame.start(session.session_state);
	
	                        if (session.sid === _this3._sid) {
	                            _Log2.default.debug("Same sub still logged in at OP, restarting check session iframe; session_state:", session.session_state);
	                        } else {
	                            _Log2.default.debug("Same sub still logged in at OP, session state has changed, restarting check session iframe; session_state:", session.session_state);
	                            _this3._userManager.events._raiseUserSessionChanged();
	                        }
	                    } else {
	                        _Log2.default.debug("Different subject signed into OP:", session.sub);
	                    }
	                } else {
	                    _Log2.default.debug("Subject no longer signed into OP");
	                }
	
	                if (raiseUserSignedOutEvent) {
	                    _Log2.default.debug("SessionMonitor._callback; raising signed out event");
	                    _this3._userManager.events._raiseUserSignedOut();
	                }
	            }).catch(function (err) {
	                _Log2.default.debug("Error calling queryCurrentSigninSession; raising signed out event", err.message);
	                _this3._userManager.events._raiseUserSignedOut();
	            });
	        }
	    }, {
	        key: '_settings',
	        get: function get() {
	            return this._userManager.settings;
	        }
	    }, {
	        key: '_metadataService',
	        get: function get() {
	            return this._userManager.metadataService;
	        }
	    }, {
	        key: '_client_id',
	        get: function get() {
	            return this._settings.client_id;
	        }
	    }, {
	        key: '_checkSessionInterval',
	        get: function get() {
	            return this._settings.checkSessionInterval;
	        }
	    }]);
	
	    return SessionMonitor;
	}();
	
	exports.default = SessionMonitor;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var DefaultInterval = 2000;
	
	var CheckSessionIFrame = function () {
	    function CheckSessionIFrame(callback, client_id, url, interval) {
	        _classCallCheck(this, CheckSessionIFrame);
	
	        this._callback = callback;
	        this._client_id = client_id;
	        this._url = url;
	        this._interval = interval || DefaultInterval;
	
	        var idx = url.indexOf("/", url.indexOf("//") + 2);
	        this._frame_origin = url.substr(0, idx);
	
	        this._frame = window.document.createElement("iframe");
	
	        // shotgun approach
	        this._frame.style.visibility = "hidden";
	        this._frame.style.position = "absolute";
	        this._frame.style.display = "none";
	        this._frame.style.width = 0;
	        this._frame.style.height = 0;
	
	        this._frame.src = url;
	    }
	
	    _createClass(CheckSessionIFrame, [{
	        key: "load",
	        value: function load() {
	            var _this = this;
	
	            return new Promise(function (resolve) {
	                _this._frame.onload = function () {
	                    resolve();
	                };
	
	                window.document.body.appendChild(_this._frame);
	                _this._boundMessageEvent = _this._message.bind(_this);
	                window.addEventListener("message", _this._boundMessageEvent, false);
	            });
	        }
	    }, {
	        key: "_message",
	        value: function _message(e) {
	            if (e.origin === this._frame_origin && e.source === this._frame.contentWindow) {
	                if (e.data === "error") {
	                    _Log2.default.error("error message from check session op iframe");
	                    this.stop();
	                } else if (e.data === "changed") {
	                    _Log2.default.debug("changed message from check session op iframe");
	                    this.stop();
	                    this._callback();
	                } else {
	                    _Log2.default.debug(e.data + " message from check session op iframe");
	                }
	            }
	        }
	    }, {
	        key: "start",
	        value: function start(session_state) {
	            var _this2 = this;
	
	            if (this._session_state !== session_state) {
	                _Log2.default.debug("CheckSessionIFrame.start");
	
	                this.stop();
	
	                this._session_state = session_state;
	
	                this._timer = window.setInterval(function () {
	                    _this2._frame.contentWindow.postMessage(_this2._client_id + " " + _this2._session_state, _this2._frame_origin);
	                }, this._interval);
	            }
	        }
	    }, {
	        key: "stop",
	        value: function stop() {
	            _Log2.default.debug("CheckSessionIFrame.stop");
	
	            this._session_state = null;
	
	            if (this._timer) {
	                window.clearInterval(this._timer);
	                this._timer = null;
	            }
	        }
	    }]);
	
	    return CheckSessionIFrame;
	}();
	
	exports.default = CheckSessionIFrame;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _MetadataService = __webpack_require__(7);
	
	var _MetadataService2 = _interopRequireDefault(_MetadataService);
	
	var _Global = __webpack_require__(5);
	
	var _Global2 = _interopRequireDefault(_Global);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var AccessTokenTypeHint = "access_token";
	
	var TokenRevocationClient = function () {
	    function TokenRevocationClient(settings) {
	        var XMLHttpRequestCtor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _Global2.default.XMLHttpRequest;
	        var MetadataServiceCtor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _MetadataService2.default;
	
	        _classCallCheck(this, TokenRevocationClient);
	
	        if (!settings) {
	            _Log2.default.error("No settings provided");
	            throw new Error("No settings provided.");
	        }
	
	        this._settings = settings;
	        this._XMLHttpRequestCtor = XMLHttpRequestCtor;
	        this._metadataService = new MetadataServiceCtor(this._settings);
	    }
	
	    _createClass(TokenRevocationClient, [{
	        key: 'revoke',
	        value: function revoke(accessToken, required) {
	            var _this = this;
	
	            _Log2.default.debug("TokenRevocationClient.revoke");
	
	            if (!accessToken) {
	                _Log2.default.error("No accessToken provided");
	                throw new Error("No accessToken provided.");
	            }
	
	            return this._metadataService.getRevocationEndpoint().then(function (url) {
	                if (!url) {
	                    if (required) {
	                        _Log2.default.error("Revocation not supported");
	                        throw new Error("Revocation not supported");
	                    }
	
	                    // not required, so don't error and just return
	                    return;
	                }
	
	                var client_id = _this._settings.client_id;
	                var client_secret = _this._settings.client_secret;
	                return _this._revoke(url, client_id, client_secret, accessToken);
	            });
	        }
	    }, {
	        key: '_revoke',
	        value: function _revoke(url, client_id, client_secret, accessToken) {
	            var _this2 = this;
	
	            _Log2.default.debug("Calling revocation endpoint");
	
	            return new Promise(function (resolve, reject) {
	
	                var xhr = new _this2._XMLHttpRequestCtor();
	                xhr.open("POST", url);
	
	                xhr.onload = function () {
	                    _Log2.default.debug("HTTP response received, status", xhr.status);
	
	                    if (xhr.status === 200) {
	                        resolve();
	                    } else {
	                        reject(Error(xhr.statusText + " (" + xhr.status + ")"));
	                    }
	                };
	
	                var body = "client_id=" + encodeURIComponent(client_id);
	                if (client_secret) {
	                    body += "&client_secret=" + encodeURIComponent(client_secret);
	                }
	                body += "&token_type_hint=" + encodeURIComponent(AccessTokenTypeHint);
	                body += "&token=" + encodeURIComponent(accessToken);
	
	                xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
	                xhr.send(body);
	            });
	        }
	    }]);
	
	    return TokenRevocationClient;
	}();
	
	exports.default = TokenRevocationClient;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _CordovaPopupWindow = __webpack_require__(58);
	
	var _CordovaPopupWindow2 = _interopRequireDefault(_CordovaPopupWindow);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var CordovaPopupNavigator = function () {
	    function CordovaPopupNavigator() {
	        _classCallCheck(this, CordovaPopupNavigator);
	    }
	
	    _createClass(CordovaPopupNavigator, [{
	        key: 'prepare',
	        value: function prepare(params) {
	            var popup = new _CordovaPopupWindow2.default(params);
	            return Promise.resolve(popup);
	        }
	    }]);
	
	    return CordovaPopupNavigator;
	}();
	
	exports.default = CordovaPopupNavigator;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var DefaultPopupFeatures = 'location=no,toolbar=no,zoom=no';
	var DefaultPopupTarget = "_blank";
	
	var CordovaPopupWindow = function () {
	    function CordovaPopupWindow(params) {
	        var _this = this;
	
	        _classCallCheck(this, CordovaPopupWindow);
	
	        _Log2.default.debug("CordovaPopupWindow.ctor");
	
	        this._promise = new Promise(function (resolve, reject) {
	            _this._resolve = resolve;
	            _this._reject = reject;
	        });
	
	        this.features = params.popupWindowFeatures || DefaultPopupFeatures;
	        this.target = params.popupWindowTarget || DefaultPopupTarget;
	
	        this.redirect_uri = params.startUrl;
	        _Log2.default.debug("redirect_uri: " + this.redirect_uri);
	    }
	
	    _createClass(CordovaPopupWindow, [{
	        key: '_isInAppBrowserInstalled',
	        value: function _isInAppBrowserInstalled(cordovaMetadata) {
	            return ["cordova-plugin-inappbrowser", "cordova-plugin-inappbrowser.inappbrowser", "org.apache.cordova.inappbrowser"].some(function (name) {
	                return cordovaMetadata.hasOwnProperty(name);
	            });
	        }
	    }, {
	        key: 'navigate',
	        value: function navigate(params) {
	            _Log2.default.debug("CordovaPopupWindow.navigate");
	
	            if (!params || !params.url) {
	                this._error("No url provided");
	            } else {
	                if (!window.cordova) {
	                    return this._error("cordova is undefined");
	                }
	
	                var cordovaMetadata = window.cordova.require("cordova/plugin_list").metadata;
	                if (this._isInAppBrowserInstalled(cordovaMetadata) === false) {
	                    return this._error("InAppBrowser plugin not found");
	                }
	                this._popup = cordova.InAppBrowser.open(params.url, this.target, this.features);
	                if (this._popup) {
	                    _Log2.default.debug("popup successfully created");
	
	                    this._exitCallbackEvent = this._exitCallback.bind(this);
	                    this._loadStartCallbackEvent = this._loadStartCallback.bind(this);
	
	                    this._popup.addEventListener("exit", this._exitCallbackEvent, false);
	                    this._popup.addEventListener("loadstart", this._loadStartCallbackEvent, false);
	                } else {
	                    this._error("Error opening popup window");
	                }
	            }
	            return this.promise;
	        }
	    }, {
	        key: '_loadStartCallback',
	        value: function _loadStartCallback(event) {
	            if (event.url.indexOf(this.redirect_uri) === 0) {
	                this._success({ url: event.url });
	            }
	        }
	    }, {
	        key: '_exitCallback',
	        value: function _exitCallback(message) {
	            this._error(message);
	        }
	    }, {
	        key: '_success',
	        value: function _success(data) {
	            this._cleanup();
	
	            _Log2.default.debug("Successful response from cordova popup window");
	            this._resolve(data);
	        }
	    }, {
	        key: '_error',
	        value: function _error(message) {
	            this._cleanup();
	
	            _Log2.default.error(message);
	            this._reject(new Error(message));
	        }
	    }, {
	        key: 'close',
	        value: function close() {
	            this._cleanup();
	        }
	    }, {
	        key: '_cleanup',
	        value: function _cleanup() {
	            _Log2.default.debug("CordovaPopupWindow._cleanup");
	
	            if (this._popup) {
	                this._popup.removeEventListener("exit", this._exitCallbackEvent, false);
	                this._popup.removeEventListener("loadstart", this._loadStartCallbackEvent, false);
	                this._popup.close();
	            }
	            this._popup = null;
	        }
	    }, {
	        key: 'promise',
	        get: function get() {
	            return this._promise;
	        }
	    }]);
	
	    return CordovaPopupWindow;
	}();
	
	exports.default = CordovaPopupWindow;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
	// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
	
	var _Log = __webpack_require__(1);
	
	var _Log2 = _interopRequireDefault(_Log);
	
	var _CordovaPopupWindow = __webpack_require__(58);
	
	var _CordovaPopupWindow2 = _interopRequireDefault(_CordovaPopupWindow);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var CordovaIFrameNavigator = function () {
	    function CordovaIFrameNavigator() {
	        _classCallCheck(this, CordovaIFrameNavigator);
	    }
	
	    _createClass(CordovaIFrameNavigator, [{
	        key: 'prepare',
	        value: function prepare(params) {
	            params.popupWindowFeatures = 'hidden=yes';
	            var popup = new _CordovaPopupWindow2.default(params);
	            return Promise.resolve(popup);
	        }
	    }]);
	
	    return CordovaIFrameNavigator;
	}();
	
	exports.default = CordovaIFrameNavigator;

/***/ })
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA1YTVkNTI2YjU5ZjVjNTdmYmFiMyIsIndlYnBhY2s6Ly8vLi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTG9nLmpzIiwid2VicGFjazovLy8uL3NyYy9PaWRjQ2xpZW50LmpzIiwid2VicGFjazovLy8uL3NyYy9PaWRjQ2xpZW50U2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1dlYlN0b3JhZ2VTdGF0ZVN0b3JlLmpzIiwid2VicGFjazovLy8uL3NyYy9HbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1Jlc3BvbnNlVmFsaWRhdG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9NZXRhZGF0YVNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0pzb25TZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NyYy9Vc2VySW5mb1NlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0Vycm9yUmVzcG9uc2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0pvc2VVdGlsLmpzIiwid2VicGFjazovLy8uLi9pZHRva2VuLXZlcmlmaWVyL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vaWR0b2tlbi12ZXJpZmllci9+L2NyeXB0by1qcy9zaGEyNTYuanMiLCJ3ZWJwYWNrOi8vLy4uL2lkdG9rZW4tdmVyaWZpZXIvfi9jcnlwdG8tanMvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi4vaWR0b2tlbi12ZXJpZmllci9+L2NyeXB0by1qcy9lbmMtYmFzZTY0LmpzIiwid2VicGFjazovLy8uLi9pZHRva2VuLXZlcmlmaWVyL34vY3J5cHRvLWpzL2VuYy1oZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2lkdG9rZW4tdmVyaWZpZXIvc3JjL2hlbHBlcnMvcnNhLXZlcmlmaWVyLmpzIiwid2VicGFjazovLy8uLi9pZHRva2VuLXZlcmlmaWVyL34vanNibi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vaWR0b2tlbi12ZXJpZmllci9zcmMvaGVscGVycy9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy4uL2lkdG9rZW4tdmVyaWZpZXIvfi9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2lkdG9rZW4tdmVyaWZpZXIvc3JjL2hlbHBlcnMvandrcy5qcyIsIndlYnBhY2s6Ly8vLi4vaWR0b2tlbi12ZXJpZmllci9+L3VybC1qb2luL2xpYi91cmwtam9pbi5qcyIsIndlYnBhY2s6Ly8vLi4vaWR0b2tlbi12ZXJpZmllci9+L3N1cGVyYWdlbnQvbGliL2NsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vaWR0b2tlbi12ZXJpZmllci9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9pZHRva2VuLXZlcmlmaWVyL34vc3VwZXJhZ2VudC9saWIvcmVxdWVzdC1iYXNlLmpzIiwid2VicGFjazovLy8uLi9pZHRva2VuLXZlcmlmaWVyL34vc3VwZXJhZ2VudC9saWIvaXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9pZHRva2VuLXZlcmlmaWVyL34vc3VwZXJhZ2VudC9saWIvcmVzcG9uc2UtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi4vaWR0b2tlbi12ZXJpZmllci9+L3N1cGVyYWdlbnQvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uLi9pZHRva2VuLXZlcmlmaWVyL34vc3VwZXJhZ2VudC9saWIvYWdlbnQtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi4vaWR0b2tlbi12ZXJpZmllci9zcmMvaGVscGVycy9lcnJvci5qcyIsIndlYnBhY2s6Ly8vLi4vaWR0b2tlbi12ZXJpZmllci9zcmMvaGVscGVycy9kdW1teS1jYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2lnbmluUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvVXJsVXRpbGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2lnbmluU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1N0YXRlLmpzIiwid2VicGFjazovLy8uL3NyYy9yYW5kb20uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NpZ25pblJlc3BvbnNlLmpzIiwid2VicGFjazovLy8uL3NyYy9TaWdub3V0UmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2lnbm91dFJlc3BvbnNlLmpzIiwid2VicGFjazovLy8uL3NyYy9Jbk1lbW9yeVdlYlN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1VzZXJNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9Vc2VyTWFuYWdlclNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL3NyYy9SZWRpcmVjdE5hdmlnYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUG9wdXBOYXZpZ2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1BvcHVwV2luZG93LmpzIiwid2VicGFjazovLy8uL3NyYy9JRnJhbWVOYXZpZ2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0lGcmFtZVdpbmRvdy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvVXNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvVXNlck1hbmFnZXJFdmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FjY2Vzc1Rva2VuRXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9UaW1lci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NpbGVudFJlbmV3U2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2Vzc2lvbk1vbml0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoZWNrU2Vzc2lvbklGcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvVG9rZW5SZXZvY2F0aW9uQ2xpZW50LmpzIiwid2VicGFjazovLy8uL3NyYy9Db3Jkb3ZhUG9wdXBOYXZpZ2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NvcmRvdmFQb3B1cFdpbmRvdy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvQ29yZG92YUlGcmFtZU5hdmlnYXRvci5qcyJdLCJuYW1lcyI6WyJMb2ciLCJyZXF1aXJlIiwiZGVmYXVsdCIsIk9pZGNDbGllbnQiLCJPaWRjQ2xpZW50U2V0dGluZ3MiLCJXZWJTdG9yYWdlU3RhdGVTdG9yZSIsIkluTWVtb3J5V2ViU3RvcmFnZSIsIlVzZXJNYW5hZ2VyIiwiQWNjZXNzVG9rZW5FdmVudHMiLCJNZXRhZGF0YVNlcnZpY2UiLCJDb3Jkb3ZhUG9wdXBOYXZpZ2F0b3IiLCJDb3Jkb3ZhSUZyYW1lTmF2aWdhdG9yIiwiQ2hlY2tTZXNzaW9uSUZyYW1lIiwiVG9rZW5SZXZvY2F0aW9uQ2xpZW50IiwiU2Vzc2lvbk1vbml0b3IiLCJHbG9iYWwiLCJVc2VyIiwibm9wTG9nZ2VyIiwiZGVidWciLCJpbmZvIiwid2FybiIsImVycm9yIiwiTk9ORSIsIkVSUk9SIiwiV0FSTiIsIklORk8iLCJERUJVRyIsImxvZ2dlciIsImxldmVsIiwiY29uc29sZSIsImFyZ3MiLCJhcHBseSIsIkFycmF5IiwiZnJvbSIsInZhbHVlIiwiRXJyb3IiLCJyZXNldCIsInNldHRpbmdzIiwiX3NldHRpbmdzIiwicmVzcG9uc2VfdHlwZSIsInNjb3BlIiwicmVkaXJlY3RfdXJpIiwiZGF0YSIsInN0YXRlIiwicHJvbXB0IiwiZGlzcGxheSIsIm1heF9hZ2UiLCJ1aV9sb2NhbGVzIiwiaWRfdG9rZW5faGludCIsImxvZ2luX2hpbnQiLCJhY3JfdmFsdWVzIiwicmVzb3VyY2UiLCJyZXF1ZXN0IiwicmVxdWVzdF91cmkiLCJleHRyYVF1ZXJ5UGFyYW1zIiwic3RhdGVTdG9yZSIsImNsaWVudF9pZCIsImF1dGhvcml0eSIsIl9tZXRhZGF0YVNlcnZpY2UiLCJnZXRBdXRob3JpemF0aW9uRW5kcG9pbnQiLCJ0aGVuIiwidXJsIiwic2lnbmluUmVxdWVzdCIsIlNpZ25pblJlcXVlc3QiLCJzaWduaW5TdGF0ZSIsIl9zdGF0ZVN0b3JlIiwic2V0IiwiaWQiLCJ0b1N0b3JhZ2VTdHJpbmciLCJyZXNwb25zZSIsIlNpZ25pblJlc3BvbnNlIiwiUHJvbWlzZSIsInJlamVjdCIsInJlbW92ZSIsInN0b3JlZFN0YXRlU3RyaW5nIiwiU2lnbmluU3RhdGUiLCJmcm9tU3RvcmFnZVN0cmluZyIsIl92YWxpZGF0b3IiLCJ2YWxpZGF0ZVNpZ25pblJlc3BvbnNlIiwicG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpIiwiZ2V0RW5kU2Vzc2lvbkVuZHBvaW50IiwiU2lnbm91dFJlcXVlc3QiLCJzaWdub3V0U3RhdGUiLCJTaWdub3V0UmVzcG9uc2UiLCJFcnJvclJlc3BvbnNlIiwicmVzb2x2ZSIsInN0YXRlS2V5IiwiU3RhdGUiLCJ2YWxpZGF0ZVNpZ25vdXRSZXNwb25zZSIsImNsZWFyU3RhbGVTdGF0ZSIsInN0YWxlU3RhdGVBZ2UiLCJ2YWxpZGF0b3IiLCJtZXRhZGF0YVNlcnZpY2UiLCJPaWRjTWV0YWRhdGFVcmxQYXRoIiwiRGVmYXVsdFJlc3BvbnNlVHlwZSIsIkRlZmF1bHRTY29wZSIsIkRlZmF1bHRTdGFsZVN0YXRlQWdlIiwiRGVmYXVsdENsb2NrU2tld0luU2Vjb25kcyIsIm1ldGFkYXRhVXJsIiwibWV0YWRhdGEiLCJzaWduaW5nS2V5cyIsImNsaWVudF9zZWNyZXQiLCJmaWx0ZXJQcm90b2NvbENsYWltcyIsImxvYWRVc2VySW5mbyIsImNsb2NrU2tldyIsIlJlc3BvbnNlVmFsaWRhdG9yQ3RvciIsIlJlc3BvbnNlVmFsaWRhdG9yIiwiTWV0YWRhdGFTZXJ2aWNlQ3RvciIsIl9hdXRob3JpdHkiLCJfbWV0YWRhdGFVcmwiLCJfbWV0YWRhdGEiLCJfc2lnbmluZ0tleXMiLCJfY2xpZW50X2lkIiwiX2NsaWVudF9zZWNyZXQiLCJfcmVzcG9uc2VfdHlwZSIsIl9zY29wZSIsIl9yZWRpcmVjdF91cmkiLCJfcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpIiwiX3Byb21wdCIsIl9kaXNwbGF5IiwiX21heF9hZ2UiLCJfdWlfbG9jYWxlcyIsIl9hY3JfdmFsdWVzIiwiX3Jlc291cmNlIiwiX2ZpbHRlclByb3RvY29sQ2xhaW1zIiwiX2xvYWRVc2VySW5mbyIsIl9zdGFsZVN0YXRlQWdlIiwiX2Nsb2NrU2tldyIsIl9leHRyYVF1ZXJ5UGFyYW1zIiwiaW5kZXhPZiIsImxlbmd0aCIsInByZWZpeCIsInN0b3JlIiwibG9jYWxTdG9yYWdlIiwiX3N0b3JlIiwiX3ByZWZpeCIsImtleSIsInNldEl0ZW0iLCJpdGVtIiwiZ2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJrZXlzIiwiaW5kZXgiLCJwdXNoIiwic3Vic3RyIiwidGltZXIiLCJzZXRJbnRlcnZhbCIsImNiIiwiZHVyYXRpb24iLCJjbGVhckludGVydmFsIiwiaGFuZGxlIiwidGVzdGluZyIsIm5ld1JlcXVlc3QiLCJsb2NhdGlvbiIsInNlc3Npb25TdG9yYWdlIiwiWE1MSHR0cFJlcXVlc3QiLCJQcm90b2NvbENsYWltcyIsIlVzZXJJbmZvU2VydmljZUN0b3IiLCJVc2VySW5mb1NlcnZpY2UiLCJqb3NlVXRpbCIsIkpvc2VVdGlsIiwiX3VzZXJJbmZvU2VydmljZSIsIl9qb3NlVXRpbCIsIl9wcm9jZXNzU2lnbmluUGFyYW1zIiwiX3ZhbGlkYXRlVG9rZW5zIiwiX3Byb2Nlc3NDbGFpbXMiLCJub25jZSIsImlkX3Rva2VuIiwiaXNPcGVuSWRDb25uZWN0IiwicHJvZmlsZSIsImFjY2Vzc190b2tlbiIsImdldENsYWltcyIsImNsYWltcyIsInN1YiIsIl9tZXJnZUNsYWltcyIsImNsYWltczEiLCJjbGFpbXMyIiwicmVzdWx0IiwiT2JqZWN0IiwiYXNzaWduIiwibmFtZSIsInZhbHVlcyIsImlzQXJyYXkiLCJpIiwiZm9yRWFjaCIsInR5cGUiLCJfdmFsaWRhdGVJZFRva2VuQW5kQWNjZXNzVG9rZW4iLCJfdmFsaWRhdGVJZFRva2VuIiwiX3ZhbGlkYXRlQWNjZXNzVG9rZW4iLCJqd3QiLCJwYXJzZUp3dCIsImhlYWRlciIsInBheWxvYWQiLCJraWQiLCJnZXRJc3N1ZXIiLCJnZXRTaWduaW5nS2V5cyIsIl9maWx0ZXJCeUFsZyIsImFsZyIsImZpbHRlciIsImF1ZGllbmNlIiwiY2xvY2tTa2V3SW5TZWNvbmRzIiwidmFsaWRhdGVKd3QiLCJpc3N1ZXIiLCJrdHkiLCJzdGFydHNXaXRoIiwiYXRfaGFzaCIsImhhc2hBbGciLCJoYXNoQml0cyIsInBhcnNlSW50Iiwic2hhIiwiaGFzaCIsImhhc2hTdHJpbmciLCJsZWZ0IiwibGVmdF9iNjR1IiwiaGV4VG9CYXNlNjRVcmwiLCJKc29uU2VydmljZUN0b3IiLCJKc29uU2VydmljZSIsIl9qc29uU2VydmljZSIsImdldEpzb24iLCJfZ2V0TWV0YWRhdGFQcm9wZXJ0eSIsIm9wdGlvbmFsIiwiZ2V0TWV0YWRhdGEiLCJ1bmRlZmluZWQiLCJqd2tzX3VyaSIsImtleVNldCIsIlhNTEh0dHBSZXF1ZXN0Q3RvciIsIl9YTUxIdHRwUmVxdWVzdCIsInRva2VuIiwicmVxIiwib3BlbiIsIm9ubG9hZCIsInN0YXR1cyIsIkpTT04iLCJwYXJzZSIsInJlc3BvbnNlVGV4dCIsImUiLCJtZXNzYWdlIiwic3RhdHVzVGV4dCIsIm9uZXJyb3IiLCJzZXRSZXF1ZXN0SGVhZGVyIiwic2VuZCIsImdldFVzZXJJbmZvRW5kcG9pbnQiLCJlcnJvcl9kZXNjcmlwdGlvbiIsImVycm9yX3VyaSIsIkFsbG93ZWRTaWduaW5nQWxncyIsInBhcmFtZXRlcnMiLCJleHBlY3RlZEFsZyIsImlkVG9rZW5WZXJpZmllciIsIklkVG9rZW5WZXJpZmllciIsImRlY29kZSIsIm5vdyIsIl92YWxpZGF0ZUp3dCIsImxlZXdheSIsIkRhdGUiLCJpc3MiLCJhdWQiLCJ2YWxpZEF1ZGllbmNlIiwibG93ZXJOb3ciLCJ1cHBlck5vdyIsImlhdCIsIm5iZiIsImV4cCIsInZlcmlmeSIsImNyeXB0byIsIlV0aWwiLCJoZXh0b2I2NHUiLCJzaGEyNTYiLCJjcnlwdG9CYXNlNjQiLCJjcnlwdG9IZXgiLCJSU0FWZXJpZmllciIsImJhc2U2NCIsImp3a3MiLCJEdW1teUNhY2hlIiwic3VwcG9ydGVkQWxncyIsIm9wdGlvbnMiLCJqd2tzQ2FjaGUiLCJfX2Rpc2FibGVFeHBpcmF0aW9uQ2hlY2siLCJqd2tzVVJJIiwiQ29uZmlndXJhdGlvbkVycm9yIiwiam9pbiIsInByb3RvdHlwZSIsImhlYWRBbmRQYXlsb2FkIiwiZW5jb2RlZCIsInNpZ25hdHVyZSIsImRlY29kZVRvSEVYIiwidG5vbmNlIiwiVG9rZW5WYWxpZGF0aW9uRXJyb3IiLCJleHBpcmF0aW9uRXJyb3IiLCJ2ZXJpZnlFeHBBbmROYmYiLCJnZXRSc2FWZXJpZmllciIsInJzYVZlcmlmaWVyIiwiY2F0Y2giLCJleHBEYXRlIiwibmJmRGF0ZSIsInNldFVUQ1NlY29uZHMiLCJ2ZXJpZnlFeHBBbmRJYXQiLCJpYXREYXRlIiwiX3RoaXMiLCJjYWNoZWtleSIsImhhcyIsImdldEpXS1MiLCJrZXlJbmZvIiwibW9kdWx1cyIsImdldCIsInBhcnRzIiwic3BsaXQiLCJkZWNvZGVUb1N0cmluZyIsInZhbGlkYXRlQWNjZXNzVG9rZW4iLCJhY2Nlc3NUb2tlbiIsImF0SGFzaCIsInNoYTI1NkFjY2Vzc1Rva2VuIiwiaGFzaFRvSGV4Iiwic3RyaW5naWZ5IiwiaGFzaFRvSGV4Rmlyc3RIYWxmIiwic3Vic3RyaW5nIiwiaGFzaEZpcnN0SGFsZldvcmRBcnJheSIsImhhc2hGaXJzdEhhbGZCYXNlNjQiLCJoYXNoRmlyc3RIYWxmQmFzZTY0U2FmZVVybCIsImJhc2U2NFRvQmFzZTY0VXJsIiwibW9kdWxlIiwiZXhwb3J0cyIsInJvb3QiLCJmYWN0b3J5IiwiZGVmaW5lIiwiQ3J5cHRvSlMiLCJNYXRoIiwiQyIsIkNfbGliIiwibGliIiwiV29yZEFycmF5IiwiSGFzaGVyIiwiQ19hbGdvIiwiYWxnbyIsIkgiLCJLIiwiaXNQcmltZSIsIm4iLCJzcXJ0TiIsInNxcnQiLCJmYWN0b3IiLCJnZXRGcmFjdGlvbmFsQml0cyIsIm5QcmltZSIsInBvdyIsIlciLCJTSEEyNTYiLCJleHRlbmQiLCJfZG9SZXNldCIsIl9oYXNoIiwiaW5pdCIsInNsaWNlIiwiX2RvUHJvY2Vzc0Jsb2NrIiwiTSIsIm9mZnNldCIsIndvcmRzIiwiYSIsImIiLCJjIiwiZCIsImYiLCJnIiwiaCIsImdhbW1hMHgiLCJnYW1tYTAiLCJnYW1tYTF4IiwiZ2FtbWExIiwiY2giLCJtYWoiLCJzaWdtYTAiLCJzaWdtYTEiLCJ0MSIsInQyIiwiX2RvRmluYWxpemUiLCJfZGF0YSIsImRhdGFXb3JkcyIsIm5CaXRzVG90YWwiLCJfbkRhdGFCeXRlcyIsIm5CaXRzTGVmdCIsInNpZ0J5dGVzIiwiZmxvb3IiLCJfcHJvY2VzcyIsImNsb25lIiwiY2FsbCIsIl9jcmVhdGVIZWxwZXIiLCJIbWFjU0hBMjU2IiwiX2NyZWF0ZUhtYWNIZWxwZXIiLCJjcmVhdGUiLCJGIiwib2JqIiwic3VidHlwZSIsIkJhc2UiLCJvdmVycmlkZXMiLCJtaXhJbiIsImhhc093blByb3BlcnR5IiwiJHN1cGVyIiwiYXJndW1lbnRzIiwiaW5zdGFuY2UiLCJwcm9wZXJ0aWVzIiwicHJvcGVydHlOYW1lIiwidG9TdHJpbmciLCJlbmNvZGVyIiwiSGV4IiwiY29uY2F0Iiwid29yZEFycmF5IiwidGhpc1dvcmRzIiwidGhhdFdvcmRzIiwidGhpc1NpZ0J5dGVzIiwidGhhdFNpZ0J5dGVzIiwiY2xhbXAiLCJ0aGF0Qnl0ZSIsImNlaWwiLCJyYW5kb20iLCJuQnl0ZXMiLCJyIiwibV93IiwibV96IiwibWFzayIsInJjYWNoZSIsIl9yIiwiQ19lbmMiLCJlbmMiLCJoZXhDaGFycyIsImJpdGUiLCJoZXhTdHIiLCJoZXhTdHJMZW5ndGgiLCJMYXRpbjEiLCJsYXRpbjFDaGFycyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImxhdGluMVN0ciIsImxhdGluMVN0ckxlbmd0aCIsImNoYXJDb2RlQXQiLCJVdGY4IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXNjYXBlIiwidXRmOFN0ciIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiQnVmZmVyZWRCbG9ja0FsZ29yaXRobSIsIl9hcHBlbmQiLCJkb0ZsdXNoIiwiZGF0YVNpZ0J5dGVzIiwiYmxvY2tTaXplIiwiYmxvY2tTaXplQnl0ZXMiLCJuQmxvY2tzUmVhZHkiLCJtYXgiLCJfbWluQnVmZmVyU2l6ZSIsIm5Xb3Jkc1JlYWR5IiwibkJ5dGVzUmVhZHkiLCJtaW4iLCJwcm9jZXNzZWRXb3JkcyIsInNwbGljZSIsImNmZyIsInVwZGF0ZSIsIm1lc3NhZ2VVcGRhdGUiLCJmaW5hbGl6ZSIsImhhc2hlciIsIkhNQUMiLCJCYXNlNjQiLCJtYXAiLCJfbWFwIiwiYmFzZTY0Q2hhcnMiLCJieXRlMSIsImJ5dGUyIiwiYnl0ZTMiLCJ0cmlwbGV0IiwiaiIsImNoYXJBdCIsInBhZGRpbmdDaGFyIiwiYmFzZTY0U3RyIiwiYmFzZTY0U3RyTGVuZ3RoIiwicmV2ZXJzZU1hcCIsIl9yZXZlcnNlTWFwIiwicGFkZGluZ0luZGV4IiwicGFyc2VMb29wIiwiYml0czEiLCJiaXRzMiIsIkJpZ0ludGVnZXIiLCJEaWdlc3RJbmZvSGVhZCIsInNoYTEiLCJzaGEyMjQiLCJzaGEzODQiLCJzaGE1MTIiLCJtZDIiLCJtZDUiLCJyaXBlbWQxNjAiLCJEaWdlc3RBbGdzIiwiZ2V0QWxnb3JpdGhtRnJvbURpZ2VzdCIsImhEaWdlc3RJbmZvIiwiYWxnTmFtZSIsImhlYWQiLCJsZW4iLCJtc2ciLCJlbmNzaWciLCJyZXBsYWNlIiwic2lnIiwiYml0TGVuZ3RoIiwiZGVjcnlwdGVkU2lnIiwibW9kUG93SW50IiwiZGlnZXN0IiwiZGlnZXN0SW5mbyIsIm1zZ0hhc2giLCJkYml0cyIsImNhbmFyeSIsImpfbG0iLCJmcm9tTnVtYmVyIiwiZnJvbVN0cmluZyIsIm5iaSIsImFtMSIsIngiLCJ3IiwidiIsImFtMiIsInhsIiwieGgiLCJsIiwibSIsImFtMyIsImluQnJvd3NlciIsIm5hdmlnYXRvciIsImFwcE5hbWUiLCJhbSIsIkRCIiwiRE0iLCJEViIsIkJJX0ZQIiwiRlYiLCJGMSIsIkYyIiwiQklfUk0iLCJCSV9SQyIsInJyIiwidnYiLCJpbnQyY2hhciIsImludEF0IiwicyIsImJucENvcHlUbyIsInQiLCJibnBGcm9tSW50IiwibmJ2IiwiZnJvbUludCIsImJucEZyb21TdHJpbmciLCJrIiwiZnJvbVJhZGl4IiwibWkiLCJzaCIsIlpFUk8iLCJzdWJUbyIsImJucENsYW1wIiwiYm5Ub1N0cmluZyIsIm5lZ2F0ZSIsInRvUmFkaXgiLCJrbSIsInAiLCJibk5lZ2F0ZSIsImJuQWJzIiwiYm5Db21wYXJlVG8iLCJuYml0cyIsImJuQml0TGVuZ3RoIiwiYm5wRExTaGlmdFRvIiwiYm5wRFJTaGlmdFRvIiwiYm5wTFNoaWZ0VG8iLCJicyIsImNicyIsImJtIiwiZHMiLCJibnBSU2hpZnRUbyIsImJucFN1YlRvIiwiYm5wTXVsdGlwbHlUbyIsImFicyIsInkiLCJibnBTcXVhcmVUbyIsImJucERpdlJlbVRvIiwicSIsInBtIiwicHQiLCJjb3B5VG8iLCJ0cyIsIm1zIiwibnNoIiwibFNoaWZ0VG8iLCJ5cyIsInkwIiwieXQiLCJkMSIsImQyIiwiZGxTaGlmdFRvIiwiY29tcGFyZVRvIiwiT05FIiwicWQiLCJkclNoaWZ0VG8iLCJyU2hpZnRUbyIsImJuTW9kIiwiZGl2UmVtVG8iLCJDbGFzc2ljIiwiY0NvbnZlcnQiLCJtb2QiLCJjUmV2ZXJ0IiwiY1JlZHVjZSIsImNNdWxUbyIsIm11bHRpcGx5VG8iLCJyZWR1Y2UiLCJjU3FyVG8iLCJzcXVhcmVUbyIsImNvbnZlcnQiLCJyZXZlcnQiLCJtdWxUbyIsInNxclRvIiwiYm5wSW52RGlnaXQiLCJNb250Z29tZXJ5IiwibXAiLCJpbnZEaWdpdCIsIm1wbCIsIm1waCIsInVtIiwibXQyIiwibW9udENvbnZlcnQiLCJtb250UmV2ZXJ0IiwibW9udFJlZHVjZSIsInUwIiwibW9udFNxclRvIiwibW9udE11bFRvIiwiYm5wSXNFdmVuIiwiYm5wRXhwIiwieiIsInIyIiwiYm5Nb2RQb3dJbnQiLCJpc0V2ZW4iLCJibkNsb25lIiwiYm5JbnRWYWx1ZSIsImJuQnl0ZVZhbHVlIiwiYm5TaG9ydFZhbHVlIiwiYm5wQ2h1bmtTaXplIiwiTE4yIiwibG9nIiwiYm5TaWdOdW0iLCJibnBUb1JhZGl4Iiwic2lnbnVtIiwiY3MiLCJjaHVua1NpemUiLCJpbnRWYWx1ZSIsImJucEZyb21SYWRpeCIsImRNdWx0aXBseSIsImRBZGRPZmZzZXQiLCJibnBGcm9tTnVtYmVyIiwidGVzdEJpdCIsImJpdHdpc2VUbyIsInNoaWZ0TGVmdCIsIm9wX29yIiwiaXNQcm9iYWJsZVByaW1lIiwibmV4dEJ5dGVzIiwiYm5Ub0J5dGVBcnJheSIsImJuRXF1YWxzIiwiYm5NaW4iLCJibk1heCIsImJucEJpdHdpc2VUbyIsIm9wIiwib3BfYW5kIiwiYm5BbmQiLCJibk9yIiwib3BfeG9yIiwiYm5Yb3IiLCJvcF9hbmRub3QiLCJibkFuZE5vdCIsImJuTm90IiwiYm5TaGlmdExlZnQiLCJiblNoaWZ0UmlnaHQiLCJsYml0IiwiYm5HZXRMb3dlc3RTZXRCaXQiLCJjYml0IiwiYm5CaXRDb3VudCIsImJuVGVzdEJpdCIsImJucENoYW5nZUJpdCIsImJuU2V0Qml0IiwiY2hhbmdlQml0IiwiYm5DbGVhckJpdCIsImJuRmxpcEJpdCIsImJucEFkZFRvIiwiYm5BZGQiLCJhZGRUbyIsImJuU3VidHJhY3QiLCJibk11bHRpcGx5IiwiYm5TcXVhcmUiLCJibkRpdmlkZSIsImJuUmVtYWluZGVyIiwiYm5EaXZpZGVBbmRSZW1haW5kZXIiLCJibnBETXVsdGlwbHkiLCJibnBEQWRkT2Zmc2V0IiwiTnVsbEV4cCIsIm5Ob3AiLCJuTXVsVG8iLCJuU3FyVG8iLCJiblBvdyIsImJucE11bHRpcGx5TG93ZXJUbyIsImJucE11bHRpcGx5VXBwZXJUbyIsIkJhcnJldHQiLCJxMyIsIm11IiwiZGl2aWRlIiwiYmFycmV0dENvbnZlcnQiLCJiYXJyZXR0UmV2ZXJ0IiwiYmFycmV0dFJlZHVjZSIsIm11bHRpcGx5VXBwZXJUbyIsIm11bHRpcGx5TG93ZXJUbyIsImJhcnJldHRTcXJUbyIsImJhcnJldHRNdWxUbyIsImJuTW9kUG93IiwiazEiLCJnMiIsImlzMSIsImJuR0NEIiwiZ2V0TG93ZXN0U2V0Qml0IiwiYm5wTW9kSW50IiwiYm5Nb2RJbnZlcnNlIiwiYWMiLCJ1Iiwic3VidHJhY3QiLCJhZGQiLCJsb3dwcmltZXMiLCJscGxpbSIsImJuSXNQcm9iYWJsZVByaW1lIiwibW9kSW50IiwibWlsbGVyUmFiaW4iLCJibnBNaWxsZXJSYWJpbiIsIm4xIiwic2hpZnRSaWdodCIsIm1vZFBvdyIsImJ5dGVWYWx1ZSIsInNob3J0VmFsdWUiLCJ0b0J5dGVBcnJheSIsImVxdWFscyIsImFuZCIsIm9yIiwieG9yIiwiYW5kTm90Iiwibm90IiwiYml0Q291bnQiLCJzZXRCaXQiLCJjbGVhckJpdCIsImZsaXBCaXQiLCJtdWx0aXBseSIsInJlbWFpbmRlciIsImRpdmlkZUFuZFJlbWFpbmRlciIsIm1vZEludmVyc2UiLCJnY2QiLCJzcXVhcmUiLCJybmdfc3RhdGUiLCJybmdfcG9vbCIsInJuZ19wcHRyIiwicm5nX3NlZWRfaW50Iiwicm5nX3BzaXplIiwicm5nX3NlZWRfdGltZSIsImdldFRpbWUiLCJ3aW5kb3ciLCJnZXRSYW5kb21WYWx1ZXMiLCJ1YSIsIlVpbnQ4QXJyYXkiLCJhcHBWZXJzaW9uIiwicm5nX2dldF9ieXRlIiwicHJuZ19uZXdzdGF0ZSIsIm5leHQiLCJybmdfZ2V0X2J5dGVzIiwiYmEiLCJTZWN1cmVSYW5kb20iLCJBcmNmb3VyIiwiUyIsIkFSQzRpbml0IiwiQVJDNG5leHQiLCJwYWRkaW5nIiwic3RyIiwicGFkIiwiYnl0ZUFycmF5VG9TdHJpbmciLCJhcnJheSIsInN0cmluZ1RvQnl0ZUFycmF5IiwiYXJyIiwiYnl0ZUFycmF5VG9IZXgiLCJyYXciLCJIRVgiLCJfaGV4IiwiZW5jb2RlU3RyaW5nIiwiZnJvbUJ5dGVBcnJheSIsIm1hdGNoIiwicDEiLCJiYXNlNjRTdHJpbmciLCJTQUZFX1VSTF9FTkNPRElOR19NQVBQSU5HIiwiYnl0ZUxlbmd0aCIsImxvb2t1cCIsInJldkxvb2t1cCIsIkFyciIsImNvZGUiLCJwbGFjZUhvbGRlcnNDb3VudCIsImI2NCIsInRtcCIsInBsYWNlSG9sZGVycyIsIkwiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4Iiwic3RhcnQiLCJlbmQiLCJvdXRwdXQiLCJleHRyYUJ5dGVzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwidXJsam9pbiIsInByb2Nlc3MiLCJlcnIiLCJtYXRjaGluZ0tleSIsImJvZHkiLCJjb250ZXh0IiwiZGVmaW5pdGlvbiIsIm5vcm1hbGl6ZSIsImlucHV0Iiwiam9pbmVkIiwic2VsZiIsIkVtaXR0ZXIiLCJSZXF1ZXN0QmFzZSIsImlzT2JqZWN0IiwiUmVzcG9uc2VCYXNlIiwiQWdlbnQiLCJub29wIiwibWV0aG9kIiwiUmVxdWVzdCIsImdldFhIUiIsInByb3RvY29sIiwiQWN0aXZlWE9iamVjdCIsInRyaW0iLCJzZXJpYWxpemUiLCJwYWlycyIsInB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyIiwidmFsIiwic3Via2V5Iiwic2VyaWFsaXplT2JqZWN0IiwicGFyc2VTdHJpbmciLCJwYWlyIiwicG9zIiwidHlwZXMiLCJodG1sIiwianNvbiIsInhtbCIsInVybGVuY29kZWQiLCJwYXJzZUhlYWRlciIsImxpbmVzIiwiZmllbGRzIiwibGluZSIsImZpZWxkIiwidG9Mb3dlckNhc2UiLCJpc0pTT04iLCJtaW1lIiwidGVzdCIsIlJlc3BvbnNlIiwieGhyIiwidGV4dCIsInJlc3BvbnNlVHlwZSIsIl9zZXRTdGF0dXNQcm9wZXJ0aWVzIiwiaGVhZGVycyIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsImdldFJlc3BvbnNlSGVhZGVyIiwiX3NldEhlYWRlclByb3BlcnRpZXMiLCJfcmVzcG9uc2VUeXBlIiwiX3BhcnNlQm9keSIsIl9wYXJzZXIiLCJ0b0Vycm9yIiwiX3F1ZXJ5IiwiX2hlYWRlciIsIm9uIiwicmVzIiwib3JpZ2luYWwiLCJyYXdSZXNwb25zZSIsInN0YXR1c0NvZGUiLCJjYWxsYmFjayIsImVtaXQiLCJuZXdfZXJyIiwiX2lzUmVzcG9uc2VPSyIsImN1c3RvbV9lcnIiLCJhY2NlcHQiLCJhdXRoIiwidXNlciIsInBhc3MiLCJidG9hIiwic3RyaW5nIiwiX2F1dGgiLCJxdWVyeSIsImF0dGFjaCIsImZpbGUiLCJfZ2V0Rm9ybURhdGEiLCJhcHBlbmQiLCJfZm9ybURhdGEiLCJGb3JtRGF0YSIsIl9zaG91bGRSZXRyeSIsIl9yZXRyeSIsImZuIiwiX2NhbGxiYWNrIiwiY2xlYXJUaW1lb3V0IiwiX21heFJldHJpZXMiLCJyZXRyaWVzIiwiX3JldHJpZXMiLCJjcm9zc0RvbWFpbkVycm9yIiwiY3Jvc3NEb21haW4iLCJidWZmZXIiLCJjYSIsImFnZW50IiwicGlwZSIsIndyaXRlIiwiX2lzSG9zdCIsIl9lbmRDYWxsZWQiLCJfZmluYWxpemVRdWVyeVN0cmluZyIsIl9lbmQiLCJfc2V0VGltZW91dHMiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwiX3Jlc3BvbnNlVGltZW91dFRpbWVyIiwidGltZWRvdXQiLCJfYWJvcnRlZCIsImhhbmRsZVByb2dyZXNzIiwiZGlyZWN0aW9uIiwidG90YWwiLCJwZXJjZW50IiwibG9hZGVkIiwiaGFzTGlzdGVuZXJzIiwib25wcm9ncmVzcyIsImJpbmQiLCJ1cGxvYWQiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiX3dpdGhDcmVkZW50aWFscyIsIndpdGhDcmVkZW50aWFscyIsImNvbnRlbnRUeXBlIiwiX3NlcmlhbGl6ZXIiLCJfc2V0RGVmYXVsdHMiLCJkZWwiLCJwYXRjaCIsInBvc3QiLCJwdXQiLCJtaXhpbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsIl9jYWxsYmFja3MiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FsbGJhY2tzIiwibGlzdGVuZXJzIiwiX2NsZWFyVGltZW91dCIsIl90aW1lciIsInRpbWVvdXQiLCJfdGltZW91dCIsIl9yZXNwb25zZVRpbWVvdXQiLCJvcHRpb24iLCJkZWFkbGluZSIsInJldHJ5IiwiY291bnQiLCJfcmV0cnlDYWxsYmFjayIsIkVSUk9SX0NPREVTIiwib3ZlcnJpZGUiLCJfZnVsbGZpbGxlZFByb21pc2UiLCJpbm5lclJlc29sdmUiLCJpbm5lclJlamVjdCIsInVzZSIsIm9rIiwiX29rQ2FsbGJhY2siLCJnZXRIZWFkZXIiLCJ1bnNldCIsImFib3J0IiwiYmFzZTY0RW5jb2RlciIsInJlZGlyZWN0cyIsIl9tYXhSZWRpcmVjdHMiLCJtYXhSZXNwb25zZVNpemUiLCJUeXBlRXJyb3IiLCJfbWF4UmVzcG9uc2VTaXplIiwidG9KU09OIiwiaXNPYmoiLCJzb3J0UXVlcnkiLCJzb3J0IiwiX3NvcnQiLCJxdWVyeUFyciIsIl9hcHBlbmRRdWVyeVN0cmluZyIsInRyYWNlIiwiX3RpbWVvdXRFcnJvciIsInJlYXNvbiIsImVycm5vIiwic2V0VGltZW91dCIsInV0aWxzIiwiY3QiLCJwYXJhbXMiLCJsaW5rcyIsImxpbmsiLCJwYXJzZUxpbmtzIiwic3RhdHVzVHlwZSIsInJlZGlyZWN0IiwiY2xpZW50RXJyb3IiLCJzZXJ2ZXJFcnJvciIsImFjY2VwdGVkIiwibm9Db250ZW50IiwiYmFkUmVxdWVzdCIsInVuYXV0aG9yaXplZCIsIm5vdEFjY2VwdGFibGUiLCJmb3JiaWRkZW4iLCJub3RGb3VuZCIsInNoaWZ0IiwicmVsIiwiY2xlYW5IZWFkZXIiLCJjaGFuZ2VzT3JpZ2luIiwiX2RlZmF1bHRzIiwiZGVmIiwib2lkYyIsImlzT2lkYyIsIlVybFV0aWxpdHkiLCJhZGRRdWVyeVBhcmFtIiwiZGVsaW1pdGVyIiwiZ2xvYmFsIiwiaHJlZiIsImlkeCIsImxhc3RJbmRleE9mIiwicmVnZXgiLCJjb3VudGVyIiwiZXhlYyIsInByb3AiLCJfbm9uY2UiLCJjcmVhdGVkIiwic3RvcmFnZVN0cmluZyIsIl9pZCIsIl9jcmVhdGVkIiwic3RvcmFnZSIsImFnZSIsImN1dG9mZiIsImdldEFsbEtleXMiLCJwcm9taXNlcyIsImFsbCIsImd1aWRIb2xkZXIiLCJoZXgiLCJndWlkUmVzcG9uc2UiLCJPaWRjU2NvcGUiLCJwYXJzZVVybEZyYWdtZW50Iiwic2Vzc2lvbl9zdGF0ZSIsInRva2VuX3R5cGUiLCJleHBpcmVzX2luIiwiZXhwaXJlc19hdCIsInNjb3BlcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJTaWxlbnRSZW5ld1NlcnZpY2VDdG9yIiwiU2lsZW50UmVuZXdTZXJ2aWNlIiwiU2Vzc2lvbk1vbml0b3JDdG9yIiwiVG9rZW5SZXZvY2F0aW9uQ2xpZW50Q3RvciIsIlVzZXJNYW5hZ2VyU2V0dGluZ3MiLCJfZXZlbnRzIiwiVXNlck1hbmFnZXJFdmVudHMiLCJfc2lsZW50UmVuZXdTZXJ2aWNlIiwiYXV0b21hdGljU2lsZW50UmVuZXciLCJzdGFydFNpbGVudFJlbmV3IiwibW9uaXRvclNlc3Npb24iLCJfc2Vzc2lvbk1vbml0b3IiLCJfdG9rZW5SZXZvY2F0aW9uQ2xpZW50IiwiX2xvYWRVc2VyIiwibG9hZCIsInN0b3JlVXNlciIsInVubG9hZCIsIl9zaWduaW5TdGFydCIsIl9yZWRpcmVjdE5hdmlnYXRvciIsIl9zaWduaW5FbmQiLCJwb3B1cF9yZWRpcmVjdF91cmkiLCJfc2lnbmluIiwiX3BvcHVwTmF2aWdhdG9yIiwic3RhcnRVcmwiLCJwb3B1cFdpbmRvd0ZlYXR1cmVzIiwicG9wdXBXaW5kb3dUYXJnZXQiLCJfc2lnbmluQ2FsbGJhY2siLCJzaWxlbnRfcmVkaXJlY3RfdXJpIiwic2V0SWRUb2tlbiIsImluY2x1ZGVJZFRva2VuSW5TaWxlbnRSZW5ldyIsIl9pZnJhbWVOYXZpZ2F0b3IiLCJzaWxlbnRSZXF1ZXN0VGltZW91dCIsInByb2Nlc3NTaWduaW5SZXNwb25zZSIsIm5hdlJlc3BvbnNlIiwic2lnbmluUmVzcG9uc2UiLCJzaWQiLCJuYXZpZ2F0b3JQYXJhbXMiLCJwcmVwYXJlIiwiY3JlYXRlU2lnbmluUmVxdWVzdCIsIm5hdmlnYXRlIiwiY2xvc2UiLCJwb3N0TG9nb3V0UmVkaXJlY3RVcmkiLCJfc2lnbm91dFN0YXJ0IiwiX3NpZ25vdXRFbmQiLCJwb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmkiLCJfc2lnbm91dCIsImtlZXBPcGVuIiwicmV2b2tlUHJvbWlzZSIsInJldm9rZUFjY2Vzc1Rva2VuT25TaWdub3V0IiwiX3Jldm9rZUludGVybmFsIiwicmVtb3ZlVXNlciIsImNyZWF0ZVNpZ25vdXRSZXF1ZXN0Iiwic2lnbm91dFJlcXVlc3QiLCJwcm9jZXNzU2lnbm91dFJlc3BvbnNlIiwic2lnbm91dFJlc3BvbnNlIiwic3VjY2VzcyIsInJlcXVpcmVkIiwicmV2b2tlIiwic3RvcCIsIl91c2VyU3RvcmUiLCJfdXNlclN0b3JlS2V5IiwicmVkaXJlY3ROYXZpZ2F0b3IiLCJwb3B1cE5hdmlnYXRvciIsImlmcmFtZU5hdmlnYXRvciIsInVzZXJTdG9yZSIsIkRlZmF1bHRBY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZSIsIkRlZmF1bHRDaGVja1Nlc3Npb25JbnRlcnZhbCIsImNoZWNrU2Vzc2lvbkludGVydmFsIiwiYWNjZXNzVG9rZW5FeHBpcmluZ05vdGlmaWNhdGlvblRpbWUiLCJSZWRpcmVjdE5hdmlnYXRvciIsIlBvcHVwTmF2aWdhdG9yIiwiSUZyYW1lTmF2aWdhdG9yIiwiX3BvcHVwX3JlZGlyZWN0X3VyaSIsIl9wb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmkiLCJfcG9wdXBXaW5kb3dGZWF0dXJlcyIsIl9wb3B1cFdpbmRvd1RhcmdldCIsIl9zaWxlbnRfcmVkaXJlY3RfdXJpIiwiX3NpbGVudFJlcXVlc3RUaW1lb3V0IiwiX2F1dG9tYXRpY1NpbGVudFJlbmV3IiwiX2luY2x1ZGVJZFRva2VuSW5TaWxlbnRSZW5ldyIsIl9hY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZSIsIl9tb25pdG9yU2Vzc2lvbiIsIl9jaGVja1Nlc3Npb25JbnRlcnZhbCIsIl9yZXZva2VBY2Nlc3NUb2tlbk9uU2lnbm91dCIsInBvcHVwIiwiUG9wdXBXaW5kb3ciLCJub3RpZnlPcGVuZXIiLCJDaGVja0ZvclBvcHVwQ2xvc2VkSW50ZXJ2YWwiLCJEZWZhdWx0UG9wdXBGZWF0dXJlcyIsIkRlZmF1bHRQb3B1cFRhcmdldCIsIl9wcm9taXNlIiwiX3Jlc29sdmUiLCJfcmVqZWN0IiwidGFyZ2V0IiwiZmVhdHVyZXMiLCJfcG9wdXAiLCJfY2hlY2tGb3JQb3B1cENsb3NlZFRpbWVyIiwiX2NoZWNrRm9yUG9wdXBDbG9zZWQiLCJfZXJyb3IiLCJmb2N1cyIsInByb21pc2UiLCJfY2xlYW51cCIsImNsb3NlZCIsIl9zdWNjZXNzIiwib3BlbmVyIiwiZnJhbWUiLCJJRnJhbWVXaW5kb3ciLCJub3RpZnlQYXJlbnQiLCJEZWZhdWx0VGltZW91dCIsIl9ib3VuZE1lc3NhZ2VFdmVudCIsIl9tZXNzYWdlIiwiX2ZyYW1lIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJ2aXNpYmlsaXR5IiwicG9zaXRpb24iLCJ3aWR0aCIsImhlaWdodCIsImFwcGVuZENoaWxkIiwic3JjIiwicmVtb3ZlQ2hpbGQiLCJvcmlnaW4iLCJfb3JpZ2luIiwic291cmNlIiwiY29udGVudFdpbmRvdyIsImhvc3QiLCJwYXJlbnQiLCJwb3N0TWVzc2FnZSIsIl91c2VyTG9hZGVkIiwiRXZlbnQiLCJfdXNlclVubG9hZGVkIiwiX3NpbGVudFJlbmV3RXJyb3IiLCJfdXNlclNpZ25lZE91dCIsIl91c2VyU2Vzc2lvbkNoYW5nZWQiLCJyYWlzZUV2ZW50IiwicmFpc2UiLCJhZGRIYW5kbGVyIiwicmVtb3ZlSGFuZGxlciIsImFjY2Vzc1Rva2VuRXhwaXJpbmdUaW1lciIsIlRpbWVyIiwiYWNjZXNzVG9rZW5FeHBpcmVkVGltZXIiLCJfYWNjZXNzVG9rZW5FeHBpcmluZyIsIl9hY2Nlc3NUb2tlbkV4cGlyZWQiLCJjb250YWluZXIiLCJfY2FuY2VsVGltZXJzIiwiZXhwaXJpbmciLCJleHBpcmVkIiwiY2FuY2VsIiwiVGltZXJEdXJhdGlvbiIsIl9ub3dGdW5jIiwiX25hbWUiLCJfZXhwaXJhdGlvbiIsInRpbWVyRHVyYXRpb24iLCJfdGltZXJIYW5kbGUiLCJkaWZmIiwiZmluZEluZGV4IiwidXNlck1hbmFnZXIiLCJfdXNlck1hbmFnZXIiLCJfdG9rZW5FeHBpcmluZyIsImV2ZW50cyIsImFkZEFjY2Vzc1Rva2VuRXhwaXJpbmciLCJnZXRVc2VyIiwicmVtb3ZlQWNjZXNzVG9rZW5FeHBpcmluZyIsInNpZ25pblNpbGVudCIsIl9yYWlzZVNpbGVudFJlbmV3RXJyb3IiLCJDaGVja1Nlc3Npb25JRnJhbWVDdG9yIiwiX0NoZWNrU2Vzc2lvbklGcmFtZUN0b3IiLCJhZGRVc2VyTG9hZGVkIiwiX3N0YXJ0IiwiYWRkVXNlclVubG9hZGVkIiwiX3N0b3AiLCJfc3ViIiwiX3NpZCIsIl9jaGVja1Nlc3Npb25JRnJhbWUiLCJnZXRDaGVja1Nlc3Npb25JZnJhbWUiLCJpbnRlcnZhbCIsInF1ZXJ5U2Vzc2lvblN0YXR1cyIsInJhaXNlVXNlclNpZ25lZE91dEV2ZW50Iiwic2Vzc2lvbiIsIl9yYWlzZVVzZXJTZXNzaW9uQ2hhbmdlZCIsIl9yYWlzZVVzZXJTaWduZWRPdXQiLCJEZWZhdWx0SW50ZXJ2YWwiLCJfdXJsIiwiX2ludGVydmFsIiwiX2ZyYW1lX29yaWdpbiIsIl9zZXNzaW9uX3N0YXRlIiwiQWNjZXNzVG9rZW5UeXBlSGludCIsIl9YTUxIdHRwUmVxdWVzdEN0b3IiLCJnZXRSZXZvY2F0aW9uRW5kcG9pbnQiLCJfcmV2b2tlIiwiQ29yZG92YVBvcHVwV2luZG93IiwiY29yZG92YU1ldGFkYXRhIiwic29tZSIsImNvcmRvdmEiLCJfaXNJbkFwcEJyb3dzZXJJbnN0YWxsZWQiLCJJbkFwcEJyb3dzZXIiLCJfZXhpdENhbGxiYWNrRXZlbnQiLCJfZXhpdENhbGxiYWNrIiwiX2xvYWRTdGFydENhbGxiYWNrRXZlbnQiLCJfbG9hZFN0YXJ0Q2FsbGJhY2siXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7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TyxHQUFoTyxFQUFvTyxHQUFwTyxFQUF3TyxHQUF4TyxFQUE0TyxHQUE1TyxFQUFnUCxHQUFoUCxFQUFvUCxHQUFwUCxFQUF3UCxHQUF4UCxFQUE0UCxHQUE1UCxFQUFnUSxHQUFoUSxFQUFvUSxHQUFwUSxFQUF3USxHQUF4USxFQUE0USxHQUE1USxFQUFnUixHQUFoUixFQUFvUixHQUFwUixFQUF3UixHQUF4UixFQUE0UixHQUE1UixFQUFnUyxHQUFoUyxFQUFvUyxHQUFwUyxFQUF3UyxHQUF4UyxFQUE0UyxHQUE1UyxFQUFnVCxHQUFoVCxFQUFvVCxHQUFwVCxFQUF3VCxHQUF4VCxFQUE0VCxHQUE1VCxFQUFnVSxHQUFoVSxFQUFvVSxHQUFwVSxFQUF3VSxHQUF4VSxFQUE0VSxHQUE1VSxFQUFnVixHQUFoVixFQUFvVixHQUFwVixFQUF3VixHQUF4VixFQUE0VixHQUE1VixFQUFnVyxHQUFoVyxFQUFvVyxHQUFwVyxFQUF3VyxHQUF4VyxFQUE0VyxHQUE1VyxFQUFnWCxHQUFoWCxFQUFvWCxHQUFwWCxFQUF3WCxHQUF4WCxFQUE0WCxHQUE1WCxFQUFnWSxHQUFoWSxFQUFvWSxHQUFwWSxFQUF3WSxHQUF4WSxFQUE0WSxHQUE1WSxFQUFnWixHQUFoWixFQUFvWixHQUFwWixFQUF3WixHQUF4WixFQUE0WixHQUE1WixFQUFnYSxHQUFoYSxFQUFvYSxHQUFwYSxFQUF3YSxHQUF4YSxFQUE0YSxHQUE1YSxFQUFnYixHQUFoYixFQUFvYixHQUFwYixFQUF3YixHQUF4YixFQUE0YixHQUE1YixFQUFnYyxHQUFoYyxFQUFvYyxHQUFwYyxFQUF3YyxHQUF4YyxFQUE0YyxHQUE1YyxFQUFnZCxHQUFoZCxFQUFvZCxHQUFwZCxFQUF3ZCxHQUF4ZCxFQUE0ZCxHQUE1ZCxFQUFnZSxHQUFoZSxFQUFvZSxHQUFwZSxFQUF3ZSxHQUF4ZSxFQUE0ZSxHQUE1ZSxFQUFnZixHQUFoZixFQUFvZixHQUFwZixFQUF3ZixHQUF4ZixFQUE0ZixHQUE1ZixFQUFnZ0IsR0FBaGdCLEVBQW9nQixHQUFwZ0IsRUFBd2dCLEdBQXhn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LGtCOzs7Ozs7Ozs7Ozs7c2pCQ1JyQjtBQUNBOztBQUVBOzs7O0FBQ0E7Ozs7Ozs7O0tBRXFCdHNDLHNCOzs7Ozs7O2lDQUVUKzhCLE0sRUFBUTtBQUNaQSxvQkFBT2dGLG1CQUFQLEdBQTZCLFlBQTdCO0FBQ0EsaUJBQUk0RCxRQUFRLElBQUkyRyw0QkFBSixDQUF1QnZQLE1BQXZCLENBQVo7QUFDQSxvQkFBT241QixRQUFRYyxPQUFSLENBQWdCaWhDLEtBQWhCLENBQVA7QUFDSDs7Ozs7O21CQU5nQjNsQyxzQiIsImZpbGUiOiJvaWRjLWNsaWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNWE1ZDUyNmI1OWY1YzU3ZmJhYjMiLCIvLyBDb3B5cmlnaHQgKGMpIEJyb2NrIEFsbGVuICYgRG9taW5pY2sgQmFpZXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTElDRU5TRSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG5leHBvcnQgY29uc3QgTG9nID0gcmVxdWlyZSgnLi9zcmMvTG9nJykuZGVmYXVsdDtcbmV4cG9ydCBjb25zdCBPaWRjQ2xpZW50ID0gcmVxdWlyZSgnLi9zcmMvT2lkY0NsaWVudCcpLmRlZmF1bHQ7XG5leHBvcnQgY29uc3QgT2lkY0NsaWVudFNldHRpbmdzID0gcmVxdWlyZSgnLi9zcmMvT2lkY0NsaWVudFNldHRpbmdzJykuZGVmYXVsdDtcbmV4cG9ydCBjb25zdCBXZWJTdG9yYWdlU3RhdGVTdG9yZSA9IHJlcXVpcmUoJy4vc3JjL1dlYlN0b3JhZ2VTdGF0ZVN0b3JlJykuZGVmYXVsdDtcbmV4cG9ydCBjb25zdCBJbk1lbW9yeVdlYlN0b3JhZ2UgPSByZXF1aXJlKCcuL3NyYy9Jbk1lbW9yeVdlYlN0b3JhZ2UnKS5kZWZhdWx0O1xuZXhwb3J0IGNvbnN0IFVzZXJNYW5hZ2VyID0gcmVxdWlyZSgnLi9zcmMvVXNlck1hbmFnZXInKS5kZWZhdWx0O1xuZXhwb3J0IGNvbnN0IEFjY2Vzc1Rva2VuRXZlbnRzID0gcmVxdWlyZSgnLi9zcmMvQWNjZXNzVG9rZW5FdmVudHMnKS5kZWZhdWx0O1xuZXhwb3J0IGNvbnN0IE1ldGFkYXRhU2VydmljZSA9IHJlcXVpcmUoJy4vc3JjL01ldGFkYXRhU2VydmljZScpLmRlZmF1bHQ7XG5leHBvcnQgY29uc3QgQ29yZG92YVBvcHVwTmF2aWdhdG9yID0gcmVxdWlyZSgnLi9zcmMvQ29yZG92YVBvcHVwTmF2aWdhdG9yJykuZGVmYXVsdDtcbmV4cG9ydCBjb25zdCBDb3Jkb3ZhSUZyYW1lTmF2aWdhdG9yID0gcmVxdWlyZSgnLi9zcmMvQ29yZG92YUlGcmFtZU5hdmlnYXRvcicpLmRlZmF1bHQ7XG5leHBvcnQgY29uc3QgQ2hlY2tTZXNzaW9uSUZyYW1lID0gcmVxdWlyZSgnLi9zcmMvQ2hlY2tTZXNzaW9uSUZyYW1lJykuZGVmYXVsdDtcbmV4cG9ydCBjb25zdCBUb2tlblJldm9jYXRpb25DbGllbnQgPSByZXF1aXJlKCcuL3NyYy9Ub2tlblJldm9jYXRpb25DbGllbnQnKS5kZWZhdWx0O1xuZXhwb3J0IGNvbnN0IFNlc3Npb25Nb25pdG9yID0gcmVxdWlyZSgnLi9zcmMvU2Vzc2lvbk1vbml0b3InKS5kZWZhdWx0O1xuZXhwb3J0IGNvbnN0IEdsb2JhbCA9IHJlcXVpcmUoJy4vc3JjL0dsb2JhbCcpLmRlZmF1bHQ7XG5leHBvcnQgY29uc3QgVXNlciA9IHJlcXVpcmUoJy4vc3JjL1VzZXInKS5kZWZhdWx0O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgTG9nLFxuICAgIE9pZGNDbGllbnQsXG4gICAgT2lkY0NsaWVudFNldHRpbmdzLFxuICAgIFdlYlN0b3JhZ2VTdGF0ZVN0b3JlLFxuICAgIEluTWVtb3J5V2ViU3RvcmFnZSxcbiAgICBVc2VyTWFuYWdlcixcbiAgICBBY2Nlc3NUb2tlbkV2ZW50cyxcbiAgICBNZXRhZGF0YVNlcnZpY2UsXG4gICAgQ29yZG92YVBvcHVwTmF2aWdhdG9yLFxuICAgIENvcmRvdmFJRnJhbWVOYXZpZ2F0b3IsXG4gICAgQ2hlY2tTZXNzaW9uSUZyYW1lLFxuICAgIFRva2VuUmV2b2NhdGlvbkNsaWVudCxcbiAgICBTZXNzaW9uTW9uaXRvcixcbiAgICBHbG9iYWwsXG4gICAgVXNlclxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2luZGV4LmpzIiwiLy8gQ29weXJpZ2h0IChjKSBCcm9jayBBbGxlbiAmIERvbWluaWNrIEJhaWVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxubGV0IG5vcExvZ2dlciA9IHtcbiAgICBkZWJ1Zygpe30sXG4gICAgaW5mbygpe30sXG4gICAgd2Fybigpe30sXG4gICAgZXJyb3IoKXt9XG59O1xuXG5jb25zdCBOT05FID0gMDtcbmNvbnN0IEVSUk9SID0gMTtcbmNvbnN0IFdBUk4gPSAyO1xuY29uc3QgSU5GTyA9IDM7XG5jb25zdCBERUJVRyA9IDQ7XG5cbmxldCBsb2dnZXI7XG5sZXQgbGV2ZWw7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvZyB7XG4gICAgc3RhdGljIGdldCBOT05FKCkge3JldHVybiBOT05FfTtcbiAgICBzdGF0aWMgZ2V0IEVSUk9SKCkge3JldHVybiBFUlJPUn07XG4gICAgc3RhdGljIGdldCBXQVJOKCkge3JldHVybiBXQVJOfTtcbiAgICBzdGF0aWMgZ2V0IElORk8oKSB7cmV0dXJuIElORk99O1xuICAgIHN0YXRpYyBnZXQgREVCVUcoKSB7cmV0dXJuIERFQlVHfTtcbiAgICBcbiAgICBzdGF0aWMgcmVzZXQoKXtcbiAgICAgICAgbGV2ZWwgPSBERUJVRztcbiAgICAgICAgbG9nZ2VyID0gY29uc29sZTtcbiAgICB9XG4gICAgXG4gICAgc3RhdGljIGdldCBsZXZlbCgpe1xuICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgfVxuICAgIHN0YXRpYyBzZXQgbGV2ZWwodmFsdWUpe1xuICAgICAgICBpZiAoTk9ORSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBERUJVRyl7XG4gICAgICAgICAgICBsZXZlbCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsb2cgbGV2ZWxcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgc3RhdGljIGdldCBsb2dnZXIoKXtcbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9XG4gICAgc3RhdGljIHNldCBsb2dnZXIodmFsdWUpe1xuICAgICAgICBpZiAoIXZhbHVlLmRlYnVnICYmIHZhbHVlLmluZm8pIHtcbiAgICAgICAgICAgIC8vIGp1c3QgdG8gc3RheSBiYWNrd2FyZHMgY29tcGF0LiBjYW4gcmVtb3ZlIGluIDIuMFxuICAgICAgICAgICAgdmFsdWUuZGVidWcgPSB2YWx1ZS5pbmZvO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmRlYnVnICYmIHZhbHVlLmluZm8gJiYgdmFsdWUud2FybiAmJiB2YWx1ZS5lcnJvcil7XG4gICAgICAgICAgICBsb2dnZXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbG9nZ2VyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHN0YXRpYyBkZWJ1ZyguLi5hcmdzKXtcbiAgICAgICAgaWYgKGxldmVsID49IERFQlVHKXtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zy5hcHBseShsb2dnZXIsIEFycmF5LmZyb20oYXJncykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBpbmZvKC4uLmFyZ3Mpe1xuICAgICAgICBpZiAobGV2ZWwgPj0gSU5GTyl7XG4gICAgICAgICAgICBsb2dnZXIuaW5mby5hcHBseShsb2dnZXIsIEFycmF5LmZyb20oYXJncykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB3YXJuKC4uLmFyZ3Mpe1xuICAgICAgICBpZiAobGV2ZWwgPj0gV0FSTil7XG4gICAgICAgICAgICBsb2dnZXIud2Fybi5hcHBseShsb2dnZXIsIEFycmF5LmZyb20oYXJncykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBlcnJvciguLi5hcmdzKXtcbiAgICAgICAgaWYgKGxldmVsID49IEVSUk9SKXtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvci5hcHBseShsb2dnZXIsIEFycmF5LmZyb20oYXJncykpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5Mb2cucmVzZXQoKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvTG9nLmpzIiwiLy8gQ29weXJpZ2h0IChjKSBCcm9jayBBbGxlbiAmIERvbWluaWNrIEJhaWVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuaW1wb3J0IExvZyBmcm9tICcuL0xvZyc7XG5pbXBvcnQgT2lkY0NsaWVudFNldHRpbmdzIGZyb20gJy4vT2lkY0NsaWVudFNldHRpbmdzJztcbmltcG9ydCBFcnJvclJlc3BvbnNlIGZyb20gJy4vRXJyb3JSZXNwb25zZSc7XG5pbXBvcnQgU2lnbmluUmVxdWVzdCBmcm9tICcuL1NpZ25pblJlcXVlc3QnO1xuaW1wb3J0IFNpZ25pblJlc3BvbnNlIGZyb20gJy4vU2lnbmluUmVzcG9uc2UnO1xuaW1wb3J0IFNpZ25vdXRSZXF1ZXN0IGZyb20gJy4vU2lnbm91dFJlcXVlc3QnO1xuaW1wb3J0IFNpZ25vdXRSZXNwb25zZSBmcm9tICcuL1NpZ25vdXRSZXNwb25zZSc7XG5pbXBvcnQgU2lnbmluU3RhdGUgZnJvbSAnLi9TaWduaW5TdGF0ZSc7XG5pbXBvcnQgU3RhdGUgZnJvbSAnLi9TdGF0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9pZGNDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzID0ge30pIHtcbiAgICAgICAgaWYgKHNldHRpbmdzIGluc3RhbmNlb2YgT2lkY0NsaWVudFNldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBuZXcgT2lkY0NsaWVudFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBfc3RhdGVTdG9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3Muc3RhdGVTdG9yZTtcbiAgICB9XG4gICAgZ2V0IF92YWxpZGF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnZhbGlkYXRvcjtcbiAgICB9XG4gICAgZ2V0IF9tZXRhZGF0YVNlcnZpY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLm1ldGFkYXRhU2VydmljZTtcbiAgICB9XG5cbiAgICBnZXQgc2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncztcbiAgICB9XG4gICAgZ2V0IG1ldGFkYXRhU2VydmljZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhU2VydmljZTtcbiAgICB9XG5cbiAgICBjcmVhdGVTaWduaW5SZXF1ZXN0KHtcbiAgICAgICAgcmVzcG9uc2VfdHlwZSwgc2NvcGUsIHJlZGlyZWN0X3VyaSwgXG4gICAgICAgIC8vIGRhdGEgd2FzIG1lYW50IHRvIGJlIHRoZSBwbGFjZSBhIGNhbGxlciBjb3VsZCBpbmRpY2F0ZSB0aGUgZGF0YSB0b1xuICAgICAgICAvLyBoYXZlIHJvdW5kIHRyaXBwZWQsIGJ1dCBwZW9wbGUgd2VyZSBnZXR0aW5nIGNvbmZ1c2VkLCBzbyBpIGFkZGVkIHN0YXRlIChzaW5jZSB0aGF0IG1hdGNoZXMgdGhlIHNwZWMpIFxuICAgICAgICAvLyBhbmQgc28gbm93IGlmIGRhdGEgaXMgbm90IHBhc3NlZCwgYnV0IHN0YXRlIGlzIHRoZW4gc3RhdGUgd2lsbCBiZSB1c2VkXG4gICAgICAgIGRhdGEsIHN0YXRlLCBwcm9tcHQsIGRpc3BsYXksIG1heF9hZ2UsIHVpX2xvY2FsZXMsIGlkX3Rva2VuX2hpbnQsIGxvZ2luX2hpbnQsIGFjcl92YWx1ZXMsXG4gICAgICAgIHJlc291cmNlLCByZXF1ZXN0LCByZXF1ZXN0X3VyaSwgZXh0cmFRdWVyeVBhcmFtcyB9ID0ge30sXG4gICAgICAgIHN0YXRlU3RvcmVcbiAgICApIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiT2lkY0NsaWVudC5jcmVhdGVTaWduaW5SZXF1ZXN0XCIpO1xuXG4gICAgICAgIGxldCBjbGllbnRfaWQgPSB0aGlzLl9zZXR0aW5ncy5jbGllbnRfaWQ7XG4gICAgICAgIHJlc3BvbnNlX3R5cGUgPSByZXNwb25zZV90eXBlIHx8IHRoaXMuX3NldHRpbmdzLnJlc3BvbnNlX3R5cGU7XG4gICAgICAgIHNjb3BlID0gc2NvcGUgfHwgdGhpcy5fc2V0dGluZ3Muc2NvcGU7XG4gICAgICAgIHJlZGlyZWN0X3VyaSA9IHJlZGlyZWN0X3VyaSB8fCB0aGlzLl9zZXR0aW5ncy5yZWRpcmVjdF91cmk7XG5cbiAgICAgICAgLy8gaWRfdG9rZW5faGludCwgbG9naW5faGludCBhcmVuJ3QgYWxsb3dlZCBvbiBfc2V0dGluZ3NcbiAgICAgICAgcHJvbXB0ID0gcHJvbXB0IHx8IHRoaXMuX3NldHRpbmdzLnByb21wdDtcbiAgICAgICAgZGlzcGxheSA9IGRpc3BsYXkgfHwgdGhpcy5fc2V0dGluZ3MuZGlzcGxheTtcbiAgICAgICAgbWF4X2FnZSA9IG1heF9hZ2UgfHwgdGhpcy5fc2V0dGluZ3MubWF4X2FnZTtcbiAgICAgICAgdWlfbG9jYWxlcyA9IHVpX2xvY2FsZXMgfHwgdGhpcy5fc2V0dGluZ3MudWlfbG9jYWxlcztcbiAgICAgICAgYWNyX3ZhbHVlcyA9IGFjcl92YWx1ZXMgfHwgdGhpcy5fc2V0dGluZ3MuYWNyX3ZhbHVlcztcbiAgICAgICAgcmVzb3VyY2UgPSByZXNvdXJjZSB8fCB0aGlzLl9zZXR0aW5ncy5yZXNvdXJjZTtcbiAgICAgICAgZXh0cmFRdWVyeVBhcmFtcyA9IGV4dHJhUXVlcnlQYXJhbXMgfHwgdGhpcy5fc2V0dGluZ3MuZXh0cmFRdWVyeVBhcmFtcztcbiAgICAgICAgXG4gICAgICAgIGxldCBhdXRob3JpdHkgPSB0aGlzLl9zZXR0aW5ncy5hdXRob3JpdHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhU2VydmljZS5nZXRBdXRob3JpemF0aW9uRW5kcG9pbnQoKS50aGVuKHVybCA9PiB7XG4gICAgICAgICAgICBMb2cuZGVidWcoXCJSZWNlaXZlZCBhdXRob3JpemF0aW9uIGVuZHBvaW50XCIsIHVybCk7XG5cbiAgICAgICAgICAgIGxldCBzaWduaW5SZXF1ZXN0ID0gbmV3IFNpZ25pblJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBjbGllbnRfaWQsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RfdXJpLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlX3R5cGUsXG4gICAgICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSB8fCBzdGF0ZSxcbiAgICAgICAgICAgICAgICBhdXRob3JpdHksXG4gICAgICAgICAgICAgICAgcHJvbXB0LCBkaXNwbGF5LCBtYXhfYWdlLCB1aV9sb2NhbGVzLCBpZF90b2tlbl9oaW50LCBsb2dpbl9oaW50LCBhY3JfdmFsdWVzLFxuICAgICAgICAgICAgICAgIHJlc291cmNlLCByZXF1ZXN0LCByZXF1ZXN0X3VyaSwgZXh0cmFRdWVyeVBhcmFtcyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgc2lnbmluU3RhdGUgPSBzaWduaW5SZXF1ZXN0LnN0YXRlO1xuICAgICAgICAgICAgc3RhdGVTdG9yZSA9IHN0YXRlU3RvcmUgfHwgdGhpcy5fc3RhdGVTdG9yZTtcblxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlU3RvcmUuc2V0KHNpZ25pblN0YXRlLmlkLCBzaWduaW5TdGF0ZS50b1N0b3JhZ2VTdHJpbmcoKSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25pblJlcXVlc3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJvY2Vzc1NpZ25pblJlc3BvbnNlKHVybCwgc3RhdGVTdG9yZSkge1xuICAgICAgICBMb2cuZGVidWcoXCJPaWRjQ2xpZW50LnByb2Nlc3NTaWduaW5SZXNwb25zZVwiKTtcblxuICAgICAgICB2YXIgcmVzcG9uc2UgPSBuZXcgU2lnbmluUmVzcG9uc2UodXJsKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLnN0YXRlKSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoXCJObyBzdGF0ZSBpbiByZXNwb25zZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyBzdGF0ZSBpbiByZXNwb25zZVwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZVN0b3JlID0gc3RhdGVTdG9yZSB8fCB0aGlzLl9zdGF0ZVN0b3JlO1xuXG4gICAgICAgIHJldHVybiBzdGF0ZVN0b3JlLnJlbW92ZShyZXNwb25zZS5zdGF0ZSkudGhlbihzdG9yZWRTdGF0ZVN0cmluZyA9PiB7XG4gICAgICAgICAgICBpZiAoIXN0b3JlZFN0YXRlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgTG9nLmVycm9yKFwiTm8gbWF0Y2hpbmcgc3RhdGUgZm91bmQgaW4gc3RvcmFnZVwiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtYXRjaGluZyBzdGF0ZSBmb3VuZCBpbiBzdG9yYWdlXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc3RhdGUgPSBTaWduaW5TdGF0ZS5mcm9tU3RvcmFnZVN0cmluZyhzdG9yZWRTdGF0ZVN0cmluZyk7XG5cbiAgICAgICAgICAgIExvZy5kZWJ1ZyhcIlJlY2VpdmVkIHN0YXRlIGZyb20gc3RvcmFnZTsgdmFsaWRhdGluZyByZXNwb25zZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0b3IudmFsaWRhdGVTaWduaW5SZXNwb25zZShzdGF0ZSwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjcmVhdGVTaWdub3V0UmVxdWVzdCh7aWRfdG9rZW5faGludCwgZGF0YSwgc3RhdGUsIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaX0gPSB7fSxcbiAgICAgICAgc3RhdGVTdG9yZVxuICAgICkge1xuICAgICAgICBMb2cuZGVidWcoXCJPaWRjQ2xpZW50LmNyZWF0ZVNpZ25vdXRSZXF1ZXN0XCIpO1xuXG4gICAgICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSA9IHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSB8fCB0aGlzLl9zZXR0aW5ncy5wb3N0X2xvZ291dF9yZWRpcmVjdF91cmk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhU2VydmljZS5nZXRFbmRTZXNzaW9uRW5kcG9pbnQoKS50aGVuKHVybCA9PiB7XG4gICAgICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgICAgIExvZy5lcnJvcihcIk5vIGVuZCBzZXNzaW9uIGVuZHBvaW50IHVybCByZXR1cm5lZFwiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBlbmQgc2Vzc2lvbiBlbmRwb2ludFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTG9nLmRlYnVnKFwiUmVjZWl2ZWQgZW5kIHNlc3Npb24gZW5kcG9pbnRcIiwgdXJsKTtcblxuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgU2lnbm91dFJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBpZF90b2tlbl9oaW50LFxuICAgICAgICAgICAgICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhIHx8IHN0YXRlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHNpZ25vdXRTdGF0ZSA9IHJlcXVlc3Quc3RhdGU7XG4gICAgICAgICAgICBpZiAoc2lnbm91dFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgTG9nLmRlYnVnKFwiU2lnbm91dCByZXF1ZXN0IGhhcyBzdGF0ZSB0byBwZXJzaXN0XCIpO1xuXG4gICAgICAgICAgICAgICAgc3RhdGVTdG9yZSA9IHN0YXRlU3RvcmUgfHwgdGhpcy5fc3RhdGVTdG9yZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVN0b3JlLnNldChzaWdub3V0U3RhdGUuaWQsIHNpZ25vdXRTdGF0ZS50b1N0b3JhZ2VTdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcm9jZXNzU2lnbm91dFJlc3BvbnNlKHVybCwgc3RhdGVTdG9yZSkge1xuICAgICAgICBMb2cuZGVidWcoXCJPaWRjQ2xpZW50LnByb2Nlc3NTaWdub3V0UmVzcG9uc2VcIik7XG5cbiAgICAgICAgdmFyIHJlc3BvbnNlID0gbmV3IFNpZ25vdXRSZXNwb25zZSh1cmwpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLnN0YXRlKSB7XG4gICAgICAgICAgICBMb2cuZGVidWcoXCJObyBzdGF0ZSBpbiByZXNwb25zZVwiKTtcblxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgTG9nLndhcm4oXCJSZXNwb25zZSB3YXMgZXJyb3JcIiwgcmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3JSZXNwb25zZShyZXNwb25zZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGF0ZUtleSA9IHJlc3BvbnNlLnN0YXRlO1xuXG4gICAgICAgIHN0YXRlU3RvcmUgPSBzdGF0ZVN0b3JlIHx8IHRoaXMuX3N0YXRlU3RvcmU7XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlU3RvcmUucmVtb3ZlKHN0YXRlS2V5KS50aGVuKHN0b3JlZFN0YXRlU3RyaW5nID0+IHtcbiAgICAgICAgICAgIGlmICghc3RvcmVkU3RhdGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBMb2cuZXJyb3IoXCJObyBtYXRjaGluZyBzdGF0ZSBmb3VuZCBpbiBzdG9yYWdlXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG1hdGNoaW5nIHN0YXRlIGZvdW5kIGluIHN0b3JhZ2VcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IFN0YXRlLmZyb21TdG9yYWdlU3RyaW5nKHN0b3JlZFN0YXRlU3RyaW5nKTtcblxuICAgICAgICAgICAgTG9nLmRlYnVnKFwiUmVjZWl2ZWQgc3RhdGUgZnJvbSBzdG9yYWdlOyB2YWxpZGF0aW5nIHJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvci52YWxpZGF0ZVNpZ25vdXRSZXNwb25zZShzdGF0ZSwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjbGVhclN0YWxlU3RhdGUoc3RhdGVTdG9yZSkge1xuICAgICAgICBMb2cuZGVidWcoXCJPaWRjQ2xpZW50LmNsZWFyU3RhbGVTdGF0ZVwiKTtcblxuICAgICAgICBzdGF0ZVN0b3JlID0gc3RhdGVTdG9yZSB8fCB0aGlzLl9zdGF0ZVN0b3JlO1xuXG4gICAgICAgIHJldHVybiBTdGF0ZS5jbGVhclN0YWxlU3RhdGUoc3RhdGVTdG9yZSwgdGhpcy5zZXR0aW5ncy5zdGFsZVN0YXRlQWdlKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvT2lkY0NsaWVudC5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBMb2cgZnJvbSAnLi9Mb2cnO1xuaW1wb3J0IFdlYlN0b3JhZ2VTdGF0ZVN0b3JlIGZyb20gJy4vV2ViU3RvcmFnZVN0YXRlU3RvcmUnO1xuaW1wb3J0IFJlc3BvbnNlVmFsaWRhdG9yIGZyb20gJy4vUmVzcG9uc2VWYWxpZGF0b3InO1xuaW1wb3J0IE1ldGFkYXRhU2VydmljZSBmcm9tICcuL01ldGFkYXRhU2VydmljZSc7XG5cbmNvbnN0IE9pZGNNZXRhZGF0YVVybFBhdGggPSAnLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb24nO1xuXG5jb25zdCBEZWZhdWx0UmVzcG9uc2VUeXBlID0gXCJpZF90b2tlblwiO1xuY29uc3QgRGVmYXVsdFNjb3BlID0gXCJvcGVuaWRcIjtcbmNvbnN0IERlZmF1bHRTdGFsZVN0YXRlQWdlID0gNjAgKiA1OyAvLyBzZWNvbmRzXG5jb25zdCBEZWZhdWx0Q2xvY2tTa2V3SW5TZWNvbmRzID0gNTk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9pZGNDbGllbnRTZXR0aW5ncyB7XG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICAvLyBtZXRhZGF0YSByZWxhdGVkXG4gICAgICAgIGF1dGhvcml0eSwgbWV0YWRhdGFVcmwsIG1ldGFkYXRhLCBzaWduaW5nS2V5cyxcbiAgICAgICAgLy8gY2xpZW50IHJlbGF0ZWRcbiAgICAgICAgY2xpZW50X2lkLCBjbGllbnRfc2VjcmV0LCByZXNwb25zZV90eXBlID0gRGVmYXVsdFJlc3BvbnNlVHlwZSwgc2NvcGUgPSBEZWZhdWx0U2NvcGUsXG4gICAgICAgIHJlZGlyZWN0X3VyaSwgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpLFxuICAgICAgICAvLyBvcHRpb25hbCBwcm90b2NvbFxuICAgICAgICBwcm9tcHQsIGRpc3BsYXksIG1heF9hZ2UsIHVpX2xvY2FsZXMsIGFjcl92YWx1ZXMsIHJlc291cmNlLFxuICAgICAgICAvLyBiZWhhdmlvciBmbGFnc1xuICAgICAgICBmaWx0ZXJQcm90b2NvbENsYWltcyA9IHRydWUsIGxvYWRVc2VySW5mbyA9IHRydWUsXG4gICAgICAgIHN0YWxlU3RhdGVBZ2UgPSBEZWZhdWx0U3RhbGVTdGF0ZUFnZSwgY2xvY2tTa2V3ID0gRGVmYXVsdENsb2NrU2tld0luU2Vjb25kcyxcbiAgICAgICAgLy8gb3RoZXIgYmVoYXZpb3JcbiAgICAgICAgc3RhdGVTdG9yZSA9IG5ldyBXZWJTdG9yYWdlU3RhdGVTdG9yZSgpLFxuICAgICAgICBSZXNwb25zZVZhbGlkYXRvckN0b3IgPSBSZXNwb25zZVZhbGlkYXRvcixcbiAgICAgICAgTWV0YWRhdGFTZXJ2aWNlQ3RvciA9IE1ldGFkYXRhU2VydmljZSxcbiAgICAgICAgLy8gZXh0cmEgcXVlcnkgcGFyYW1zXG4gICAgICAgIGV4dHJhUXVlcnlQYXJhbXMgPSB7fVxuICAgIH0gPSB7fSkge1xuXG4gICAgICAgIHRoaXMuX2F1dGhvcml0eSA9IGF1dGhvcml0eTtcbiAgICAgICAgdGhpcy5fbWV0YWRhdGFVcmwgPSBtZXRhZGF0YVVybDtcbiAgICAgICAgdGhpcy5fbWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5fc2lnbmluZ0tleXMgPSBzaWduaW5nS2V5cztcblxuICAgICAgICB0aGlzLl9jbGllbnRfaWQgPSBjbGllbnRfaWQ7XG4gICAgICAgIHRoaXMuX2NsaWVudF9zZWNyZXQgPSBjbGllbnRfc2VjcmV0O1xuICAgICAgICB0aGlzLl9yZXNwb25zZV90eXBlID0gcmVzcG9uc2VfdHlwZTtcbiAgICAgICAgdGhpcy5fc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy5fcmVkaXJlY3RfdXJpID0gcmVkaXJlY3RfdXJpO1xuICAgICAgICB0aGlzLl9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmkgPSBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmk7XG5cbiAgICAgICAgdGhpcy5fcHJvbXB0ID0gcHJvbXB0O1xuICAgICAgICB0aGlzLl9kaXNwbGF5ID0gZGlzcGxheTtcbiAgICAgICAgdGhpcy5fbWF4X2FnZSA9IG1heF9hZ2U7XG4gICAgICAgIHRoaXMuX3VpX2xvY2FsZXMgPSB1aV9sb2NhbGVzO1xuICAgICAgICB0aGlzLl9hY3JfdmFsdWVzID0gYWNyX3ZhbHVlcztcbiAgICAgICAgdGhpcy5fcmVzb3VyY2UgPSByZXNvdXJjZTtcblxuICAgICAgICB0aGlzLl9maWx0ZXJQcm90b2NvbENsYWltcyA9ICEhZmlsdGVyUHJvdG9jb2xDbGFpbXM7XG4gICAgICAgIHRoaXMuX2xvYWRVc2VySW5mbyA9ICEhbG9hZFVzZXJJbmZvO1xuICAgICAgICB0aGlzLl9zdGFsZVN0YXRlQWdlID0gc3RhbGVTdGF0ZUFnZTtcbiAgICAgICAgdGhpcy5fY2xvY2tTa2V3ID0gY2xvY2tTa2V3O1xuXG4gICAgICAgIHRoaXMuX3N0YXRlU3RvcmUgPSBzdGF0ZVN0b3JlO1xuICAgICAgICB0aGlzLl92YWxpZGF0b3IgPSBuZXcgUmVzcG9uc2VWYWxpZGF0b3JDdG9yKHRoaXMpO1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVNlcnZpY2UgPSBuZXcgTWV0YWRhdGFTZXJ2aWNlQ3Rvcih0aGlzKTtcblxuICAgICAgICB0aGlzLl9leHRyYVF1ZXJ5UGFyYW1zID0gdHlwZW9mIGV4dHJhUXVlcnlQYXJhbXMgPT09ICdvYmplY3QnID8gZXh0cmFRdWVyeVBhcmFtcyA6IHt9O1xuICAgIH1cblxuICAgIC8vIGNsaWVudCBjb25maWdcbiAgICBnZXQgY2xpZW50X2lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50X2lkO1xuICAgIH1cbiAgICBzZXQgY2xpZW50X2lkKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2xpZW50X2lkKSB7XG4gICAgICAgICAgICAvLyBvbmUtdGltZSBzZXQgb25seVxuICAgICAgICAgICAgdGhpcy5fY2xpZW50X2lkID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoXCJjbGllbnRfaWQgaGFzIGFscmVhZHkgYmVlbiBhc3NpZ25lZC5cIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNsaWVudF9pZCBoYXMgYWxyZWFkeSBiZWVuIGFzc2lnbmVkLlwiKVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjbGllbnRfc2VjcmV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50X3NlY3JldDtcbiAgICB9XG4gICAgZ2V0IHJlc3BvbnNlX3R5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNwb25zZV90eXBlO1xuICAgIH1cbiAgICBnZXQgc2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY29wZTtcbiAgICB9XG4gICAgZ2V0IHJlZGlyZWN0X3VyaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZGlyZWN0X3VyaTtcbiAgICB9XG4gICAgZ2V0IHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaTtcbiAgICB9XG5cblxuICAgIC8vIG9wdGlvbmFsIHByb3RvY29sIHBhcmFtc1xuICAgIGdldCBwcm9tcHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9tcHQ7XG4gICAgfVxuICAgIGdldCBkaXNwbGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGxheTtcbiAgICB9XG4gICAgZ2V0IG1heF9hZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhfYWdlO1xuICAgIH1cbiAgICBnZXQgdWlfbG9jYWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VpX2xvY2FsZXM7XG4gICAgfVxuICAgIGdldCBhY3JfdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWNyX3ZhbHVlcztcbiAgICB9XG4gICAgZ2V0IHJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb3VyY2U7XG4gICAgfVxuXG5cbiAgICAvLyBtZXRhZGF0YVxuICAgIGdldCBhdXRob3JpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRob3JpdHk7XG4gICAgfVxuICAgIHNldCBhdXRob3JpdHkodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hdXRob3JpdHkpIHtcbiAgICAgICAgICAgIC8vIG9uZS10aW1lIHNldCBvbmx5XG4gICAgICAgICAgICB0aGlzLl9hdXRob3JpdHkgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcImF1dGhvcml0eSBoYXMgYWxyZWFkeSBiZWVuIGFzc2lnbmVkLlwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXV0aG9yaXR5IGhhcyBhbHJlYWR5IGJlZW4gYXNzaWduZWQuXCIpXG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG1ldGFkYXRhVXJsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21ldGFkYXRhVXJsKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXRhZGF0YVVybCA9IHRoaXMuYXV0aG9yaXR5O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fbWV0YWRhdGFVcmwgJiYgdGhpcy5fbWV0YWRhdGFVcmwuaW5kZXhPZihPaWRjTWV0YWRhdGFVcmxQYXRoKSA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWV0YWRhdGFVcmxbdGhpcy5fbWV0YWRhdGFVcmwubGVuZ3RoIC0gMV0gIT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRhZGF0YVVybCArPSAnLyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhVXJsICs9IE9pZGNNZXRhZGF0YVVybFBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGFVcmw7XG4gICAgfVxuXG4gICAgLy8gc2V0dGFibGUvY2FjaGFibGUgbWV0YWRhdGEgdmFsdWVzXG4gICAgZ2V0IG1ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGE7XG4gICAgfVxuICAgIHNldCBtZXRhZGF0YSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9tZXRhZGF0YSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBzaWduaW5nS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25pbmdLZXlzO1xuICAgIH1cbiAgICBzZXQgc2lnbmluZ0tleXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2lnbmluZ0tleXMgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBiZWhhdmlvciBmbGFnc1xuICAgIGdldCBmaWx0ZXJQcm90b2NvbENsYWltcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlclByb3RvY29sQ2xhaW1zO1xuICAgIH1cbiAgICBnZXQgbG9hZFVzZXJJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZFVzZXJJbmZvO1xuICAgIH1cbiAgICBnZXQgc3RhbGVTdGF0ZUFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWxlU3RhdGVBZ2U7XG4gICAgfVxuICAgIGdldCBjbG9ja1NrZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9ja1NrZXc7XG4gICAgfVxuXG4gICAgZ2V0IHN0YXRlU3RvcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZVN0b3JlO1xuICAgIH1cbiAgICBnZXQgdmFsaWRhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdG9yO1xuICAgIH1cbiAgICBnZXQgbWV0YWRhdGFTZXJ2aWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGFTZXJ2aWNlO1xuICAgIH1cblxuICAgIC8vIGV4dHJhIHF1ZXJ5IHBhcmFtc1xuICAgIGdldCBleHRyYVF1ZXJ5UGFyYW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0cmFRdWVyeVBhcmFtcztcbiAgICB9XG4gICAgc2V0IGV4dHJhUXVlcnlQYXJhbXModmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpe1xuICAgICAgICAgICAgdGhpcy5fZXh0cmFRdWVyeVBhcmFtcyA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXh0cmFRdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL09pZGNDbGllbnRTZXR0aW5ncy5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBMb2cgZnJvbSAnLi9Mb2cnO1xuaW1wb3J0IEdsb2JhbCBmcm9tICcuL0dsb2JhbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYlN0b3JhZ2VTdGF0ZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3Rvcih7cHJlZml4ID0gXCJvaWRjLlwiLCBzdG9yZSA9IEdsb2JhbC5sb2NhbFN0b3JhZ2V9ID0ge30pIHtcbiAgICAgICAgdGhpcy5fc3RvcmUgPSBzdG9yZTtcbiAgICAgICAgdGhpcy5fcHJlZml4ID0gcHJlZml4O1xuICAgIH1cblxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIldlYlN0b3JhZ2VTdGF0ZVN0b3JlLnNldFwiLCBrZXkpO1xuXG4gICAgICAgIGtleSA9IHRoaXMuX3ByZWZpeCArIGtleTtcblxuICAgICAgICB0aGlzLl9zdG9yZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIGdldChrZXkpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiV2ViU3RvcmFnZVN0YXRlU3RvcmUuZ2V0XCIsIGtleSk7XG5cbiAgICAgICAga2V5ID0gdGhpcy5fcHJlZml4ICsga2V5O1xuXG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5fc3RvcmUuZ2V0SXRlbShrZXkpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpdGVtKTtcbiAgICB9XG5cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIldlYlN0b3JhZ2VTdGF0ZVN0b3JlLnJlbW92ZVwiLCBrZXkpO1xuXG4gICAgICAgIGtleSA9IHRoaXMuX3ByZWZpeCArIGtleTtcblxuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuX3N0b3JlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgdGhpcy5fc3RvcmUucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpdGVtKTtcbiAgICB9XG5cbiAgICBnZXRBbGxLZXlzKCkge1xuICAgICAgICBMb2cuZGVidWcoXCJXZWJTdG9yYWdlU3RhdGVTdG9yZS5nZXRBbGxLZXlzXCIpO1xuXG4gICAgICAgIHZhciBrZXlzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX3N0b3JlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuX3N0b3JlLmtleShpbmRleCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZih0aGlzLl9wcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleS5zdWJzdHIodGhpcy5fcHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtleXMpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9XZWJTdG9yYWdlU3RhdGVTdG9yZS5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmNvbnN0IHRpbWVyID0ge1xuICAgIHNldEludGVydmFsOiBmdW5jdGlvbiAoY2IsIGR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBzZXRJbnRlcnZhbChjYiwgZHVyYXRpb24pO1xuICAgIH0sXG4gICAgY2xlYXJJbnRlcnZhbDogZnVuY3Rpb24gKGhhbmRsZSkge1xuICAgICAgICByZXR1cm4gY2xlYXJJbnRlcnZhbChoYW5kbGUpO1xuICAgIH1cbn07XG5cbmxldCB0ZXN0aW5nID0gZmFsc2U7XG5sZXQgcmVxdWVzdCA9IG51bGw7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdsb2JhbCB7XG5cbiAgICBzdGF0aWMgX3Rlc3RpbmcoKSB7XG4gICAgICAgIHRlc3RpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgbG9jYXRpb24oKSB7XG4gICAgICAgIGlmICghdGVzdGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBsb2NhbFN0b3JhZ2UoKSB7XG4gICAgICAgIGlmICghdGVzdGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgc2Vzc2lvblN0b3JhZ2UoKSB7XG4gICAgICAgIGlmICghdGVzdGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHNldFhNTEh0dHBSZXF1ZXN0KG5ld1JlcXVlc3QpIHtcbiAgICAgICAgcmVxdWVzdCA9IG5ld1JlcXVlc3Q7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBYTUxIdHRwUmVxdWVzdCgpIHtcbiAgICAgICAgaWYgKCF0ZXN0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdCB8fCBYTUxIdHRwUmVxdWVzdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgdGltZXIoKSB7XG4gICAgICAgIGlmICghdGVzdGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVyO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9HbG9iYWwuanMiLCIvLyBDb3B5cmlnaHQgKGMpIEJyb2NrIEFsbGVuICYgRG9taW5pY2sgQmFpZXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTElDRU5TRSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG5pbXBvcnQgTG9nIGZyb20gJy4vTG9nJztcbmltcG9ydCBNZXRhZGF0YVNlcnZpY2UgZnJvbSAnLi9NZXRhZGF0YVNlcnZpY2UnO1xuaW1wb3J0IFVzZXJJbmZvU2VydmljZSBmcm9tICcuL1VzZXJJbmZvU2VydmljZSc7XG5pbXBvcnQgRXJyb3JSZXNwb25zZSBmcm9tICcuL0Vycm9yUmVzcG9uc2UnO1xuaW1wb3J0IEpvc2VVdGlsIGZyb20gJy4vSm9zZVV0aWwnO1xuXG5jb25zdCBQcm90b2NvbENsYWltcyA9IFtcIm5vbmNlXCIsIFwiYXRfaGFzaFwiLCBcImlhdFwiLCBcIm5iZlwiLCBcImV4cFwiLCBcImF1ZFwiLCBcImlzc1wiLCBcImNfaGFzaFwiXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzcG9uc2VWYWxpZGF0b3Ige1xuXG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MsIE1ldGFkYXRhU2VydmljZUN0b3IgPSBNZXRhZGF0YVNlcnZpY2UsIFVzZXJJbmZvU2VydmljZUN0b3IgPSBVc2VySW5mb1NlcnZpY2UsIGpvc2VVdGlsID0gSm9zZVV0aWwpIHtcbiAgICAgICAgaWYgKCFzZXR0aW5ncykge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiTm8gc2V0dGluZ3MgcGFzc2VkIHRvIFJlc3BvbnNlVmFsaWRhdG9yXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2V0dGluZ3NcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVNlcnZpY2UgPSBuZXcgTWV0YWRhdGFTZXJ2aWNlQ3Rvcih0aGlzLl9zZXR0aW5ncyk7XG4gICAgICAgIHRoaXMuX3VzZXJJbmZvU2VydmljZSA9IG5ldyBVc2VySW5mb1NlcnZpY2VDdG9yKHRoaXMuX3NldHRpbmdzKTtcbiAgICAgICAgdGhpcy5fam9zZVV0aWwgPSBqb3NlVXRpbDtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZVNpZ25pblJlc3BvbnNlKHN0YXRlLCByZXNwb25zZSkge1xuICAgICAgICBMb2cuZGVidWcoXCJSZXNwb25zZVZhbGlkYXRvci52YWxpZGF0ZVNpZ25pblJlc3BvbnNlXCIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzU2lnbmluUGFyYW1zKHN0YXRlLCByZXNwb25zZSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICBMb2cuZGVidWcoXCJzdGF0ZSBwcm9jZXNzZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGVUb2tlbnMoc3RhdGUsIHJlc3BvbnNlKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJ0b2tlbnMgdmFsaWRhdGVkXCIpO1xuICAgICAgICAgICAgICAgIExvZy5kZWJ1ZygnLS0tLS0tJylcbiAgICAgICAgICAgICAgICBMb2cuZGVidWcocmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NDbGFpbXMocmVzcG9uc2UpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJjbGFpbXMgcHJvY2Vzc2VkXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVTaWdub3V0UmVzcG9uc2Uoc3RhdGUsIHJlc3BvbnNlKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIlJlc3BvbnNlVmFsaWRhdG9yLnZhbGlkYXRlU2lnbm91dFJlc3BvbnNlXCIpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5pZCAhPT0gcmVzcG9uc2Uuc3RhdGUpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIlN0YXRlIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlN0YXRlIGRvZXMgbm90IG1hdGNoXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdyB0aGF0IHdlIGtub3cgdGhlIHN0YXRlIG1hdGNoZXMsIHRha2UgdGhlIHN0b3JlZCBkYXRhXG4gICAgICAgIC8vIGFuZCBzZXQgaXQgaW50byB0aGUgcmVzcG9uc2Ugc28gY2FsbGVycyBjYW4gZ2V0IHRoZWlyIHN0YXRlXG4gICAgICAgIC8vIHRoaXMgaXMgaW1wb3J0YW50IGZvciBib3RoIHN1Y2Nlc3MgJiBlcnJvciBvdXRjb21lc1xuICAgICAgICBMb2cuZGVidWcoXCJzdGF0ZSB2YWxpZGF0ZWRcIik7XG4gICAgICAgIHJlc3BvbnNlLnN0YXRlID0gc3RhdGUuZGF0YTtcblxuICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIExvZy53YXJuKFwiUmVzcG9uc2Ugd2FzIGVycm9yXCIsIHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3JSZXNwb25zZShyZXNwb25zZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgX3Byb2Nlc3NTaWduaW5QYXJhbXMoc3RhdGUsIHJlc3BvbnNlKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIlJlc3BvbnNlVmFsaWRhdG9yLl9wcm9jZXNzU2lnbmluUGFyYW1zXCIpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5pZCAhPT0gcmVzcG9uc2Uuc3RhdGUpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIlN0YXRlIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlN0YXRlIGRvZXMgbm90IG1hdGNoXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCFzdGF0ZS5jbGllbnRfaWQpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIk5vIGNsaWVudF9pZCBvbiBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyBjbGllbnRfaWQgb24gc3RhdGVcIikpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIXN0YXRlLmF1dGhvcml0eSkge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiTm8gYXV0aG9yaXR5IG9uIHN0YXRlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIGF1dGhvcml0eSBvbiBzdGF0ZVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHRoaXMgYWxsb3dzIHRoZSBhdXRob3JpdHkgdG8gYmUgbG9hZGVkIGZyb20gdGhlIHNpZ25pbiBzdGF0ZVxuICAgICAgICBpZiAoIXRoaXMuX3NldHRpbmdzLmF1dGhvcml0eSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3MuYXV0aG9yaXR5ID0gc3RhdGUuYXV0aG9yaXR5O1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuc3VyZSB3ZSdyZSB1c2luZyB0aGUgY29ycmVjdCBhdXRob3JpdHkgaWYgdGhlIGF1dGhvcml0eSBpcyBub3QgbG9hZGVkIGZyb20gc2lnbmluIHN0YXRlXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3NldHRpbmdzLmF1dGhvcml0eSAmJiB0aGlzLl9zZXR0aW5ncy5hdXRob3JpdHkgIT09IHN0YXRlLmF1dGhvcml0eSkge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiYXV0aG9yaXR5IG1pc21hdGNoIG9uIHNldHRpbmdzIHZzLiBzaWduaW4gc3RhdGVcIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiYXV0aG9yaXR5IG1pc21hdGNoIG9uIHNldHRpbmdzIHZzLiBzaWduaW4gc3RhdGVcIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgYWxsb3dzIHRoZSBjbGllbnRfaWQgdG8gYmUgbG9hZGVkIGZyb20gdGhlIHNpZ25pbiBzdGF0ZVxuICAgICAgICBpZiAoIXRoaXMuX3NldHRpbmdzLmNsaWVudF9pZCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3MuY2xpZW50X2lkID0gc3RhdGUuY2xpZW50X2lkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuc3VyZSB3ZSdyZSB1c2luZyB0aGUgY29ycmVjdCBjbGllbnRfaWQgaWYgdGhlIGNsaWVudF9pZCBpcyBub3QgbG9hZGVkIGZyb20gc2lnbmluIHN0YXRlXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3NldHRpbmdzLmNsaWVudF9pZCAmJiB0aGlzLl9zZXR0aW5ncy5jbGllbnRfaWQgIT09IHN0YXRlLmNsaWVudF9pZCkge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiY2xpZW50X2lkIG1pc21hdGNoIG9uIHNldHRpbmdzIHZzLiBzaWduaW4gc3RhdGVcIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiY2xpZW50X2lkIG1pc21hdGNoIG9uIHNldHRpbmdzIHZzLiBzaWduaW4gc3RhdGVcIikpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBub3cgdGhhdCB3ZSBrbm93IHRoZSBzdGF0ZSBtYXRjaGVzLCB0YWtlIHRoZSBzdG9yZWQgZGF0YVxuICAgICAgICAvLyBhbmQgc2V0IGl0IGludG8gdGhlIHJlc3BvbnNlIHNvIGNhbGxlcnMgY2FuIGdldCB0aGVpciBzdGF0ZVxuICAgICAgICAvLyB0aGlzIGlzIGltcG9ydGFudCBmb3IgYm90aCBzdWNjZXNzICYgZXJyb3Igb3V0Y29tZXNcbiAgICAgICAgTG9nLmRlYnVnKFwic3RhdGUgdmFsaWRhdGVkXCIpO1xuICAgICAgICByZXNwb25zZS5zdGF0ZSA9IHN0YXRlLmRhdGE7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICBMb2cud2FybihcIlJlc3BvbnNlIHdhcyBlcnJvclwiLCByZXNwb25zZS5lcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yUmVzcG9uc2UocmVzcG9uc2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZS5ub25jZSAmJiAhcmVzcG9uc2UuaWRfdG9rZW4pIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIkV4cGVjdGluZyBpZF90b2tlbiBpbiByZXNwb25zZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyBpZF90b2tlbiBpbiByZXNwb25zZVwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0YXRlLm5vbmNlICYmIHJlc3BvbnNlLmlkX3Rva2VuKSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoXCJOb3QgZXhwZWN0aW5nIGlkX3Rva2VuIGluIHJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgaWRfdG9rZW4gaW4gcmVzcG9uc2VcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgX3Byb2Nlc3NDbGFpbXMocmVzcG9uc2UpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiUmVzcG9uc2VWYWxpZGF0b3IuX3Byb2Nlc3NDbGFpbXNcIik7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLmlzT3BlbklkQ29ubmVjdCkge1xuICAgICAgICAgICAgTG9nLmRlYnVnKFwicmVzcG9uc2UgaXMgT0lEQywgcHJvY2Vzc2luZyBjbGFpbXNcIik7XG5cbiAgICAgICAgICAgIHJlc3BvbnNlLnByb2ZpbGUgPSB0aGlzLl9maWx0ZXJQcm90b2NvbENsYWltcyhyZXNwb25zZS5wcm9maWxlKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmxvYWRVc2VySW5mbyAmJiByZXNwb25zZS5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJsb2FkaW5nIHVzZXIgaW5mb1wiKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91c2VySW5mb1NlcnZpY2UuZ2V0Q2xhaW1zKHJlc3BvbnNlLmFjY2Vzc190b2tlbikudGhlbihjbGFpbXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJ1c2VyIGluZm8gY2xhaW1zIHJlY2VpdmVkIGZyb20gdXNlciBpbmZvIGVuZHBvaW50XCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFpbXMuc3ViICE9PSByZXNwb25zZS5wcm9maWxlLnN1Yikge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmVycm9yKFwic3ViIGZyb20gdXNlciBpbmZvIGVuZHBvaW50IGRvZXMgbm90IG1hdGNoIHN1YiBpbiBhY2Nlc3NfdG9rZW5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwic3ViIGZyb20gdXNlciBpbmZvIGVuZHBvaW50IGRvZXMgbm90IG1hdGNoIHN1YiBpbiBhY2Nlc3NfdG9rZW5cIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucHJvZmlsZSA9IHRoaXMuX21lcmdlQ2xhaW1zKHJlc3BvbnNlLnByb2ZpbGUsIGNsYWltcyk7XG4gICAgICAgICAgICAgICAgICAgIExvZy5kZWJ1ZyhcInVzZXIgaW5mbyBjbGFpbXMgcmVjZWl2ZWQsIHVwZGF0ZWQgcHJvZmlsZTpcIiwgcmVzcG9uc2UucHJvZmlsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgTG9nLmRlYnVnKFwibm90IGxvYWRpbmcgdXNlciBpbmZvXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgTG9nLmRlYnVnKFwicmVzcG9uc2UgaXMgbm90IE9JREMsIG5vdCBwcm9jZXNzaW5nIGNsYWltc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIF9tZXJnZUNsYWltcyhjbGFpbXMxLCBjbGFpbXMyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBjbGFpbXMxKTtcblxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGNsYWltczIpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBjbGFpbXMyW25hbWVdO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0W25hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0W25hbWVdLmluZGV4T2YodmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W25hbWVdLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdFtuYW1lXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gW3Jlc3VsdFtuYW1lXSwgdmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgX2ZpbHRlclByb3RvY29sQ2xhaW1zKGNsYWltcykge1xuICAgICAgICBMb2cuZGVidWcoXCJSZXNwb25zZVZhbGlkYXRvci5fZmlsdGVyUHJvdG9jb2xDbGFpbXMsIGluY29taW5nIGNsYWltczpcIiwgY2xhaW1zKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgY2xhaW1zKTtcblxuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MuX2ZpbHRlclByb3RvY29sQ2xhaW1zKSB7XG4gICAgICAgICAgICBQcm90b2NvbENsYWltcy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRbdHlwZV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgTG9nLmRlYnVnKFwicHJvdG9jb2wgY2xhaW1zIGZpbHRlcmVkXCIsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBMb2cuZGVidWcoXCJwcm90b2NvbCBjbGFpbXMgbm90IGZpbHRlcmVkXCIpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIF92YWxpZGF0ZVRva2VucyhzdGF0ZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiUmVzcG9uc2VWYWxpZGF0b3IuX3ZhbGlkYXRlVG9rZW5zXCIpO1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5pZF90b2tlbikge1xuXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgTG9nLmRlYnVnKFwiVmFsaWRhdGluZyBpZF90b2tlbiBhbmQgYWNjZXNzX3Rva2VuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZUlkVG9rZW5BbmRBY2Nlc3NUb2tlbihzdGF0ZSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBMb2cuZGVidWcoXCJWYWxpZGF0aW5nIGlkX3Rva2VuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlSWRUb2tlbihzdGF0ZSwgcmVzcG9uc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgTG9nLmRlYnVnKFwiTm8gaWRfdG9rZW4gdG8gdmFsaWRhdGVcIik7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIF92YWxpZGF0ZUlkVG9rZW5BbmRBY2Nlc3NUb2tlbihzdGF0ZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiUmVzcG9uc2VWYWxpZGF0b3IuX3ZhbGlkYXRlSWRUb2tlbkFuZEFjY2Vzc1Rva2VuXCIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZUlkVG9rZW4oc3RhdGUsIHJlc3BvbnNlKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZUFjY2Vzc1Rva2VuKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3ZhbGlkYXRlSWRUb2tlbihzdGF0ZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiUmVzcG9uc2VWYWxpZGF0b3IuX3ZhbGlkYXRlSWRUb2tlblwiKTtcblxuICAgICAgICBpZiAoIXN0YXRlLm5vbmNlKSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoXCJObyBub25jZSBvbiBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyBub25jZSBvbiBzdGF0ZVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGxldCBqd3QgPSB0aGlzLl9qb3NlVXRpbC5wYXJzZUp3dChyZXNwb25zZS5pZF90b2tlbik7XG4gICAgICAgIGlmICghand0IHx8ICFqd3QuaGVhZGVyIHx8ICFqd3QucGF5bG9hZCkge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIGlkX3Rva2VuXCIsIGp3dCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIGlkX3Rva2VuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZS5ub25jZSAhPT0gand0LnBheWxvYWQubm9uY2UpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIkludmFsaWQgbm9uY2UgaW4gaWRfdG9rZW5cIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBub25jZSBpbiBpZF90b2tlblwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2lkID0gand0LmhlYWRlci5raWQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhU2VydmljZS5nZXRJc3N1ZXIoKS50aGVuKGlzc3VlciA9PiB7XG4gICAgICAgICAgICBMb2cuZGVidWcoXCJSZWNlaXZlZCBpc3N1ZXJcIik7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXRhZGF0YVNlcnZpY2UuZ2V0U2lnbmluZ0tleXMoKS50aGVuKGtleXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgha2V5cykge1xuICAgICAgICAgICAgICAgICAgICBMb2cuZXJyb3IoXCJObyBzaWduaW5nIGtleXMgZnJvbSBtZXRhZGF0YVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIHNpZ25pbmcga2V5cyBmcm9tIG1ldGFkYXRhXCIpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJSZWNlaXZlZCBzaWduaW5nIGtleXNcIik7XG4gICAgICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgICAgICBpZiAoIWtpZCkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzID0gdGhpcy5fZmlsdGVyQnlBbGcoa2V5cywgand0LmhlYWRlci5hbGcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZy5lcnJvcihcIk5vIGtpZCBmb3VuZCBpbiBpZF90b2tlbiBhbmQgbW9yZSB0aGFuIG9uZSBrZXkgZm91bmQgaW4gbWV0YWRhdGFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm8ga2lkIGZvdW5kIGluIGlkX3Rva2VuIGFuZCBtb3JlIHRoYW4gb25lIGtleSBmb3VuZCBpbiBtZXRhZGF0YVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2lkIGlzIG1hbmRhdG9yeSBvbmx5IHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGtleXMgaW4gdGhlIHJlZmVyZW5jZWQgSldLIFNldCBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlIGh0dHA6Ly9vcGVuaWQubmV0L3NwZWNzL29wZW5pZC1jb25uZWN0LWNvcmUtMV8wLmh0bWwjU2lnbmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5c1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5cy5maWx0ZXIoa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkua2lkID09PSBraWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIExvZy5lcnJvcihcIk5vIGtleSBtYXRjaGluZyBraWQgb3IgYWxnIGZvdW5kIGluIHNpZ25pbmcga2V5c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIGtleSBtYXRjaGluZyBraWQgb3IgYWxnIGZvdW5kIGluIHNpZ25pbmcga2V5c1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGF1ZGllbmNlID0gc3RhdGUuY2xpZW50X2lkO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxldCBjbG9ja1NrZXdJblNlY29uZHMgPSB0aGlzLl9zZXR0aW5ncy5jbG9ja1NrZXc7XG4gICAgICAgICAgICAgICAgTG9nLmRlYnVnKFwiVmFsaWRhaW5nIEpXVDsgdXNpbmcgY2xvY2sgc2tldyAoaW4gc2Vjb25kcykgb2Y6IFwiLCBjbG9ja1NrZXdJblNlY29uZHMpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pvc2VVdGlsLnZhbGlkYXRlSnd0KHJlc3BvbnNlLmlkX3Rva2VuLCBrZXksIGlzc3VlciwgYXVkaWVuY2UsIGNsb2NrU2tld0luU2Vjb25kcykudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJKV1QgdmFsaWRhdGlvbiBzdWNjZXNzZnVsXCIpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqd3QucGF5bG9hZC5zdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZy5lcnJvcihcIk5vIHN1YiBwcmVzZW50IGluIGlkX3Rva2VuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIHN1YiBwcmVzZW50IGluIGlkX3Rva2VuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnByb2ZpbGUgPSBqd3QucGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfZmlsdGVyQnlBbGcoa2V5cywgYWxnKXtcbiAgICAgICAgTG9nLmRlYnVnKFwiUmVzcG9uc2VWYWxpZGF0b3IuX2ZpbHRlckJ5QWxnXCIsIGFsZyk7XG5cbiAgICAgICAgdmFyIGt0eSA9IG51bGw7XG4gICAgICAgIGlmIChhbGcuc3RhcnRzV2l0aChcIlJTXCIpKSB7XG4gICAgICAgICAgICBrdHkgPSBcIlJTQVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsZy5zdGFydHNXaXRoKFwiUFNcIikpIHtcbiAgICAgICAgICAgIGt0eSA9IFwiUFNcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbGcuc3RhcnRzV2l0aChcIkVTXCIpKSB7XG4gICAgICAgICAgICBrdHkgPSBcIkVDXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBMb2cuZGVidWcoXCJhbGcgbm90IHN1cHBvcnRlZDogXCIsIGFsZyk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIExvZy5kZWJ1ZyhcIkxvb2tpbmcgZm9yIGtleXMgdGhhdCBtYXRjaCBrdHk6IFwiLCBrdHkpO1xuXG4gICAgICAgIGtleXMgPSBrZXlzLmZpbHRlcihrZXkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGtleS5rdHkgPT09IGt0eTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgTG9nLmRlYnVnKFwiTnVtYmVyIG9mIGtleXMgdGhhdCBtYXRjaCBrdHk6IFwiLCBrdHksIGtleXMubGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG5cbiAgICBfdmFsaWRhdGVBY2Nlc3NUb2tlbihyZXNwb25zZSkge1xuICAgICAgICBMb2cuZGVidWcoXCJSZXNwb25zZVZhbGlkYXRvci5fdmFsaWRhdGVBY2Nlc3NUb2tlblwiKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLnByb2ZpbGUpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIk5vIHByb2ZpbGUgbG9hZGVkIGZyb20gaWRfdG9rZW5cIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm8gcHJvZmlsZSBsb2FkZWQgZnJvbSBpZF90b2tlblwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlc3BvbnNlLnByb2ZpbGUuYXRfaGFzaCkge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiTm8gYXRfaGFzaCBpbiBpZF90b2tlblwiKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyBhdF9oYXNoIGluIGlkX3Rva2VuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzcG9uc2UuaWRfdG9rZW4pIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIk5vIGlkX3Rva2VuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIGlkX3Rva2VuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBqd3QgPSB0aGlzLl9qb3NlVXRpbC5wYXJzZUp3dChyZXNwb25zZS5pZF90b2tlbik7XG4gICAgICAgIGlmICghand0IHx8ICFqd3QuaGVhZGVyKSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgaWRfdG9rZW5cIiwgand0KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgaWRfdG9rZW5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhc2hBbGcgPSBqd3QuaGVhZGVyLmFsZztcbiAgICAgICAgaWYgKCFoYXNoQWxnIHx8IGhhc2hBbGcubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoXCJVbnN1cHBvcnRlZCBhbGc6XCIsIGhhc2hBbGcpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGFsZzogXCIgKyBoYXNoQWxnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFzaEJpdHMgPSBoYXNoQWxnLnN1YnN0cigyLCAzKTtcbiAgICAgICAgaWYgKCFoYXNoQml0cykge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiVW5zdXBwb3J0ZWQgYWxnOlwiLCBoYXNoQWxnLCBoYXNoQml0cyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgYWxnOiBcIiArIGhhc2hBbGcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc2hCaXRzID0gcGFyc2VJbnQoaGFzaEJpdHMpO1xuICAgICAgICBpZiAoaGFzaEJpdHMgIT09IDI1NiAmJiBoYXNoQml0cyAhPT0gMzg0ICYmIGhhc2hCaXRzICE9PSA1MTIpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIlVuc3VwcG9ydGVkIGFsZzpcIiwgaGFzaEFsZywgaGFzaEJpdHMpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGFsZzogXCIgKyBoYXNoQWxnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2hhID0gXCJzaGFcIiArIGhhc2hCaXRzO1xuICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2pvc2VVdGlsLmhhc2hTdHJpbmcocmVzcG9uc2UuYWNjZXNzX3Rva2VuLCBzaGEpO1xuICAgICAgICBpZiAoIWhhc2gpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcImFjY2Vzc190b2tlbiBoYXNoIGZhaWxlZDpcIiwgc2hhKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJGYWlsZWQgdG8gdmFsaWRhdGUgYXRfaGFzaFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVmdCA9IGhhc2guc3Vic3RyKDAsIGhhc2gubGVuZ3RoIC8gMik7XG4gICAgICAgIHZhciBsZWZ0X2I2NHUgPSB0aGlzLl9qb3NlVXRpbC5oZXhUb0Jhc2U2NFVybChsZWZ0KTtcbiAgICAgICAgaWYgKGxlZnRfYjY0dSAhPT0gcmVzcG9uc2UucHJvZmlsZS5hdF9oYXNoKSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoXCJGYWlsZWQgdG8gdmFsaWRhdGUgYXRfaGFzaFwiLCBsZWZ0X2I2NHUsIHJlc3BvbnNlLnByb2ZpbGUuYXRfaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiRmFpbGVkIHRvIHZhbGlkYXRlIGF0X2hhc2hcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9SZXNwb25zZVZhbGlkYXRvci5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBMb2cgZnJvbSAnLi9Mb2cnO1xuaW1wb3J0IEpzb25TZXJ2aWNlIGZyb20gJy4vSnNvblNlcnZpY2UnO1xuXG5jb25zdCBPaWRjTWV0YWRhdGFVcmxQYXRoID0gJy53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWV0YWRhdGFTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncywgSnNvblNlcnZpY2VDdG9yID0gSnNvblNlcnZpY2UpIHtcbiAgICAgICAgaWYgKCFzZXR0aW5ncykge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiTm8gc2V0dGluZ3MgcGFzc2VkIHRvIE1ldGFkYXRhU2VydmljZVwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNldHRpbmdzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5fanNvblNlcnZpY2UgPSBuZXcgSnNvblNlcnZpY2VDdG9yKCk7XG4gICAgfVxuXG4gICAgZ2V0IG1ldGFkYXRhVXJsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21ldGFkYXRhVXJsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MubWV0YWRhdGFVcmwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXRhZGF0YVVybCA9IHRoaXMuX3NldHRpbmdzLm1ldGFkYXRhVXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWV0YWRhdGFVcmwgPSB0aGlzLl9zZXR0aW5ncy5hdXRob3JpdHk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWV0YWRhdGFVcmwgJiYgdGhpcy5fbWV0YWRhdGFVcmwuaW5kZXhPZihPaWRjTWV0YWRhdGFVcmxQYXRoKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21ldGFkYXRhVXJsW3RoaXMuX21ldGFkYXRhVXJsLmxlbmd0aCAtIDFdICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhVXJsICs9ICcvJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRhZGF0YVVybCArPSBPaWRjTWV0YWRhdGFVcmxQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRhZGF0YVVybDtcbiAgICB9XG5cbiAgICBnZXRNZXRhZGF0YSgpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiTWV0YWRhdGFTZXJ2aWNlLmdldE1ldGFkYXRhXCIpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tZXRhZGF0YSkge1xuICAgICAgICAgICAgTG9nLmRlYnVnKFwiUmV0dXJuaW5nIG1ldGFkYXRhIGZyb20gc2V0dGluZ3NcIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3NldHRpbmdzLm1ldGFkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5tZXRhZGF0YVVybCkge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiTm8gYXV0aG9yaXR5IG9yIG1ldGFkYXRhVXJsIGNvbmZpZ3VyZWQgb24gc2V0dGluZ3NcIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm8gYXV0aG9yaXR5IG9yIG1ldGFkYXRhVXJsIGNvbmZpZ3VyZWQgb24gc2V0dGluZ3NcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgTG9nLmRlYnVnKFwiZ2V0dGluZyBtZXRhZGF0YSBmcm9tXCIsIHRoaXMubWV0YWRhdGFVcmwpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9qc29uU2VydmljZS5nZXRKc29uKHRoaXMubWV0YWRhdGFVcmwpXG4gICAgICAgICAgICAudGhlbihtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgTG9nLmRlYnVnKFwianNvbiByZWNlaXZlZFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXR0aW5ncy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBnZXRJc3N1ZXIoKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIk1ldGFkYXRhU2VydmljZS5nZXRJc3N1ZXJcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRNZXRhZGF0YVByb3BlcnR5KFwiaXNzdWVyXCIpO1xuICAgIH1cblxuICAgIGdldEF1dGhvcml6YXRpb25FbmRwb2ludCgpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiTWV0YWRhdGFTZXJ2aWNlLmdldEF1dGhvcml6YXRpb25FbmRwb2ludFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1ldGFkYXRhUHJvcGVydHkoXCJhdXRob3JpemF0aW9uX2VuZHBvaW50XCIpO1xuICAgIH1cblxuICAgIGdldFVzZXJJbmZvRW5kcG9pbnQoKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIk1ldGFkYXRhU2VydmljZS5nZXRVc2VySW5mb0VuZHBvaW50XCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcInVzZXJpbmZvX2VuZHBvaW50XCIpO1xuICAgIH1cblxuICAgIGdldFRva2VuRW5kcG9pbnQoKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIk1ldGFkYXRhU2VydmljZS5nZXRUb2tlbkVuZHBvaW50XCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcInRva2VuX2VuZHBvaW50XCIsIHRydWUpO1xuICAgIH1cbiAgICBcbiAgICBnZXRDaGVja1Nlc3Npb25JZnJhbWUoKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIk1ldGFkYXRhU2VydmljZS5nZXRDaGVja1Nlc3Npb25JZnJhbWVcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRNZXRhZGF0YVByb3BlcnR5KFwiY2hlY2tfc2Vzc2lvbl9pZnJhbWVcIiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZ2V0RW5kU2Vzc2lvbkVuZHBvaW50KCkge1xuICAgICAgICBMb2cuZGVidWcoXCJNZXRhZGF0YVNlcnZpY2UuZ2V0RW5kU2Vzc2lvbkVuZHBvaW50XCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcImVuZF9zZXNzaW9uX2VuZHBvaW50XCIsIHRydWUpO1xuICAgIH1cblxuICAgIGdldFJldm9jYXRpb25FbmRwb2ludCgpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiTWV0YWRhdGFTZXJ2aWNlLmdldFJldm9jYXRpb25FbmRwb2ludFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1ldGFkYXRhUHJvcGVydHkoXCJyZXZvY2F0aW9uX2VuZHBvaW50XCIsIHRydWUpO1xuICAgIH1cblxuICAgIF9nZXRNZXRhZGF0YVByb3BlcnR5KG5hbWUsIG9wdGlvbmFsPWZhbHNlKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIk1ldGFkYXRhU2VydmljZS5fZ2V0TWV0YWRhdGFQcm9wZXJ0eVwiLCBuYW1lKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNZXRhZGF0YSgpLnRoZW4obWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgTG9nLmRlYnVnKFwibWV0YWRhdGEgcmVjaWV2ZWRcIik7XG5cbiAgICAgICAgICAgIGlmIChtZXRhZGF0YVtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nLndhcm4oXCJNZXRhZGF0YSBkb2VzIG5vdCBjb250YWluIG9wdGlvbmFsIHByb3BlcnR5IFwiICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBMb2cuZXJyb3IoXCJNZXRhZGF0YSBkb2VzIG5vdCBjb250YWluIHByb3BlcnR5IFwiICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGFkYXRhIGRvZXMgbm90IGNvbnRhaW4gcHJvcGVydHkgXCIgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YVtuYW1lXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0U2lnbmluZ0tleXMoKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIk1ldGFkYXRhU2VydmljZS5nZXRTaWduaW5nS2V5c1wiKTtcblxuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3Muc2lnbmluZ0tleXMpIHtcbiAgICAgICAgICAgIExvZy5kZWJ1ZyhcIlJldHVybmluZyBzaWduaW5nS2V5cyBmcm9tIHNldHRpbmdzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9zZXR0aW5ncy5zaWduaW5nS2V5cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcImp3a3NfdXJpXCIpLnRoZW4oandrc191cmkgPT4ge1xuICAgICAgICAgICAgTG9nLmRlYnVnKFwiandrc191cmkgcmVjZWl2ZWRcIiwgandrc191cmkpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fanNvblNlcnZpY2UuZ2V0SnNvbihqd2tzX3VyaSkudGhlbihrZXlTZXQgPT4ge1xuICAgICAgICAgICAgICAgIExvZy5kZWJ1ZyhcImtleSBzZXQgcmVjZWl2ZWRcIiwga2V5U2V0KTtcblxuICAgICAgICAgICAgICAgIGlmICgha2V5U2V0LmtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nLmVycm9yKFwiTWlzc2luZyBrZXlzIG9uIGtleXNldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBrZXlzIG9uIGtleXNldFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXR0aW5ncy5zaWduaW5nS2V5cyA9IGtleVNldC5rZXlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncy5zaWduaW5nS2V5cztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvTWV0YWRhdGFTZXJ2aWNlLmpzIiwiLy8gQ29weXJpZ2h0IChjKSBCcm9jayBBbGxlbiAmIERvbWluaWNrIEJhaWVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuaW1wb3J0IExvZyBmcm9tICcuL0xvZyc7XG5pbXBvcnQgR2xvYmFsIGZyb20gJy4vR2xvYmFsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSnNvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKFhNTEh0dHBSZXF1ZXN0Q3RvciA9IEdsb2JhbC5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICB0aGlzLl9YTUxIdHRwUmVxdWVzdCA9IFhNTEh0dHBSZXF1ZXN0Q3RvcjtcbiAgICB9XG4gICAgXG4gICAgZ2V0SnNvbih1cmwsIHRva2VuKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIkpzb25TZXJ2aWNlLmdldEpzb25cIiwgdXJsKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghdXJsKXtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIk5vIHVybCBwYXNzZWRcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1cmxcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciByZXEgPSBuZXcgdGhpcy5fWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcS5vcGVuKCdHRVQnLCB1cmwpO1xuXG4gICAgICAgICAgICByZXEub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgTG9nLmRlYnVnKFwiSFRUUCByZXNwb25zZSByZWNlaXZlZCwgc3RhdHVzXCIsIHJlcS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoSlNPTi5wYXJzZShyZXEucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZy5lcnJvcihcIkVycm9yIHBhcnNpbmcgSlNPTiByZXNwb25zZVwiLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoRXJyb3IocmVxLnN0YXR1c1RleHQgKyBcIiAoXCIgKyByZXEuc3RhdHVzICsgXCIpXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIExvZy5lcnJvcihcIm5ldHdvcmsgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KEVycm9yKFwiTmV0d29yayBFcnJvclwiKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJ0b2tlbiBwYXNzZWQsIHNldHRpbmcgQXV0aG9yaXphdGlvbiBoZWFkZXJcIik7XG4gICAgICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJBdXRob3JpemF0aW9uXCIsIFwiQmVhcmVyIFwiICsgdG9rZW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXEuc2VuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0pzb25TZXJ2aWNlLmpzIiwiLy8gQ29weXJpZ2h0IChjKSBCcm9jayBBbGxlbiAmIERvbWluaWNrIEJhaWVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuaW1wb3J0IEpzb25TZXJ2aWNlIGZyb20gJy4vSnNvblNlcnZpY2UnO1xuaW1wb3J0IE1ldGFkYXRhU2VydmljZSBmcm9tICcuL01ldGFkYXRhU2VydmljZSc7XG5pbXBvcnQgTG9nIGZyb20gJy4vTG9nJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlckluZm9TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncywgSnNvblNlcnZpY2VDdG9yID0gSnNvblNlcnZpY2UsIE1ldGFkYXRhU2VydmljZUN0b3IgPSBNZXRhZGF0YVNlcnZpY2UpIHtcbiAgICAgICAgaWYgKCFzZXR0aW5ncykge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiTm8gc2V0dGluZ3MgcGFzc2VkIHRvIFVzZXJJbmZvU2VydmljZVwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNldHRpbmdzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5fanNvblNlcnZpY2UgPSBuZXcgSnNvblNlcnZpY2VDdG9yKCk7XG4gICAgICAgIHRoaXMuX21ldGFkYXRhU2VydmljZSA9IG5ldyBNZXRhZGF0YVNlcnZpY2VDdG9yKHRoaXMuX3NldHRpbmdzKTtcbiAgICB9XG5cbiAgICBnZXRDbGFpbXModG9rZW4pIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiVXNlckluZm9TZXJ2aWNlLmdldENsYWltc1wiKTtcblxuICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoXCJObyB0b2tlbiBwYXNzZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiQSB0b2tlbiBpcyByZXF1aXJlZFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGFTZXJ2aWNlLmdldFVzZXJJbmZvRW5kcG9pbnQoKS50aGVuKHVybCA9PiB7XG4gICAgICAgICAgICBMb2cuZGVidWcoXCJyZWNlaXZlZCB1c2VyaW5mbyB1cmxcIiwgdXJsKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzb25TZXJ2aWNlLmdldEpzb24odXJsLCB0b2tlbikudGhlbihjbGFpbXMgPT4ge1xuICAgICAgICAgICAgICAgIExvZy5kZWJ1ZyhcImNsYWltcyByZWNlaXZlZFwiLCBjbGFpbXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGFpbXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1VzZXJJbmZvU2VydmljZS5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBMb2cgZnJvbSAnLi9Mb2cnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFcnJvclJlc3BvbnNlIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHtlcnJvciwgZXJyb3JfZGVzY3JpcHRpb24sIGVycm9yX3VyaSwgc3RhdGV9PXt9XG4gICAgKSB7XG4gICAgICAgICBpZiAoIWVycm9yKXtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIk5vIGVycm9yIHBhc3NlZCB0byBFcnJvclJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN1cGVyKGVycm9yX2Rlc2NyaXB0aW9uIHx8IGVycm9yKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubmFtZSA9IFwiRXJyb3JSZXNwb25zZVwiOyBcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5lcnJvcl9kZXNjcmlwdGlvbiA9IGVycm9yX2Rlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmVycm9yX3VyaSA9IGVycm9yX3VyaTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvRXJyb3JSZXNwb25zZS5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbi8vIGltcG9ydCB7IGp3cywgS0VZVVRJTCBhcyBLZXlVdGlsLCBYNTA5LCBjcnlwdG8sIGhleHRvYjY0dSB9IGZyb20gJ2pzcnNhc2lnbic7XG5pbXBvcnQgTG9nIGZyb20gJy4vTG9nJztcbmltcG9ydCBJZFRva2VuVmVyaWZpZXIgZnJvbSAnaWR0b2tlbi12ZXJpZmllcidcblxuY29uc3QgQWxsb3dlZFNpZ25pbmdBbGdzID0gWydSUzI1NicsICdSUzM4NCcsICdSUzUxMicsICdQUzI1NicsICdQUzM4NCcsICdQUzUxMicsICdFUzI1NicsICdFUzM4NCcsICdFUzUxMiddO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBKb3NlVXRpbCB7XG5cbiAgICBzdGF0aWMgcGFyc2VKd3Qoand0KSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIkpvc2VVdGlsLnBhcnNlSnd0XCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZEFsZzogJ1JTMjU2J1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWRUb2tlblZlcmlmaWVyID0gbmV3IElkVG9rZW5WZXJpZmllcihwYXJhbWV0ZXJzKVxuXG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IGlkVG9rZW5WZXJpZmllci5kZWNvZGUoand0KVxuICAgICAgICAgICAgaWYgKHRva2VuLmhlYWRlciAmJiB0b2tlbi5wYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiB0b2tlbi5oZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHRva2VuLnBheWxvYWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB2YWxpZGF0ZUp3dChqd3QsIGtleSwgaXNzdWVyLCBhdWRpZW5jZSwgY2xvY2tTa2V3LCBub3csIGNiKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIkpvc2VVdGlsLnZhbGlkYXRlSnd0XCIpO1xuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgIC8vIGlmIChrZXkua3R5ID09PSBcIlJTQVwiKSB7XG4gICAgICAgICAgICAvLyAgICAgaWYgKGtleS5lICYmIGtleS5uKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIGtleSA9IEtleVV0aWwuZ2V0S2V5KGtleSk7XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gICAgIGVsc2UgaWYgKGtleS54NWMgJiYga2V5Lng1Yy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAga2V5ID0gS2V5VXRpbC5nZXRLZXkoWDUwOS5nZXRQdWJsaWNLZXlGcm9tQ2VydFBFTShrZXkueDVjWzBdKSk7XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgICAgICBMb2cuZXJyb3IoXCJSU0Ega2V5IG1pc3Npbmcga2V5IG1hdGVyaWFsXCIsIGtleSk7XG4gICAgICAgICAgICAvLyAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJSU0Ega2V5IG1pc3Npbmcga2V5IG1hdGVyaWFsXCIpKTtcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBlbHNlIGlmIChrZXkua3R5ID09PSBcIkVDXCIpIHtcbiAgICAgICAgICAgIC8vICAgICBpZiAoa2V5LmNydiAmJiBrZXkueCAmJiBrZXkueSkge1xuICAgICAgICAgICAgLy8gICAgICAgICBrZXkgPSBLZXlVdGlsLmdldEtleShrZXkpO1xuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgTG9nLmVycm9yKFwiRUMga2V5IG1pc3Npbmcga2V5IG1hdGVyaWFsXCIsIGtleSk7XG4gICAgICAgICAgICAvLyAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJFQyBrZXkgbWlzc2luZyBrZXkgbWF0ZXJpYWxcIikpO1xuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgIExvZy5lcnJvcihcIlVuc3VwcG9ydGVkIGtleSB0eXBlXCIsIGtleSAmJiBrZXkua3R5KTtcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQga2V5IHR5cGU6IFwiICsga2V5ICYmIGtleS5rdHkpKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByZXR1cm4gSm9zZVV0aWwuX3ZhbGlkYXRlSnd0KGp3dCwga2V5LCBpc3N1ZXIsIGF1ZGllbmNlLCBjbG9ja1NrZXcsIG5vdyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihlICYmIGUubWVzc2FnZSB8fCBlKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIkpXVCB2YWxpZGF0aW9uIGZhaWxlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBfdmFsaWRhdGVKd3Qoand0LCBrZXksIGlzc3VlciwgYXVkaWVuY2UsIGNsb2NrU2tldywgbm93KSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIkpvc2VVdGlsLl92YWxpZGF0ZUp3dFwiKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIGlzc3VlcixcbiAgICAgICAgICAgIGF1ZGllbmNlLFxuICAgICAgICAgICAgbGVld2F5OiBjbG9ja1NrZXcsXG4gICAgICAgICAgICBleHBlY3RlZEFsZzogJ1JTMjU2J1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkVG9rZW5WZXJpZmllciA9IG5ldyBJZFRva2VuVmVyaWZpZXIocGFyYW1ldGVycylcblxuICAgICAgICBpZiAoIWNsb2NrU2tldykge1xuICAgICAgICAgICAgY2xvY2tTa2V3ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbm93KSB7XG4gICAgICAgICAgICBub3cgPSBwYXJzZUludChEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF5bG9hZCA9IEpvc2VVdGlsLnBhcnNlSnd0KGp3dCkucGF5bG9hZDtcblxuICAgICAgICBpZiAoIXBheWxvYWQuaXNzKSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoXCJpc3N1ZXIgd2FzIG5vdCBwcm92aWRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpc3N1ZXIgd2FzIG5vdCBwcm92aWRlZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBheWxvYWQuaXNzICE9PSBpc3N1ZXIpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIkludmFsaWQgaXNzdWVyIGluIHRva2VuXCIsIHBheWxvYWQuaXNzKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIGlzc3VlciBpbiB0b2tlbjogXCIgKyBwYXlsb2FkLmlzcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXlsb2FkLmF1ZCkge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiYXVkIHdhcyBub3QgcHJvdmlkZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiYXVkIHdhcyBub3QgcHJvdmlkZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZEF1ZGllbmNlID0gcGF5bG9hZC5hdWQgPT09IGF1ZGllbmNlIHx8IChBcnJheS5pc0FycmF5KHBheWxvYWQuYXVkKSAmJiBwYXlsb2FkLmF1ZC5pbmRleE9mKGF1ZGllbmNlKSA+PSAwKTsgXG4gICAgICAgIGlmICghdmFsaWRBdWRpZW5jZSkge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiSW52YWxpZCBhdWRpZW5jZSBpbiB0b2tlblwiLCBwYXlsb2FkLmF1ZCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBhdWRpZW5jZSBpbiB0b2tlbjogXCIgKyBwYXlsb2FkLmF1ZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvd2VyTm93ID0gbm93ICsgY2xvY2tTa2V3O1xuICAgICAgICB2YXIgdXBwZXJOb3cgPSBub3cgLSBjbG9ja1NrZXc7XG5cbiAgICAgICAgaWYgKCFwYXlsb2FkLmlhdCkge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiaWF0IHdhcyBub3QgcHJvdmlkZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaWF0IHdhcyBub3QgcHJvdmlkZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dlck5vdyA8IHBheWxvYWQuaWF0KSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoXCJpYXQgaXMgaW4gdGhlIGZ1dHVyZVwiLCBwYXlsb2FkLmlhdCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaWF0IGlzIGluIHRoZSBmdXR1cmU6IFwiICsgcGF5bG9hZC5pYXQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXlsb2FkLm5iZiAmJiBsb3dlck5vdyA8IHBheWxvYWQubmJmKSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoXCJuYmYgaXMgaW4gdGhlIGZ1dHVyZVwiLCBwYXlsb2FkLm5iZik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibmJmIGlzIGluIHRoZSBmdXR1cmU6IFwiICsgcGF5bG9hZC5uYmYpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGF5bG9hZC5leHApIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcImV4cCB3YXMgbm90IHByb3ZpZGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImV4cCB3YXMgbm90IHByb3ZpZGVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF5bG9hZC5leHAgPCB1cHBlck5vdykge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiZXhwIGlzIGluIHRoZSBwYXN0XCIsIHBheWxvYWQuZXhwKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJleHAgaXMgaW4gdGhlIHBhc3Q6XCIgKyBwYXlsb2FkLmV4cCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGlmICghandzLkpXUy52ZXJpZnkoand0LCBrZXksIEFsbG93ZWRTaWduaW5nQWxncykpIHtcbiAgICAgICAgICAgIGlmICghaWRUb2tlblZlcmlmaWVyLnZlcmlmeShqd3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInNpZ25hdHVyZSB2YWxpZGF0aW9uIGZhaWxlZFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihlICYmIGUubWVzc2FnZSB8fCBlKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJzaWduYXR1cmUgdmFsaWRhdGlvbiBmYWlsZWRcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBoYXNoU3RyaW5nKHZhbHVlLCBhbGcpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiSm9zZVV0aWwuaGFzaFN0cmluZ1wiLCB2YWx1ZSwgYWxnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBjcnlwdG8uVXRpbC5oYXNoU3RyaW5nKHZhbHVlLCBhbGcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgaGV4VG9CYXNlNjRVcmwodmFsdWUpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiSm9zZVV0aWwuaGV4VG9CYXNlNjRVcmxcIiwgdmFsdWUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGhleHRvYjY0dSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Kb3NlVXRpbC5qcyIsInZhciBzaGEyNTYgPSByZXF1aXJlKCdjcnlwdG8tanMvc2hhMjU2Jyk7XG52YXIgY3J5cHRvQmFzZTY0ID0gcmVxdWlyZSgnY3J5cHRvLWpzL2VuYy1iYXNlNjQnKTtcbnZhciBjcnlwdG9IZXggPSByZXF1aXJlKCdjcnlwdG8tanMvZW5jLWhleCcpO1xuXG52YXIgUlNBVmVyaWZpZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMvcnNhLXZlcmlmaWVyJyk7XG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Jhc2U2NCcpO1xudmFyIGp3a3MgPSByZXF1aXJlKCcuL2hlbHBlcnMvandrcycpO1xudmFyIGVycm9yID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Vycm9yJyk7XG52YXIgRHVtbXlDYWNoZSA9IHJlcXVpcmUoJy4vaGVscGVycy9kdW1teS1jYWNoZScpO1xudmFyIHN1cHBvcnRlZEFsZ3MgPSBbJ1JTMjU2J107XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZF90b2tlbiB2ZXJpZmllclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtZXRlcnMuaXNzdWVyIG5hbWUgb2YgdGhlIGlzc3VlciBvZiB0aGUgdG9rZW5cbiAqIHRoYXQgc2hvdWxkIG1hdGNoIHRoZSBgaXNzYCBjbGFpbSBpbiB0aGUgaWRfdG9rZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbWV0ZXJzLmF1ZGllbmNlIGlkZW50aWZpZXMgdGhlIHJlY2lwaWVudHMgdGhhdCB0aGUgSldUIGlzIGludGVuZGVkIGZvclxuICogYW5kIHNob3VsZCBtYXRjaCB0aGUgYGF1ZGAgY2xhaW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1ldGVycy5qd2tzQ2FjaGVdIGNhY2hlIGZvciBKU09OIFdlYiBUb2tlbiBLZXlzLiBCeSBkZWZhdWx0IGl0IGhhcyBubyBjYWNoZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbWV0ZXJzLmp3a3NVUkldIEEgdmFsaWQsIGRpcmVjdCBVUkkgdG8gZmV0Y2ggdGhlIEpTT04gV2ViIEtleSBTZXQgKEpXS1MpLlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbWV0ZXJzLmV4cGVjdGVkQWxnPSdSUzI1NiddIGFsZ29yaXRobSBpbiB3aGljaCB0aGUgaWRfdG9rZW4gd2FzIHNpZ25lZFxuICogYW5kIHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbWV0ZXJzLmxlZXdheT0wXSBudW1iZXIgb2Ygc2Vjb25kcyB0aGF0IHRoZSBjbG9jayBjYW4gYmUgb3V0IG9mIHN5bmNcbiAqIHdoaWxlIHZhbGlkYXRpbmcgZXhwaXJhdGlvbiBvZiB0aGUgaWRfdG9rZW5cbiAqL1xuZnVuY3Rpb24gSWRUb2tlblZlcmlmaWVyKHBhcmFtZXRlcnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHBhcmFtZXRlcnMgfHwge307XG5cbiAgICB0aGlzLmp3a3NDYWNoZSA9IG9wdGlvbnMuandrc0NhY2hlIHx8IG5ldyBEdW1teUNhY2hlKCk7XG4gICAgdGhpcy5leHBlY3RlZEFsZyA9IG9wdGlvbnMuZXhwZWN0ZWRBbGcgfHwgJ1JTMjU2JztcbiAgICB0aGlzLmlzc3VlciA9IG9wdGlvbnMuaXNzdWVyO1xuICAgIHRoaXMuYXVkaWVuY2UgPSBvcHRpb25zLmF1ZGllbmNlO1xuICAgIHRoaXMubGVld2F5ID0gb3B0aW9ucy5sZWV3YXkgfHwgMDtcbiAgICB0aGlzLl9fZGlzYWJsZUV4cGlyYXRpb25DaGVjayA9IG9wdGlvbnMuX19kaXNhYmxlRXhwaXJhdGlvbkNoZWNrIHx8IGZhbHNlO1xuICAgIHRoaXMuandrc1VSSSA9IG9wdGlvbnMuandrc1VSSTtcblxuICAgIGlmICh0aGlzLmxlZXdheSA8IDAgfHwgdGhpcy5sZWV3YXkgPiA2MCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3IuQ29uZmlndXJhdGlvbkVycm9yKCdUaGUgbGVld2F5IHNob3VsZCBiZSBwb3NpdGl2ZSBhbmQgbG93ZXIgdGhhbiBhIG1pbnV0ZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydGVkQWxncy5pbmRleE9mKHRoaXMuZXhwZWN0ZWRBbGcpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3IuQ29uZmlndXJhdGlvbkVycm9yKCdBbGdvcml0aG0gJyArIHRoaXMuZXhwZWN0ZWRBbGcgK1xuICAgICAgICAgICAgJyBpcyBub3Qgc3VwcG9ydGVkLiAoRXhwZWN0ZWQgYWxnczogWycgKyBzdXBwb3J0ZWRBbGdzLmpvaW4oJywnKSArICddKScpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Vycm9yfSBbZXJyXSBlcnJvciByZXR1cm5lZCBpZiB0aGUgdmVyaWZ5IGNhbm5vdCBiZSBwZXJmb3JtZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0YXR1c10gaWYgdGhlIHRva2VuIGlzIHZhbGlkIG9yIG5vdFxuICovXG5cbi8qKlxuICogVmVyaWZpZXMgYW4gaWRfdG9rZW5cbiAqXG4gKiBJdCB3aWxsIHZhbGlkYXRlOlxuICogLSBzaWduYXR1cmUgYWNjb3JkaW5nIHRvIHRoZSBhbGdvcml0aG0gY29uZmlndXJlZCBpbiB0aGUgdmVyaWZpZXIuXG4gKiAtIGlmIG5vbmNlIGlzIHByZXNlbnQgYW5kIG1hdGNoZXMgdGhlIG9uZSBwcm92aWRlZFxuICogLSBpZiBgaXNzYCBhbmQgYGF1ZGAgY2xhaW1zIG1hdGNoZXMgdGhlIGNvbmZpZ3VyZWQgaXNzdWVyIGFuZCBhdWRpZW5jZVxuICogLSBpZiB0b2tlbiBpcyBub3QgZXhwaXJlZCBhbmQgdmFsaWQgKGlmIHRoZSBgbmJmYCBjbGFpbSBpcyBpbiB0aGUgcGFzdClcbiAqXG4gKiBAbWV0aG9kIHZlcmlmeVxuICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIGlkX3Rva2VuIHRvIHZlcmlmeVxuICogQHBhcmFtIHtTdHJpbmd9IFtub25jZV0gbm9uY2UgdmFsdWUgdGhhdCBzaG91bGQgbWF0Y2ggdGhlIG9uZSBpbiB0aGUgaWRfdG9rZW4gY2xhaW1zXG4gKi9cbklkVG9rZW5WZXJpZmllci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gKHRva2VuLCBub25jZSkge1xuICAgIHZhciBqd3QgPSB0aGlzLmRlY29kZSh0b2tlbik7XG5cbiAgICBpZiAoand0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGp3dCk7XG4gICAgfVxuXG4gICAgLyogZXNsaW50LWRpc2FibGUgdmFycy1vbi10b3AgKi9cbiAgICB2YXIgaGVhZEFuZFBheWxvYWQgPSBqd3QuZW5jb2RlZC5oZWFkZXIgKyAnLicgKyBqd3QuZW5jb2RlZC5wYXlsb2FkO1xuICAgIHZhciBzaWduYXR1cmUgPSBiYXNlNjQuZGVjb2RlVG9IRVgoand0LmVuY29kZWQuc2lnbmF0dXJlKTtcblxuICAgIHZhciBhbGcgPSBqd3QuaGVhZGVyLmFsZztcbiAgICB2YXIga2lkID0gand0LmhlYWRlci5raWQ7XG5cbiAgICB2YXIgYXVkID0gand0LnBheWxvYWQuYXVkO1xuICAgIHZhciBpc3MgPSBqd3QucGF5bG9hZC5pc3M7XG4gICAgdmFyIGV4cCA9IGp3dC5wYXlsb2FkLmV4cDtcbiAgICB2YXIgbmJmID0gand0LnBheWxvYWQubmJmO1xuICAgIHZhciB0bm9uY2UgPSBqd3QucGF5bG9hZC5ub25jZSB8fCBudWxsO1xuICAgIC8qIGVzbGludC1lbmFibGUgdmFycy1vbi10b3AgKi9cblxuICAgIGlmICh0aGlzLmlzc3VlciAhPT0gaXNzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgZXJyb3IuVG9rZW5WYWxpZGF0aW9uRXJyb3IoJ0lzc3VlciAnICsgaXNzICsgJyBpcyBub3QgdmFsaWQuJyksIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hdWRpZW5jZSAhPT0gYXVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgZXJyb3IuVG9rZW5WYWxpZGF0aW9uRXJyb3IoJ0F1ZGllbmNlICcgKyBhdWQgKyAnIGlzIG5vdCB2YWxpZC4nKSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV4cGVjdGVkQWxnICE9PSBhbGcpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvci5Ub2tlblZhbGlkYXRpb25FcnJvcignQWxnb3JpdGhtICcgKyBhbGcgK1xuICAgICAgICAgICAgJyBpcyBub3Qgc3VwcG9ydGVkLiAoRXhwZWN0ZWQgYWxnczogWycgKyBzdXBwb3J0ZWRBbGdzLmpvaW4oJywnKSArICddKScpLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKHRub25jZSAhPT0gbm9uY2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvci5Ub2tlblZhbGlkYXRpb25FcnJvcignTm9uY2UgZG9lcyBub3QgbWF0Y2guJyksIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgZXhwaXJhdGlvbkVycm9yID0gdGhpcy52ZXJpZnlFeHBBbmROYmYoZXhwLCBuYmYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHZhcnMtb24tdG9wXG5cbiAgICBpZiAoZXhwaXJhdGlvbkVycm9yKSB7XG4gICAgICAgIHJldHVybiBleHBpcmF0aW9uRXJyb3IsIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldFJzYVZlcmlmaWVyKGlzcywga2lkKVxuICAgICAgICAudGhlbihyc2FWZXJpZmllciA9PiB7XG4gICAgICAgICAgICBpZiAocnNhVmVyaWZpZXIudmVyaWZ5KGhlYWRBbmRQYXlsb2FkLCBzaWduYXR1cmUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShqd3QucGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IGVycm9yLlRva2VuVmFsaWRhdGlvbkVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZS4nKSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKVxuICAgICAgICB9KVxufTtcblxuLyoqXG4gKiBWZXJpZmllcyB0aGF0IHRoZSBgZXhwYCBhbmQgYG5iZmAgY2xhaW1zIGFyZSB2YWxpZCBpbiB0aGUgY3VycmVudCBtb21lbnQuXG4gKlxuICogQG1ldGhvZCB2ZXJpZnlFeHBBbmROYmZcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHAgdmFsdWUgb2YgYGV4cGAgY2xhaW1cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYmYgdmFsdWUgb2YgYG5iZmAgY2xhaW1cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIHRva2VuIGlzIHZhbGlkIGFjY29yZGluZyB0byBgZXhwYCBhbmQgYG5iZmBcbiAqL1xuSWRUb2tlblZlcmlmaWVyLnByb3RvdHlwZS52ZXJpZnlFeHBBbmROYmYgPSBmdW5jdGlvbiAoZXhwLCBuYmYpIHtcbiAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICB2YXIgZXhwRGF0ZSA9IG5ldyBEYXRlKDApO1xuICAgIHZhciBuYmZEYXRlID0gbmV3IERhdGUoMCk7XG5cbiAgICBpZiAodGhpcy5fX2Rpc2FibGVFeHBpcmF0aW9uQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZXhwRGF0ZS5zZXRVVENTZWNvbmRzKGV4cCArIHRoaXMubGVld2F5KTtcblxuICAgIGlmIChub3cgPiBleHBEYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgZXJyb3IuVG9rZW5WYWxpZGF0aW9uRXJyb3IoJ0V4cGlyZWQgdG9rZW4uJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuYmYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBuYmZEYXRlLnNldFVUQ1NlY29uZHMobmJmIC0gdGhpcy5sZWV3YXkpO1xuICAgIGlmIChub3cgPCBuYmZEYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgZXJyb3IuVG9rZW5WYWxpZGF0aW9uRXJyb3IoJ1RoZSB0b2tlbiBpcyBub3QgdmFsaWQgdW50aWwgbGF0ZXIgaW4gdGhlIGZ1dHVyZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIGNoZWNrIHlvdXIgY29tcHV0ZWQgY2xvY2suJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgdGhlIGBleHBgIGFuZCBgaWF0YCBjbGFpbXMgYXJlIHZhbGlkIGluIHRoZSBjdXJyZW50IG1vbWVudC5cbiAqXG4gKiBAbWV0aG9kIHZlcmlmeUV4cEFuZElhdFxuICogQHBhcmFtIHtTdHJpbmd9IGV4cCB2YWx1ZSBvZiBgZXhwYCBjbGFpbVxuICogQHBhcmFtIHtTdHJpbmd9IGlhdCB2YWx1ZSBvZiBgaWF0YCBjbGFpbVxuICogQHJldHVybiB7Ym9vbGVhbn0gaWYgdG9rZW4gaXMgdmFsaWQgYWNjb3JkaW5nIHRvIGBleHBgIGFuZCBgaWF0YFxuICovXG5JZFRva2VuVmVyaWZpZXIucHJvdG90eXBlLnZlcmlmeUV4cEFuZElhdCA9IGZ1bmN0aW9uIChleHAsIGlhdCkge1xuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIHZhciBleHBEYXRlID0gbmV3IERhdGUoMCk7XG4gICAgdmFyIGlhdERhdGUgPSBuZXcgRGF0ZSgwKTtcblxuICAgIGlmICh0aGlzLl9fZGlzYWJsZUV4cGlyYXRpb25DaGVjaykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBleHBEYXRlLnNldFVUQ1NlY29uZHMoZXhwICsgdGhpcy5sZWV3YXkpO1xuXG4gICAgaWYgKG5vdyA+IGV4cERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlcnJvci5Ub2tlblZhbGlkYXRpb25FcnJvcignRXhwaXJlZCB0b2tlbi4nKTtcbiAgICB9XG5cbiAgICBpYXREYXRlLnNldFVUQ1NlY29uZHMoaWF0IC0gdGhpcy5sZWV3YXkpO1xuXG4gICAgaWYgKG5vdyA8IGlhdERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlcnJvci5Ub2tlblZhbGlkYXRpb25FcnJvcignVGhlIHRva2VuIHdhcyBpc3N1ZWQgaW4gdGhlIGZ1dHVyZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIGNoZWNrIHlvdXIgY29tcHV0ZWQgY2xvY2suJyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuSWRUb2tlblZlcmlmaWVyLnByb3RvdHlwZS5nZXRSc2FWZXJpZmllciA9IGZ1bmN0aW9uIChpc3MsIGtpZCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGNhY2hla2V5ID0gaXNzICsga2lkO1xuXG4gICAgaWYgKCF0aGlzLmp3a3NDYWNoZS5oYXMoY2FjaGVrZXkpKSB7XG4gICAgICAgIGp3a3MuZ2V0SldLUyh7XG4gICAgICAgICAgICBqd2tzVVJJOiB0aGlzLmp3a3NVUkksXG4gICAgICAgICAgICBpc3M6IGlzcyxcbiAgICAgICAgICAgIGtpZDoga2lkXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihrZXlJbmZvID0+IHtcbiAgICAgICAgICAgICAgICBfdGhpcy5qd2tzQ2FjaGUuc2V0KGNhY2hla2V5LCBrZXlJbmZvKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwsIG5ldyBSU0FWZXJpZmllcihrZXlJbmZvLm1vZHVsdXMsIGtleUluZm8uZXhwKSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgIFByb21pc2UucmVqZWN0KGUpXG4gICAgICAgICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlJbmZvID0gdGhpcy5qd2tzQ2FjaGUuZ2V0KGNhY2hla2V5KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSB2YXJzLW9uLXRvcFxuICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbCwgbmV3IFJTQVZlcmlmaWVyKGtleUluZm8ubW9kdWx1cywga2V5SW5mby5leHApKTtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogQHR5cGVkZWYgRGVjb2RlZFRva2VuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtPYmplY3R9IGhlYWRlciAtIGNvbnRlbnQgb2YgdGhlIEpXVCBoZWFkZXIuXG4gKiBAcHJvcGVydHkge09iamVjdH0gcGF5bG9hZCAtIHRva2VuIGNsYWltcy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBlbmNvZGVkIC0gZW5jb2RlZCBwYXJ0cyBvZiB0aGUgdG9rZW4uXG4gKi9cblxuLyoqXG4gKiBEZWNvZGVzIGEgd2VsbCBmb3JtZWQgSldUIHdpdGhvdXQgYW55IHZlcmlmaWNhdGlvblxuICpcbiAqIEBtZXRob2QgZGVjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gZGVjb2RlcyB0aGUgdG9rZW5cbiAqIEByZXR1cm4ge0RlY29kZWRUb2tlbn0gaWYgdG9rZW4gaXMgdmFsaWQgYWNjb3JkaW5nIHRvIGBleHBgIGFuZCBgbmJmYFxuICovXG5JZFRva2VuVmVyaWZpZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIHZhciBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgdmFyIGhlYWRlcjtcbiAgICB2YXIgcGF5bG9hZDtcblxuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlcnJvci5Ub2tlblZhbGlkYXRpb25FcnJvcignQ2Fubm90IGRlY29kZSBhIG1hbGZvcm1lZCBKV1QnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICBoZWFkZXIgPSBKU09OLnBhcnNlKGJhc2U2NC5kZWNvZGVUb1N0cmluZyhwYXJ0c1swXSkpO1xuICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShiYXNlNjQuZGVjb2RlVG9TdHJpbmcocGFydHNbMV0pKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBuZXcgZXJyb3IuVG9rZW5WYWxpZGF0aW9uRXJyb3IoJ1Rva2VuIGhlYWRlciBvciBwYXlsb2FkIGlzIG5vdCB2YWxpZCBKU09OJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgIGVuY29kZWQ6IHtcbiAgICAgICAgICAgIGhlYWRlcjogcGFydHNbMF0sXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXJ0c1sxXSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogcGFydHNbMl1cbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZUFjY2Vzc1Rva2VuQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IFtlcnJdIGVycm9yIHJldHVybmVkIGlmIHRoZSB2YWxpZGF0aW9uIGNhbm5vdCBiZSBwZXJmb3JtZWRcbiAqIG9yIHRoZSB0b2tlbiBpcyBpbnZhbGlkLiBJZiB0aGVyZSBpcyBubyBlcnJvciwgdGhlbiB0aGUgYWNjZXNzX3Rva2VuIGlzIHZhbGlkLlxuICovXG5cbi8qKlxuICogVmFsaWRhdGVzIGFuIGFjY2Vzc190b2tlbiBiYXNlZCBvbiB7QGxpbmsgaHR0cDovL29wZW5pZC5uZXQvc3BlY3Mvb3BlbmlkLWNvbm5lY3QtY29yZS0xXzAuaHRtbCNJbXBsaWNpdFRva2VuVmFsaWRhdGlvbn0uXG4gKiBUaGUgaWRfdG9rZW4gZnJvbSB3aGVyZSB0aGUgYWxnIGFuZCBhdEhhc2ggcGFyYW1ldGVycyBhcmUgdGFrZW4sXG4gKiBzaG91bGQgYmUgZGVjb2RlZCBhbmQgdmVyaWZpZWQgYmVmb3JlIHVzaW5nIHRoaXNmdW5jdGlvblxuICpcbiAqIEBtZXRob2QgdmFsaWRhdGVBY2Nlc3NUb2tlblxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2Vzc190b2tlbiB0aGUgYWNjZXNzX3Rva2VuXG4gKiBAcGFyYW0ge1N0cmluZ30gYWxnIFRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiB0aGUgaGVhZGVyIG9mIHRoZVxuICogcHJldmlvdXNseSB2ZXJpZmllZCBpZF90b2tlbiB1bmRlciB0aGUgXCJhbGdcIiBjbGFpbS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBhdEhhc2ggVGhlIFwiYXRfaGFzaFwiIHZhbHVlIGluY2x1ZGVkIGluIHRoZSBwYXlsb2FkXG4gKiBvZiB0aGUgcHJldmlvdXNseSB2ZXJpZmllZCBpZF90b2tlbi5cbiAqIEBwYXJhbSB7dmFsaWRhdGVBY2Nlc3NUb2tlbkNhbGxiYWNrfSBjYiBjYWxsYmFjayB1c2VkIHRvIG5vdGlmeSB0aGUgcmVzdWx0cyBvZiB0aGUgdmFsaWRhdGlvbi5cbiAqL1xuSWRUb2tlblZlcmlmaWVyLnByb3RvdHlwZS52YWxpZGF0ZUFjY2Vzc1Rva2VuID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBhbGcsIGF0SGFzaCkge1xuICAgIGlmICh0aGlzLmV4cGVjdGVkQWxnICE9PSBhbGcpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvci5Ub2tlblZhbGlkYXRpb25FcnJvcignQWxnb3JpdGhtICcgKyBhbGcgK1xuICAgICAgICAgICAgJyBpcyBub3Qgc3VwcG9ydGVkLiAoRXhwZWN0ZWQgYWxnOiAnICsgdGhpcy5leHBlY3RlZEFsZyArICcpJykpO1xuICAgIH1cbiAgICB2YXIgc2hhMjU2QWNjZXNzVG9rZW4gPSBzaGEyNTYoYWNjZXNzVG9rZW4pO1xuICAgIHZhciBoYXNoVG9IZXggPSBjcnlwdG9IZXguc3RyaW5naWZ5KHNoYTI1NkFjY2Vzc1Rva2VuKTtcbiAgICB2YXIgaGFzaFRvSGV4Rmlyc3RIYWxmID0gaGFzaFRvSGV4LnN1YnN0cmluZygwLCBoYXNoVG9IZXgubGVuZ3RoIC8gMik7XG4gICAgdmFyIGhhc2hGaXJzdEhhbGZXb3JkQXJyYXkgPSBjcnlwdG9IZXgucGFyc2UoaGFzaFRvSGV4Rmlyc3RIYWxmKTtcbiAgICB2YXIgaGFzaEZpcnN0SGFsZkJhc2U2NCA9IGNyeXB0b0Jhc2U2NC5zdHJpbmdpZnkoaGFzaEZpcnN0SGFsZldvcmRBcnJheSk7XG4gICAgdmFyIGhhc2hGaXJzdEhhbGZCYXNlNjRTYWZlVXJsID0gYmFzZTY0LmJhc2U2NFRvQmFzZTY0VXJsKGhhc2hGaXJzdEhhbGZCYXNlNjQpO1xuICAgIGlmIChoYXNoRmlyc3RIYWxmQmFzZTY0U2FmZVVybCAhPT0gYXRIYXNoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgZXJyb3IuVG9rZW5WYWxpZGF0aW9uRXJyb3IoJ0ludmFsaWQgYWNjZXNzX3Rva2VuJykpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJZFRva2VuVmVyaWZpZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vaWR0b2tlbi12ZXJpZmllci9zcmMvaW5kZXguanMiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIEluaXRpYWxpemF0aW9uIGFuZCByb3VuZCBjb25zdGFudHMgdGFibGVzXG5cdCAgICB2YXIgSCA9IFtdO1xuXHQgICAgdmFyIEsgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gaXNQcmltZShuKSB7XG5cdCAgICAgICAgICAgIHZhciBzcXJ0TiA9IE1hdGguc3FydChuKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgZmFjdG9yID0gMjsgZmFjdG9yIDw9IHNxcnROOyBmYWN0b3IrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKCEobiAlIGZhY3RvcikpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdW5jdGlvbiBnZXRGcmFjdGlvbmFsQml0cyhuKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoKG4gLSAobiB8IDApKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIG4gPSAyO1xuXHQgICAgICAgIHZhciBuUHJpbWUgPSAwO1xuXHQgICAgICAgIHdoaWxlIChuUHJpbWUgPCA2NCkge1xuXHQgICAgICAgICAgICBpZiAoaXNQcmltZShuKSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG5QcmltZSA8IDgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBIW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgS1tuUHJpbWVdID0gZ2V0RnJhY3Rpb25hbEJpdHMoTWF0aC5wb3cobiwgMSAvIDMpKTtcblxuXHQgICAgICAgICAgICAgICAgblByaW1lKys7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBuKys7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0XG5cdCAgICB2YXIgVyA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0yNTYgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEEyNTYgPSBDX2FsZ28uU0hBMjU2ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChILnNsaWNlKDApKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cdCAgICAgICAgICAgIHZhciBlID0gSFs0XTtcblx0ICAgICAgICAgICAgdmFyIGYgPSBIWzVdO1xuXHQgICAgICAgICAgICB2YXIgZyA9IEhbNl07XG5cdCAgICAgICAgICAgIHZhciBoID0gSFs3XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTB4ID0gV1tpIC0gMTVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTAgID0gKChnYW1tYTB4IDw8IDI1KSB8IChnYW1tYTB4ID4+PiA3KSkgIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZ2FtbWEweCA8PCAxNCkgfCAoZ2FtbWEweCA+Pj4gMTgpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMHggPj4+IDMpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMXggPSBXW2kgLSAyXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExICA9ICgoZ2FtbWExeCA8PCAxNSkgfCAoZ2FtbWExeCA+Pj4gMTcpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGdhbW1hMXggPDwgMTMpIHwgKGdhbW1hMXggPj4+IDE5KSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnYW1tYTF4ID4+PiAxMCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciBjaCAgPSAoZSAmIGYpIF4gKH5lICYgZyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFqID0gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWEwID0gKChhIDw8IDMwKSB8IChhID4+PiAyKSkgXiAoKGEgPDwgMTkpIHwgKGEgPj4+IDEzKSkgXiAoKGEgPDwgMTApIHwgKGEgPj4+IDIyKSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWExID0gKChlIDw8IDI2KSB8IChlID4+PiA2KSkgXiAoKGUgPDwgMjEpIHwgKGUgPj4+IDExKSkgXiAoKGUgPDwgNykgIHwgKGUgPj4+IDI1KSk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQyID0gc2lnbWEwICsgbWFqO1xuXG5cdCAgICAgICAgICAgICAgICBoID0gZztcblx0ICAgICAgICAgICAgICAgIGcgPSBmO1xuXHQgICAgICAgICAgICAgICAgZiA9IGU7XG5cdCAgICAgICAgICAgICAgICBlID0gKGQgKyB0MSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgZCA9IGM7XG5cdCAgICAgICAgICAgICAgICBjID0gYjtcblx0ICAgICAgICAgICAgICAgIGIgPSBhO1xuXHQgICAgICAgICAgICAgICAgYSA9ICh0MSArIHQyKSB8IDA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFs0XSArIGUpIHwgMDtcblx0ICAgICAgICAgICAgSFs1XSA9IChIWzVdICsgZikgfCAwO1xuXHQgICAgICAgICAgICBIWzZdID0gKEhbNl0gKyBnKSB8IDA7XG5cdCAgICAgICAgICAgIEhbN10gPSAoSFs3XSArIGgpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEEyNTYpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTI1NihtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMjU2KTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMjU2O1xuXG59KSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2lkdG9rZW4tdmVyaWZpZXIvfi9jcnlwdG8tanMvc2hhMjU2LmpzIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdHJvb3QuQ3J5cHRvSlMgPSBmYWN0b3J5KCk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuXHQgKiBDcnlwdG9KUyBjb3JlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHR2YXIgQ3J5cHRvSlMgPSBDcnlwdG9KUyB8fCAoZnVuY3Rpb24gKE1hdGgsIHVuZGVmaW5lZCkge1xuXHQgICAgLypcblx0ICAgICAqIExvY2FsIHBvbHlmaWwgb2YgT2JqZWN0LmNyZWF0ZVxuXHQgICAgICovXG5cdCAgICB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIEYoKSB7fTtcblxuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgICAgIHZhciBzdWJ0eXBlO1xuXG5cdCAgICAgICAgICAgIEYucHJvdG90eXBlID0gb2JqO1xuXG5cdCAgICAgICAgICAgIHN1YnR5cGUgPSBuZXcgRigpO1xuXG5cdCAgICAgICAgICAgIEYucHJvdG90eXBlID0gbnVsbDtcblxuXHQgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICB9O1xuXHQgICAgfSgpKVxuXG5cdCAgICAvKipcblx0ICAgICAqIENyeXB0b0pTIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMaWJyYXJ5IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbGliID0gQy5saWIgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlIG9iamVjdCBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlID0gKGZ1bmN0aW9uICgpIHtcblxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyBQcm9wZXJ0aWVzIHRvIGNvcHkgaW50byB0aGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZScsXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNwYXduXG5cdCAgICAgICAgICAgICAgICB2YXIgc3VidHlwZSA9IGNyZWF0ZSh0aGlzKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gQXVnbWVudFxuXHQgICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUubWl4SW4ob3ZlcnJpZGVzKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgaW5pdGlhbGl6ZXJcblx0ICAgICAgICAgICAgICAgIGlmICghc3VidHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5pdCcpIHx8IHRoaXMuaW5pdCA9PT0gc3VidHlwZS5pbml0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZXIncyBwcm90b3R5cGUgaXMgdGhlIHN1YnR5cGUgb2JqZWN0XG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQucHJvdG90eXBlID0gc3VidHlwZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlIHN1cGVydHlwZVxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogRXh0ZW5kcyB0aGlzIG9iamVjdCBhbmQgcnVucyB0aGUgaW5pdCBtZXRob2QuXG5cdCAgICAgICAgICAgICAqIEFyZ3VtZW50cyB0byBjcmVhdGUoKSB3aWxsIGJlIHBhc3NlZCB0byBpbml0KCkuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBpbnN0YW5jZSA9IE15VHlwZS5jcmVhdGUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5leHRlbmQoKTtcblx0ICAgICAgICAgICAgICAgIGluc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG9iamVjdC5cblx0ICAgICAgICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIHNvbWUgbG9naWMgd2hlbiB5b3VyIG9iamVjdHMgYXJlIGNyZWF0ZWQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgICAgIC8vIC4uLlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBpbnRvIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBUaGUgcHJvcGVydGllcyB0byBtaXggaW4uXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBNeVR5cGUubWl4SW4oe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnXG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIG1peEluOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIElFIHdvbid0IGNvcHkgdG9TdHJpbmcgdXNpbmcgdGhlIGxvb3AgYWJvdmVcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmluZyA9IHByb3BlcnRpZXMudG9TdHJpbmc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGluc3RhbmNlLmNsb25lKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgKi9cblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddLCA2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XG5cdCAgICAgICAgICAgIHdvcmRzID0gdGhpcy53b3JkcyA9IHdvcmRzIHx8IFtdO1xuXG5cdCAgICAgICAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgd29yZCBhcnJheSB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciAoT3B0aW9uYWwpIFRoZSBlbmNvZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IENyeXB0b0pTLmVuYy5IZXhcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGVuY29kZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChlbmNvZGVyIHx8IEhleCkuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25jYXRlbmF0ZXMgYSB3b3JkIGFycmF5IHRvIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0V29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGlzU2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHRoaXMuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb25jYXRcblx0ICAgICAgICAgICAgaWYgKHRoaXNTaWdCeXRlcyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXRCeXRlID0gKHRoYXRXb3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gfD0gdGhhdEJ5dGUgPDwgKDI0IC0gKCh0aGlzU2lnQnl0ZXMgKyBpKSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSB3b3JkIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdID0gdGhhdFdvcmRzW2kgPj4+IDJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgKz0gdGhhdFNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVtb3ZlcyBpbnNpZ25pZmljYW50IGJpdHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsYW1wOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wXG5cdCAgICAgICAgICAgIHdvcmRzW3NpZ0J5dGVzID4+PiAyXSAmPSAweGZmZmZmZmZmIDw8ICgzMiAtIChzaWdCeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIHdvcmRzLmxlbmd0aCA9IE1hdGguY2VpbChzaWdCeXRlcyAvIDQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gd29yZEFycmF5LmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgd29yZCBhcnJheSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmFuZG9tOiBmdW5jdGlvbiAobkJ5dGVzKSB7XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXG5cdCAgICAgICAgICAgIHZhciByID0gKGZ1bmN0aW9uIChtX3cpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtX3cgPSBtX3c7XG5cdCAgICAgICAgICAgICAgICB2YXIgbV96ID0gMHgzYWRlNjhiMTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYXNrID0gMHhmZmZmZmZmZjtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBtX3ogPSAoMHg5MDY5ICogKG1feiAmIDB4RkZGRikgKyAobV96ID4+IDB4MTApKSAmIG1hc2s7XG5cdCAgICAgICAgICAgICAgICAgICAgbV93ID0gKDB4NDY1MCAqIChtX3cgJiAweEZGRkYpICsgKG1fdyA+PiAweDEwKSkgJiBtYXNrO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAoKG1feiA8PCAweDEwKSArIG1fdykgJiBtYXNrO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCAvPSAweDEwMDAwMDAwMDtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gMC41O1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKiAoTWF0aC5yYW5kb20oKSA+IC41ID8gMSA6IC0xKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHJjYWNoZTsgaSA8IG5CeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3IgPSByKChyY2FjaGUgfHwgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwMDAwMCk7XG5cblx0ICAgICAgICAgICAgICAgIHJjYWNoZSA9IF9yKCkgKiAweDNhZGU2N2I3O1xuXHQgICAgICAgICAgICAgICAgd29yZHMucHVzaCgoX3IoKSAqIDB4MTAwMDAwMDAwKSB8IDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbkJ5dGVzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBFbmNvZGVyIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBIZXggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGhleENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhleENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGhleFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChoZXhTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhleFN0ckxlbmd0aCA9IGhleFN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZXhTdHJMZW5ndGg7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8ICgyNCAtIChpICUgOCkgKiA0KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGhleFN0ckxlbmd0aCAvIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGF0aW4xIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgTGF0aW4xID0gQ19lbmMuTGF0aW4xID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGxhdGluMVN0cmluZyA9IENyeXB0b0pTLmVuYy5MYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbGF0aW4xQ2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgTGF0aW4xIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0aW4xU3RyIFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5MYXRpbjEucGFyc2UobGF0aW4xU3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGxhdGluMVN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xU3RyTGVuZ3RoID0gbGF0aW4xU3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSAobGF0aW4xU3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBsYXRpbjFTdHJMZW5ndGgpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmOCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmOFN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFVURi04IGRhdGEnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi04IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmOFN0ciBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKHV0ZjhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmOFN0cikge1xuXHQgICAgICAgICAgICByZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYnVmZmVyZWQgYmxvY2sgYWxnb3JpdGhtIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIFRoZSBwcm9wZXJ0eSBibG9ja1NpemUgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9taW5CdWZmZXJTaXplIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIGtlcHQgdW5wcm9jZXNzZWQgaW4gdGhlIGJ1ZmZlci4gRGVmYXVsdDogMFxuXHQgICAgICovXG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgZGF0YSBidWZmZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLl9kYXRhID0gbmV3IFdvcmRBcnJheS5pbml0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgPSAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIG5ldyBkYXRhIHRvIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgYnVmZmVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGFwcGVuZC4gU3RyaW5ncyBhcmUgY29udmVydGVkIHRvIGEgV29yZEFycmF5IHVzaW5nIFVURi04LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2FwcGVuZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSBVdGY4LnBhcnNlKGRhdGEpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEuY29uY2F0KGRhdGEpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFByb2Nlc3NlcyBhdmFpbGFibGUgZGF0YSBibG9ja3MuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIF9kb1Byb2Nlc3NCbG9jayhvZmZzZXQpLCB3aGljaCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9GbHVzaCBXaGV0aGVyIGFsbCBibG9ja3MgYW5kIHBhcnRpYWwgYmxvY2tzIHNob3VsZCBiZSBwcm9jZXNzZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwcm9jZXNzZWQgZGF0YS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wcm9jZXNzOiBmdW5jdGlvbiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGRhdGFTaWdCeXRlcyA9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBibG9ja3MgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CbG9ja3NSZWFkeSA9IGRhdGFTaWdCeXRlcyAvIGJsb2NrU2l6ZUJ5dGVzO1xuXHQgICAgICAgICAgICBpZiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgdG8gaW5jbHVkZSBwYXJ0aWFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5jZWlsKG5CbG9ja3NSZWFkeSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSb3VuZCBkb3duIHRvIGluY2x1ZGUgb25seSBmdWxsIGJsb2Nrcyxcblx0ICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBtdXN0IHJlbWFpbiBpbiB0aGUgYnVmZmVyXG5cdCAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLm1heCgobkJsb2Nrc1JlYWR5IHwgMCkgLSB0aGlzLl9taW5CdWZmZXJTaXplLCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvdW50IHdvcmRzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuV29yZHNSZWFkeSA9IG5CbG9ja3NSZWFkeSAqIGJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBieXRlcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbkJ5dGVzUmVhZHkgPSBNYXRoLm1pbihuV29yZHNSZWFkeSAqIDQsIGRhdGFTaWdCeXRlcyk7XG5cblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBibG9ja3Ncblx0ICAgICAgICAgICAgaWYgKG5Xb3Jkc1JlYWR5KSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBuV29yZHNSZWFkeTsgb2Zmc2V0ICs9IGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtYWxnb3JpdGhtIGxvZ2ljXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9Qcm9jZXNzQmxvY2soZGF0YVdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkV29yZHMgPSBkYXRhV29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcblx0ICAgICAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQocHJvY2Vzc2VkV29yZHMsIG5CeXRlc1JlYWR5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWluQnVmZmVyU2l6ZTogMFxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgaGFzaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBoYXNoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDE2ICg1MTIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaGVyID0gQ3J5cHRvSlMuYWxnby5TSEEyNTYuY3JlYXRlKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBoYXNoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SGFzaGVyfSBUaGlzIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaGFzaFxuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBtZXNzYWdlIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogNTEyLzMyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGEgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIFNIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGNmZykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBoYXNoZXIuaW5pdChjZmcpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEhtYWNTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSG1hY0hlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbGdvcml0aG0gbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvID0ge307XG5cblx0ICAgIHJldHVybiBDO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9pZHRva2VuLXZlcmlmaWVyL34vY3J5cHRvLWpzL2NvcmUuanMiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlNjQgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgYmFzZTY0U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUxID0gKHdvcmRzW2kgPj4+IDJdICAgICAgID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICAgICAgICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMiA9ICh3b3Jkc1soaSArIDEpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMSkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTMgPSAod29yZHNbKGkgKyAyKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDIpICUgNCkgKiA4KSkgJiAweGZmO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdHJpcGxldCA9IChieXRlMSA8PCAxNikgfCAoYnl0ZTIgPDwgOCkgfCBieXRlMztcblxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IChqIDwgNCkgJiYgKGkgKyBqICogMC43NSA8IHNpZ0J5dGVzKTsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChtYXAuY2hhckF0KCh0cmlwbGV0ID4+PiAoNiAqICgzIC0gaikpKSAmIDB4M2YpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXHQgICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChiYXNlNjRDaGFycy5sZW5ndGggJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChwYWRkaW5nQ2hhcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gYmFzZTY0Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0U3RyIFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoYmFzZTY0U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGJhc2U2NFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NFN0ckxlbmd0aCA9IGJhc2U2NFN0ci5sZW5ndGg7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdCAgICAgICAgICAgIHZhciByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcDtcblxuXHQgICAgICAgICAgICBpZiAoIXJldmVyc2VNYXApIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBbbWFwLmNoYXJDb2RlQXQoaildID0gajtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJZ25vcmUgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdJbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRTdHJMZW5ndGggPSBwYWRkaW5nSW5kZXg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHJldHVybiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApO1xuXG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9tYXA6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSdcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCkge1xuXHQgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgdmFyIG5CeXRlcyA9IDA7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZTY0U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChpICUgNCkge1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMSA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSAtIDEpXSA8PCAoKGkgJSA0KSAqIDIpO1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMiA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldID4+PiAoNiAtIChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICB3b3Jkc1tuQnl0ZXMgPj4+IDJdIHw9IChiaXRzMSB8IGJpdHMyKSA8PCAoMjQgLSAobkJ5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICBuQnl0ZXMrKztcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgbkJ5dGVzKTtcblx0ICAgIH1cblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuQmFzZTY0O1xuXG59KSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2lkdG9rZW4tdmVyaWZpZXIvfi9jcnlwdG8tanMvZW5jLWJhc2U2NC5qcyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5IZXg7XG5cbn0pKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vaWR0b2tlbi12ZXJpZmllci9+L2NyeXB0by1qcy9lbmMtaGV4LmpzIiwiLypcbkJhc2VkIG9uIHRoZSB3b3JrIG9mIFRvbSBXdVxuaHR0cDovL3d3dy1jcy1zdHVkZW50cy5zdGFuZm9yZC5lZHUvfnRqdy9qc2JuL1xuaHR0cDovL3d3dy1jcy1zdHVkZW50cy5zdGFuZm9yZC5lZHUvfnRqdy9qc2JuL0xJQ0VOU0VcbiovXG5cbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnanNibicpLkJpZ0ludGVnZXI7XG52YXIgU0hBMjU2ID0gcmVxdWlyZSgnY3J5cHRvLWpzL3NoYTI1NicpO1xuXG52YXIgRGlnZXN0SW5mb0hlYWQgPSB7XG4gIHNoYTE6ICczMDIxMzAwOTA2MDUyYjBlMDMwMjFhMDUwMDA0MTQnLFxuICBzaGEyMjQ6ICczMDJkMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDQwNTAwMDQxYycsXG4gIHNoYTI1NjogJzMwMzEzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwMTA1MDAwNDIwJyxcbiAgc2hhMzg0OiAnMzA0MTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAyMDUwMDA0MzAnLFxuICBzaGE1MTI6ICczMDUxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDMwNTAwMDQ0MCcsXG4gIG1kMjogJzMwMjAzMDBjMDYwODJhODY0ODg2ZjcwZDAyMDIwNTAwMDQxMCcsXG4gIG1kNTogJzMwMjAzMDBjMDYwODJhODY0ODg2ZjcwZDAyMDUwNTAwMDQxMCcsXG4gIHJpcGVtZDE2MDogJzMwMjEzMDA5MDYwNTJiMjQwMzAyMDEwNTAwMDQxNCdcbn07XG5cbnZhciBEaWdlc3RBbGdzID0ge1xuICBzaGEyNTY6IFNIQTI1NlxufTtcblxuZnVuY3Rpb24gUlNBVmVyaWZpZXIobW9kdWx1cywgZXhwKSB7XG4gIHRoaXMubiA9IG51bGw7XG4gIHRoaXMuZSA9IDA7XG5cbiAgaWYgKG1vZHVsdXMgIT0gbnVsbCAmJiBleHAgIT0gbnVsbCAmJiBtb2R1bHVzLmxlbmd0aCA+IDAgJiYgZXhwLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLm4gPSBuZXcgQmlnSW50ZWdlcihtb2R1bHVzLCAxNik7XG4gICAgdGhpcy5lID0gcGFyc2VJbnQoZXhwLCAxNik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBkYXRhJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QWxnb3JpdGhtRnJvbURpZ2VzdChoRGlnZXN0SW5mbykge1xuICBmb3IgKHZhciBhbGdOYW1lIGluIERpZ2VzdEluZm9IZWFkKSB7XG4gICAgdmFyIGhlYWQgPSBEaWdlc3RJbmZvSGVhZFthbGdOYW1lXTtcbiAgICB2YXIgbGVuID0gaGVhZC5sZW5ndGg7XG5cbiAgICBpZiAoaERpZ2VzdEluZm8uc3Vic3RyaW5nKDAsIGxlbikgPT09IGhlYWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFsZzogYWxnTmFtZSxcbiAgICAgICAgaGFzaDogaERpZ2VzdEluZm8uc3Vic3RyaW5nKGxlbilcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn1cblxuXG5SU0FWZXJpZmllci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gKG1zZywgZW5jc2lnKSB7XG4gIGVuY3NpZyA9IGVuY3NpZy5yZXBsYWNlKC9bXjAtOWEtZl18W1xcc1xcbl1dL2lnLCAnJyk7XG5cbiAgdmFyIHNpZyA9IG5ldyBCaWdJbnRlZ2VyKGVuY3NpZywgMTYpO1xuICBpZiAoc2lnLmJpdExlbmd0aCgpID4gdGhpcy5uLmJpdExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggd2l0aCB0aGUga2V5IG1vZHVsdXMuJyk7XG4gIH1cblxuICB2YXIgZGVjcnlwdGVkU2lnID0gc2lnLm1vZFBvd0ludCh0aGlzLmUsIHRoaXMubik7XG4gIHZhciBkaWdlc3QgPSBkZWNyeXB0ZWRTaWcudG9TdHJpbmcoMTYpLnJlcGxhY2UoL14xZiswMC8sICcnKTtcblxuICB2YXIgZGlnZXN0SW5mbyA9IGdldEFsZ29yaXRobUZyb21EaWdlc3QoZGlnZXN0KTtcbiAgaWYgKGRpZ2VzdEluZm8ubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFEaWdlc3RBbGdzLmhhc093blByb3BlcnR5KGRpZ2VzdEluZm8uYWxnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSGFzaGluZyBhbGdvcml0aG0gaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgfVxuXG4gIHZhciBtc2dIYXNoID0gRGlnZXN0QWxnc1tkaWdlc3RJbmZvLmFsZ10obXNnKS50b1N0cmluZygpO1xuICByZXR1cm4gKGRpZ2VzdEluZm8uaGFzaCA9PT0gbXNnSGFzaCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJTQVZlcmlmaWVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2lkdG9rZW4tdmVyaWZpZXIvc3JjL2hlbHBlcnMvcnNhLXZlcmlmaWVyLmpzIiwiKGZ1bmN0aW9uKCl7XG5cbiAgICAvLyBDb3B5cmlnaHQgKGMpIDIwMDUgIFRvbSBXdVxuICAgIC8vIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgLy8gU2VlIFwiTElDRU5TRVwiIGZvciBkZXRhaWxzLlxuXG4gICAgLy8gQmFzaWMgSmF2YVNjcmlwdCBCTiBsaWJyYXJ5IC0gc3Vic2V0IHVzZWZ1bCBmb3IgUlNBIGVuY3J5cHRpb24uXG5cbiAgICAvLyBCaXRzIHBlciBkaWdpdFxuICAgIHZhciBkYml0cztcblxuICAgIC8vIEphdmFTY3JpcHQgZW5naW5lIGFuYWx5c2lzXG4gICAgdmFyIGNhbmFyeSA9IDB4ZGVhZGJlZWZjYWZlO1xuICAgIHZhciBqX2xtID0gKChjYW5hcnkmMHhmZmZmZmYpPT0weGVmY2FmZSk7XG5cbiAgICAvLyAocHVibGljKSBDb25zdHJ1Y3RvclxuICAgIGZ1bmN0aW9uIEJpZ0ludGVnZXIoYSxiLGMpIHtcbiAgICAgIGlmKGEgIT0gbnVsbClcbiAgICAgICAgaWYoXCJudW1iZXJcIiA9PSB0eXBlb2YgYSkgdGhpcy5mcm9tTnVtYmVyKGEsYixjKTtcbiAgICAgICAgZWxzZSBpZihiID09IG51bGwgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgYSkgdGhpcy5mcm9tU3RyaW5nKGEsMjU2KTtcbiAgICAgICAgZWxzZSB0aGlzLmZyb21TdHJpbmcoYSxiKTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gbmV3LCB1bnNldCBCaWdJbnRlZ2VyXG4gICAgZnVuY3Rpb24gbmJpKCkgeyByZXR1cm4gbmV3IEJpZ0ludGVnZXIobnVsbCk7IH1cblxuICAgIC8vIGFtOiBDb21wdXRlIHdfaiArPSAoeCp0aGlzX2kpLCBwcm9wYWdhdGUgY2FycmllcyxcbiAgICAvLyBjIGlzIGluaXRpYWwgY2FycnksIHJldHVybnMgZmluYWwgY2FycnkuXG4gICAgLy8gYyA8IDMqZHZhbHVlLCB4IDwgMipkdmFsdWUsIHRoaXNfaSA8IGR2YWx1ZVxuICAgIC8vIFdlIG5lZWQgdG8gc2VsZWN0IHRoZSBmYXN0ZXN0IG9uZSB0aGF0IHdvcmtzIGluIHRoaXMgZW52aXJvbm1lbnQuXG5cbiAgICAvLyBhbTE6IHVzZSBhIHNpbmdsZSBtdWx0IGFuZCBkaXZpZGUgdG8gZ2V0IHRoZSBoaWdoIGJpdHMsXG4gICAgLy8gbWF4IGRpZ2l0IGJpdHMgc2hvdWxkIGJlIDI2IGJlY2F1c2VcbiAgICAvLyBtYXggaW50ZXJuYWwgdmFsdWUgPSAyKmR2YWx1ZV4yLTIqZHZhbHVlICg8IDJeNTMpXG4gICAgZnVuY3Rpb24gYW0xKGkseCx3LGosYyxuKSB7XG4gICAgICB3aGlsZSgtLW4gPj0gMCkge1xuICAgICAgICB2YXIgdiA9IHgqdGhpc1tpKytdK3dbal0rYztcbiAgICAgICAgYyA9IE1hdGguZmxvb3Iodi8weDQwMDAwMDApO1xuICAgICAgICB3W2orK10gPSB2JjB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICAvLyBhbTIgYXZvaWRzIGEgYmlnIG11bHQtYW5kLWV4dHJhY3QgY29tcGxldGVseS5cbiAgICAvLyBNYXggZGlnaXQgYml0cyBzaG91bGQgYmUgPD0gMzAgYmVjYXVzZSB3ZSBkbyBiaXR3aXNlIG9wc1xuICAgIC8vIG9uIHZhbHVlcyB1cCB0byAyKmhkdmFsdWVeMi1oZHZhbHVlLTEgKDwgMl4zMSlcbiAgICBmdW5jdGlvbiBhbTIoaSx4LHcsaixjLG4pIHtcbiAgICAgIHZhciB4bCA9IHgmMHg3ZmZmLCB4aCA9IHg+PjE1O1xuICAgICAgd2hpbGUoLS1uID49IDApIHtcbiAgICAgICAgdmFyIGwgPSB0aGlzW2ldJjB4N2ZmZjtcbiAgICAgICAgdmFyIGggPSB0aGlzW2krK10+PjE1O1xuICAgICAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICAgICAgbCA9IHhsKmwrKChtJjB4N2ZmZik8PDE1KSt3W2pdKyhjJjB4M2ZmZmZmZmYpO1xuICAgICAgICBjID0gKGw+Pj4zMCkrKG0+Pj4xNSkreGgqaCsoYz4+PjMwKTtcbiAgICAgICAgd1tqKytdID0gbCYweDNmZmZmZmZmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIC8vIEFsdGVybmF0ZWx5LCBzZXQgbWF4IGRpZ2l0IGJpdHMgdG8gMjggc2luY2Ugc29tZVxuICAgIC8vIGJyb3dzZXJzIHNsb3cgZG93biB3aGVuIGRlYWxpbmcgd2l0aCAzMi1iaXQgbnVtYmVycy5cbiAgICBmdW5jdGlvbiBhbTMoaSx4LHcsaixjLG4pIHtcbiAgICAgIHZhciB4bCA9IHgmMHgzZmZmLCB4aCA9IHg+PjE0O1xuICAgICAgd2hpbGUoLS1uID49IDApIHtcbiAgICAgICAgdmFyIGwgPSB0aGlzW2ldJjB4M2ZmZjtcbiAgICAgICAgdmFyIGggPSB0aGlzW2krK10+PjE0O1xuICAgICAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICAgICAgbCA9IHhsKmwrKChtJjB4M2ZmZik8PDE0KSt3W2pdK2M7XG4gICAgICAgIGMgPSAobD4+MjgpKyhtPj4xNCkreGgqaDtcbiAgICAgICAgd1tqKytdID0gbCYweGZmZmZmZmY7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgdmFyIGluQnJvd3NlciA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgaWYoaW5Ccm93c2VyICYmIGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lID09IFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCIpKSB7XG4gICAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGFtMjtcbiAgICAgIGRiaXRzID0gMzA7XG4gICAgfVxuICAgIGVsc2UgaWYoaW5Ccm93c2VyICYmIGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lICE9IFwiTmV0c2NhcGVcIikpIHtcbiAgICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0xO1xuICAgICAgZGJpdHMgPSAyNjtcbiAgICB9XG4gICAgZWxzZSB7IC8vIE1vemlsbGEvTmV0c2NhcGUgc2VlbXMgdG8gcHJlZmVyIGFtM1xuICAgICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gICAgICBkYml0cyA9IDI4O1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLkRCID0gZGJpdHM7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuRE0gPSAoKDE8PGRiaXRzKS0xKTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5EViA9ICgxPDxkYml0cyk7XG5cbiAgICB2YXIgQklfRlAgPSA1MjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5GViA9IE1hdGgucG93KDIsQklfRlApO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLkYxID0gQklfRlAtZGJpdHM7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuRjIgPSAyKmRiaXRzLUJJX0ZQO1xuXG4gICAgLy8gRGlnaXQgY29udmVyc2lvbnNcbiAgICB2YXIgQklfUk0gPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xuICAgIHZhciBCSV9SQyA9IG5ldyBBcnJheSgpO1xuICAgIHZhciBycix2djtcbiAgICByciA9IFwiMFwiLmNoYXJDb2RlQXQoMCk7XG4gICAgZm9yKHZ2ID0gMDsgdnYgPD0gOTsgKyt2dikgQklfUkNbcnIrK10gPSB2djtcbiAgICByciA9IFwiYVwiLmNoYXJDb2RlQXQoMCk7XG4gICAgZm9yKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIEJJX1JDW3JyKytdID0gdnY7XG4gICAgcnIgPSBcIkFcIi5jaGFyQ29kZUF0KDApO1xuICAgIGZvcih2diA9IDEwOyB2diA8IDM2OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2O1xuXG4gICAgZnVuY3Rpb24gaW50MmNoYXIobikgeyByZXR1cm4gQklfUk0uY2hhckF0KG4pOyB9XG4gICAgZnVuY3Rpb24gaW50QXQocyxpKSB7XG4gICAgICB2YXIgYyA9IEJJX1JDW3MuY2hhckNvZGVBdChpKV07XG4gICAgICByZXR1cm4gKGM9PW51bGwpPy0xOmM7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgY29weSB0aGlzIHRvIHJcbiAgICBmdW5jdGlvbiBibnBDb3B5VG8ocikge1xuICAgICAgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByW2ldID0gdGhpc1tpXTtcbiAgICAgIHIudCA9IHRoaXMudDtcbiAgICAgIHIucyA9IHRoaXMucztcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBpbnRlZ2VyIHZhbHVlIHgsIC1EViA8PSB4IDwgRFZcbiAgICBmdW5jdGlvbiBibnBGcm9tSW50KHgpIHtcbiAgICAgIHRoaXMudCA9IDE7XG4gICAgICB0aGlzLnMgPSAoeDwwKT8tMTowO1xuICAgICAgaWYoeCA+IDApIHRoaXNbMF0gPSB4O1xuICAgICAgZWxzZSBpZih4IDwgLTEpIHRoaXNbMF0gPSB4K3RoaXMuRFY7XG4gICAgICBlbHNlIHRoaXMudCA9IDA7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIGJpZ2ludCBpbml0aWFsaXplZCB0byB2YWx1ZVxuICAgIGZ1bmN0aW9uIG5idihpKSB7IHZhciByID0gbmJpKCk7IHIuZnJvbUludChpKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIHN0cmluZyBhbmQgcmFkaXhcbiAgICBmdW5jdGlvbiBibnBGcm9tU3RyaW5nKHMsYikge1xuICAgICAgdmFyIGs7XG4gICAgICBpZihiID09IDE2KSBrID0gNDtcbiAgICAgIGVsc2UgaWYoYiA9PSA4KSBrID0gMztcbiAgICAgIGVsc2UgaWYoYiA9PSAyNTYpIGsgPSA4OyAvLyBieXRlIGFycmF5XG4gICAgICBlbHNlIGlmKGIgPT0gMikgayA9IDE7XG4gICAgICBlbHNlIGlmKGIgPT0gMzIpIGsgPSA1O1xuICAgICAgZWxzZSBpZihiID09IDQpIGsgPSAyO1xuICAgICAgZWxzZSB7IHRoaXMuZnJvbVJhZGl4KHMsYik7IHJldHVybjsgfVxuICAgICAgdGhpcy50ID0gMDtcbiAgICAgIHRoaXMucyA9IDA7XG4gICAgICB2YXIgaSA9IHMubGVuZ3RoLCBtaSA9IGZhbHNlLCBzaCA9IDA7XG4gICAgICB3aGlsZSgtLWkgPj0gMCkge1xuICAgICAgICB2YXIgeCA9IChrPT04KT9zW2ldJjB4ZmY6aW50QXQocyxpKTtcbiAgICAgICAgaWYoeCA8IDApIHtcbiAgICAgICAgICBpZihzLmNoYXJBdChpKSA9PSBcIi1cIikgbWkgPSB0cnVlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1pID0gZmFsc2U7XG4gICAgICAgIGlmKHNoID09IDApXG4gICAgICAgICAgdGhpc1t0aGlzLnQrK10gPSB4O1xuICAgICAgICBlbHNlIGlmKHNoK2sgPiB0aGlzLkRCKSB7XG4gICAgICAgICAgdGhpc1t0aGlzLnQtMV0gfD0gKHgmKCgxPDwodGhpcy5EQi1zaCkpLTEpKTw8c2g7XG4gICAgICAgICAgdGhpc1t0aGlzLnQrK10gPSAoeD4+KHRoaXMuREItc2gpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpc1t0aGlzLnQtMV0gfD0geDw8c2g7XG4gICAgICAgIHNoICs9IGs7XG4gICAgICAgIGlmKHNoID49IHRoaXMuREIpIHNoIC09IHRoaXMuREI7XG4gICAgICB9XG4gICAgICBpZihrID09IDggJiYgKHNbMF0mMHg4MCkgIT0gMCkge1xuICAgICAgICB0aGlzLnMgPSAtMTtcbiAgICAgICAgaWYoc2ggPiAwKSB0aGlzW3RoaXMudC0xXSB8PSAoKDE8PCh0aGlzLkRCLXNoKSktMSk8PHNoO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGFtcCgpO1xuICAgICAgaWYobWkpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLHRoaXMpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIGNsYW1wIG9mZiBleGNlc3MgaGlnaCB3b3Jkc1xuICAgIGZ1bmN0aW9uIGJucENsYW1wKCkge1xuICAgICAgdmFyIGMgPSB0aGlzLnMmdGhpcy5ETTtcbiAgICAgIHdoaWxlKHRoaXMudCA+IDAgJiYgdGhpc1t0aGlzLnQtMV0gPT0gYykgLS10aGlzLnQ7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxuICAgIGZ1bmN0aW9uIGJuVG9TdHJpbmcoYikge1xuICAgICAgaWYodGhpcy5zIDwgMCkgcmV0dXJuIFwiLVwiK3RoaXMubmVnYXRlKCkudG9TdHJpbmcoYik7XG4gICAgICB2YXIgaztcbiAgICAgIGlmKGIgPT0gMTYpIGsgPSA0O1xuICAgICAgZWxzZSBpZihiID09IDgpIGsgPSAzO1xuICAgICAgZWxzZSBpZihiID09IDIpIGsgPSAxO1xuICAgICAgZWxzZSBpZihiID09IDMyKSBrID0gNTtcbiAgICAgIGVsc2UgaWYoYiA9PSA0KSBrID0gMjtcbiAgICAgIGVsc2UgcmV0dXJuIHRoaXMudG9SYWRpeChiKTtcbiAgICAgIHZhciBrbSA9ICgxPDxrKS0xLCBkLCBtID0gZmFsc2UsIHIgPSBcIlwiLCBpID0gdGhpcy50O1xuICAgICAgdmFyIHAgPSB0aGlzLkRCLShpKnRoaXMuREIpJWs7XG4gICAgICBpZihpLS0gPiAwKSB7XG4gICAgICAgIGlmKHAgPCB0aGlzLkRCICYmIChkID0gdGhpc1tpXT4+cCkgPiAwKSB7IG0gPSB0cnVlOyByID0gaW50MmNoYXIoZCk7IH1cbiAgICAgICAgd2hpbGUoaSA+PSAwKSB7XG4gICAgICAgICAgaWYocCA8IGspIHtcbiAgICAgICAgICAgIGQgPSAodGhpc1tpXSYoKDE8PHApLTEpKTw8KGstcCk7XG4gICAgICAgICAgICBkIHw9IHRoaXNbLS1pXT4+KHArPXRoaXMuREItayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZCA9ICh0aGlzW2ldPj4ocC09aykpJmttO1xuICAgICAgICAgICAgaWYocCA8PSAwKSB7IHAgKz0gdGhpcy5EQjsgLS1pOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGQgPiAwKSBtID0gdHJ1ZTtcbiAgICAgICAgICBpZihtKSByICs9IGludDJjaGFyKGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbT9yOlwiMFwiO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIC10aGlzXG4gICAgZnVuY3Rpb24gYm5OZWdhdGUoKSB7IHZhciByID0gbmJpKCk7IEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLHIpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHB1YmxpYykgfHRoaXN8XG4gICAgZnVuY3Rpb24gYm5BYnMoKSB7IHJldHVybiAodGhpcy5zPDApP3RoaXMubmVnYXRlKCk6dGhpczsgfVxuXG4gICAgLy8gKHB1YmxpYykgcmV0dXJuICsgaWYgdGhpcyA+IGEsIC0gaWYgdGhpcyA8IGEsIDAgaWYgZXF1YWxcbiAgICBmdW5jdGlvbiBibkNvbXBhcmVUbyhhKSB7XG4gICAgICB2YXIgciA9IHRoaXMucy1hLnM7XG4gICAgICBpZihyICE9IDApIHJldHVybiByO1xuICAgICAgdmFyIGkgPSB0aGlzLnQ7XG4gICAgICByID0gaS1hLnQ7XG4gICAgICBpZihyICE9IDApIHJldHVybiAodGhpcy5zPDApPy1yOnI7XG4gICAgICB3aGlsZSgtLWkgPj0gMCkgaWYoKHI9dGhpc1tpXS1hW2ldKSAhPSAwKSByZXR1cm4gcjtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgYml0IGxlbmd0aCBvZiB0aGUgaW50ZWdlciB4XG4gICAgZnVuY3Rpb24gbmJpdHMoeCkge1xuICAgICAgdmFyIHIgPSAxLCB0O1xuICAgICAgaWYoKHQ9eD4+PjE2KSAhPSAwKSB7IHggPSB0OyByICs9IDE2OyB9XG4gICAgICBpZigodD14Pj44KSAhPSAwKSB7IHggPSB0OyByICs9IDg7IH1cbiAgICAgIGlmKCh0PXg+PjQpICE9IDApIHsgeCA9IHQ7IHIgKz0gNDsgfVxuICAgICAgaWYoKHQ9eD4+MikgIT0gMCkgeyB4ID0gdDsgciArPSAyOyB9XG4gICAgICBpZigodD14Pj4xKSAhPSAwKSB7IHggPSB0OyByICs9IDE7IH1cbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHJldHVybiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gXCJ0aGlzXCJcbiAgICBmdW5jdGlvbiBibkJpdExlbmd0aCgpIHtcbiAgICAgIGlmKHRoaXMudCA8PSAwKSByZXR1cm4gMDtcbiAgICAgIHJldHVybiB0aGlzLkRCKih0aGlzLnQtMSkrbmJpdHModGhpc1t0aGlzLnQtMV1eKHRoaXMucyZ0aGlzLkRNKSk7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgbipEQlxuICAgIGZ1bmN0aW9uIGJucERMU2hpZnRUbyhuLHIpIHtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yKGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHJbaStuXSA9IHRoaXNbaV07XG4gICAgICBmb3IoaSA9IG4tMTsgaSA+PSAwOyAtLWkpIHJbaV0gPSAwO1xuICAgICAgci50ID0gdGhpcy50K247XG4gICAgICByLnMgPSB0aGlzLnM7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gbipEQlxuICAgIGZ1bmN0aW9uIGJucERSU2hpZnRUbyhuLHIpIHtcbiAgICAgIGZvcih2YXIgaSA9IG47IGkgPCB0aGlzLnQ7ICsraSkgcltpLW5dID0gdGhpc1tpXTtcbiAgICAgIHIudCA9IE1hdGgubWF4KHRoaXMudC1uLDApO1xuICAgICAgci5zID0gdGhpcy5zO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIDw8IG5cbiAgICBmdW5jdGlvbiBibnBMU2hpZnRUbyhuLHIpIHtcbiAgICAgIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgICAgIHZhciBjYnMgPSB0aGlzLkRCLWJzO1xuICAgICAgdmFyIGJtID0gKDE8PGNicyktMTtcbiAgICAgIHZhciBkcyA9IE1hdGguZmxvb3Iobi90aGlzLkRCKSwgYyA9ICh0aGlzLnM8PGJzKSZ0aGlzLkRNLCBpO1xuICAgICAgZm9yKGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgcltpK2RzKzFdID0gKHRoaXNbaV0+PmNicyl8YztcbiAgICAgICAgYyA9ICh0aGlzW2ldJmJtKTw8YnM7XG4gICAgICB9XG4gICAgICBmb3IoaSA9IGRzLTE7IGkgPj0gMDsgLS1pKSByW2ldID0gMDtcbiAgICAgIHJbZHNdID0gYztcbiAgICAgIHIudCA9IHRoaXMudCtkcysxO1xuICAgICAgci5zID0gdGhpcy5zO1xuICAgICAgci5jbGFtcCgpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG5cbiAgICBmdW5jdGlvbiBibnBSU2hpZnRUbyhuLHIpIHtcbiAgICAgIHIucyA9IHRoaXMucztcbiAgICAgIHZhciBkcyA9IE1hdGguZmxvb3Iobi90aGlzLkRCKTtcbiAgICAgIGlmKGRzID49IHRoaXMudCkgeyByLnQgPSAwOyByZXR1cm47IH1cbiAgICAgIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgICAgIHZhciBjYnMgPSB0aGlzLkRCLWJzO1xuICAgICAgdmFyIGJtID0gKDE8PGJzKS0xO1xuICAgICAgclswXSA9IHRoaXNbZHNdPj5icztcbiAgICAgIGZvcih2YXIgaSA9IGRzKzE7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgICAgICByW2ktZHMtMV0gfD0gKHRoaXNbaV0mYm0pPDxjYnM7XG4gICAgICAgIHJbaS1kc10gPSB0aGlzW2ldPj5icztcbiAgICAgIH1cbiAgICAgIGlmKGJzID4gMCkgclt0aGlzLnQtZHMtMV0gfD0gKHRoaXMucyZibSk8PGNicztcbiAgICAgIHIudCA9IHRoaXMudC1kcztcbiAgICAgIHIuY2xhbXAoKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyAtIGFcbiAgICBmdW5jdGlvbiBibnBTdWJUbyhhLHIpIHtcbiAgICAgIHZhciBpID0gMCwgYyA9IDAsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbiAgICAgIHdoaWxlKGkgPCBtKSB7XG4gICAgICAgIGMgKz0gdGhpc1tpXS1hW2ldO1xuICAgICAgICByW2krK10gPSBjJnRoaXMuRE07XG4gICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICB9XG4gICAgICBpZihhLnQgPCB0aGlzLnQpIHtcbiAgICAgICAgYyAtPSBhLnM7XG4gICAgICAgIHdoaWxlKGkgPCB0aGlzLnQpIHtcbiAgICAgICAgICBjICs9IHRoaXNbaV07XG4gICAgICAgICAgcltpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgIH1cbiAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICAgIHdoaWxlKGkgPCBhLnQpIHtcbiAgICAgICAgICBjIC09IGFbaV07XG4gICAgICAgICAgcltpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgIH1cbiAgICAgICAgYyAtPSBhLnM7XG4gICAgICB9XG4gICAgICByLnMgPSAoYzwwKT8tMTowO1xuICAgICAgaWYoYyA8IC0xKSByW2krK10gPSB0aGlzLkRWK2M7XG4gICAgICBlbHNlIGlmKGMgPiAwKSByW2krK10gPSBjO1xuICAgICAgci50ID0gaTtcbiAgICAgIHIuY2xhbXAoKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyAqIGEsIHIgIT0gdGhpcyxhIChIQUMgMTQuMTIpXG4gICAgLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuICAgIGZ1bmN0aW9uIGJucE11bHRpcGx5VG8oYSxyKSB7XG4gICAgICB2YXIgeCA9IHRoaXMuYWJzKCksIHkgPSBhLmFicygpO1xuICAgICAgdmFyIGkgPSB4LnQ7XG4gICAgICByLnQgPSBpK3kudDtcbiAgICAgIHdoaWxlKC0taSA+PSAwKSByW2ldID0gMDtcbiAgICAgIGZvcihpID0gMDsgaSA8IHkudDsgKytpKSByW2kreC50XSA9IHguYW0oMCx5W2ldLHIsaSwwLHgudCk7XG4gICAgICByLnMgPSAwO1xuICAgICAgci5jbGFtcCgpO1xuICAgICAgaWYodGhpcy5zICE9IGEucykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIscik7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXNeMiwgciAhPSB0aGlzIChIQUMgMTQuMTYpXG4gICAgZnVuY3Rpb24gYm5wU3F1YXJlVG8ocikge1xuICAgICAgdmFyIHggPSB0aGlzLmFicygpO1xuICAgICAgdmFyIGkgPSByLnQgPSAyKngudDtcbiAgICAgIHdoaWxlKC0taSA+PSAwKSByW2ldID0gMDtcbiAgICAgIGZvcihpID0gMDsgaSA8IHgudC0xOyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSB4LmFtKGkseFtpXSxyLDIqaSwwLDEpO1xuICAgICAgICBpZigocltpK3gudF0rPXguYW0oaSsxLDIqeFtpXSxyLDIqaSsxLGMseC50LWktMSkpID49IHguRFYpIHtcbiAgICAgICAgICByW2kreC50XSAtPSB4LkRWO1xuICAgICAgICAgIHJbaSt4LnQrMV0gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihyLnQgPiAwKSByW3IudC0xXSArPSB4LmFtKGkseFtpXSxyLDIqaSwwLDEpO1xuICAgICAgci5zID0gMDtcbiAgICAgIHIuY2xhbXAoKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSBkaXZpZGUgdGhpcyBieSBtLCBxdW90aWVudCBhbmQgcmVtYWluZGVyIHRvIHEsIHIgKEhBQyAxNC4yMClcbiAgICAvLyByICE9IHEsIHRoaXMgIT0gbS4gIHEgb3IgciBtYXkgYmUgbnVsbC5cbiAgICBmdW5jdGlvbiBibnBEaXZSZW1UbyhtLHEscikge1xuICAgICAgdmFyIHBtID0gbS5hYnMoKTtcbiAgICAgIGlmKHBtLnQgPD0gMCkgcmV0dXJuO1xuICAgICAgdmFyIHB0ID0gdGhpcy5hYnMoKTtcbiAgICAgIGlmKHB0LnQgPCBwbS50KSB7XG4gICAgICAgIGlmKHEgIT0gbnVsbCkgcS5mcm9tSW50KDApO1xuICAgICAgICBpZihyICE9IG51bGwpIHRoaXMuY29weVRvKHIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZihyID09IG51bGwpIHIgPSBuYmkoKTtcbiAgICAgIHZhciB5ID0gbmJpKCksIHRzID0gdGhpcy5zLCBtcyA9IG0ucztcbiAgICAgIHZhciBuc2ggPSB0aGlzLkRCLW5iaXRzKHBtW3BtLnQtMV0pOyAgIC8vIG5vcm1hbGl6ZSBtb2R1bHVzXG4gICAgICBpZihuc2ggPiAwKSB7IHBtLmxTaGlmdFRvKG5zaCx5KTsgcHQubFNoaWZ0VG8obnNoLHIpOyB9XG4gICAgICBlbHNlIHsgcG0uY29weVRvKHkpOyBwdC5jb3B5VG8ocik7IH1cbiAgICAgIHZhciB5cyA9IHkudDtcbiAgICAgIHZhciB5MCA9IHlbeXMtMV07XG4gICAgICBpZih5MCA9PSAwKSByZXR1cm47XG4gICAgICB2YXIgeXQgPSB5MCooMTw8dGhpcy5GMSkrKCh5cz4xKT95W3lzLTJdPj50aGlzLkYyOjApO1xuICAgICAgdmFyIGQxID0gdGhpcy5GVi95dCwgZDIgPSAoMTw8dGhpcy5GMSkveXQsIGUgPSAxPDx0aGlzLkYyO1xuICAgICAgdmFyIGkgPSByLnQsIGogPSBpLXlzLCB0ID0gKHE9PW51bGwpP25iaSgpOnE7XG4gICAgICB5LmRsU2hpZnRUbyhqLHQpO1xuICAgICAgaWYoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgICAgICByW3IudCsrXSA9IDE7XG4gICAgICAgIHIuc3ViVG8odCxyKTtcbiAgICAgIH1cbiAgICAgIEJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbyh5cyx0KTtcbiAgICAgIHQuc3ViVG8oeSx5KTsgIC8vIFwibmVnYXRpdmVcIiB5IHNvIHdlIGNhbiByZXBsYWNlIHN1YiB3aXRoIGFtIGxhdGVyXG4gICAgICB3aGlsZSh5LnQgPCB5cykgeVt5LnQrK10gPSAwO1xuICAgICAgd2hpbGUoLS1qID49IDApIHtcbiAgICAgICAgLy8gRXN0aW1hdGUgcXVvdGllbnQgZGlnaXRcbiAgICAgICAgdmFyIHFkID0gKHJbLS1pXT09eTApP3RoaXMuRE06TWF0aC5mbG9vcihyW2ldKmQxKyhyW2ktMV0rZSkqZDIpO1xuICAgICAgICBpZigocltpXSs9eS5hbSgwLHFkLHIsaiwwLHlzKSkgPCBxZCkgeyAgIC8vIFRyeSBpdCBvdXRcbiAgICAgICAgICB5LmRsU2hpZnRUbyhqLHQpO1xuICAgICAgICAgIHIuc3ViVG8odCxyKTtcbiAgICAgICAgICB3aGlsZShyW2ldIDwgLS1xZCkgci5zdWJUbyh0LHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihxICE9IG51bGwpIHtcbiAgICAgICAgci5kclNoaWZ0VG8oeXMscSk7XG4gICAgICAgIGlmKHRzICE9IG1zKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocSxxKTtcbiAgICAgIH1cbiAgICAgIHIudCA9IHlzO1xuICAgICAgci5jbGFtcCgpO1xuICAgICAgaWYobnNoID4gMCkgci5yU2hpZnRUbyhuc2gscik7IC8vIERlbm9ybWFsaXplIHJlbWFpbmRlclxuICAgICAgaWYodHMgPCAwKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzIG1vZCBhXG4gICAgZnVuY3Rpb24gYm5Nb2QoYSkge1xuICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgIHRoaXMuYWJzKCkuZGl2UmVtVG8oYSxudWxsLHIpO1xuICAgICAgaWYodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgYS5zdWJUbyhyLHIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8gTW9kdWxhciByZWR1Y3Rpb24gdXNpbmcgXCJjbGFzc2ljXCIgYWxnb3JpdGhtXG4gICAgZnVuY3Rpb24gQ2xhc3NpYyhtKSB7IHRoaXMubSA9IG07IH1cbiAgICBmdW5jdGlvbiBjQ29udmVydCh4KSB7XG4gICAgICBpZih4LnMgPCAwIHx8IHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG4gICAgICBlbHNlIHJldHVybiB4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjUmV2ZXJ0KHgpIHsgcmV0dXJuIHg7IH1cbiAgICBmdW5jdGlvbiBjUmVkdWNlKHgpIHsgeC5kaXZSZW1Ubyh0aGlzLm0sbnVsbCx4KTsgfVxuICAgIGZ1bmN0aW9uIGNNdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgdGhpcy5yZWR1Y2Uocik7IH1cbiAgICBmdW5jdGlvbiBjU3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbiAgICBDbGFzc2ljLnByb3RvdHlwZS5jb252ZXJ0ID0gY0NvbnZlcnQ7XG4gICAgQ2xhc3NpYy5wcm90b3R5cGUucmV2ZXJ0ID0gY1JldmVydDtcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBjUmVkdWNlO1xuICAgIENsYXNzaWMucHJvdG90eXBlLm11bFRvID0gY011bFRvO1xuICAgIENsYXNzaWMucHJvdG90eXBlLnNxclRvID0gY1NxclRvO1xuXG4gICAgLy8gKHByb3RlY3RlZCkgcmV0dXJuIFwiLTEvdGhpcyAlIDJeREJcIjsgdXNlZnVsIGZvciBNb250LiByZWR1Y3Rpb25cbiAgICAvLyBqdXN0aWZpY2F0aW9uOlxuICAgIC8vICAgICAgICAgeHkgPT0gMSAobW9kIG0pXG4gICAgLy8gICAgICAgICB4eSA9ICAxK2ttXG4gICAgLy8gICB4eSgyLXh5KSA9ICgxK2ttKSgxLWttKVxuICAgIC8vIHhbeSgyLXh5KV0gPSAxLWteMm1eMlxuICAgIC8vIHhbeSgyLXh5KV0gPT0gMSAobW9kIG1eMilcbiAgICAvLyBpZiB5IGlzIDEveCBtb2QgbSwgdGhlbiB5KDIteHkpIGlzIDEveCBtb2QgbV4yXG4gICAgLy8gc2hvdWxkIHJlZHVjZSB4IGFuZCB5KDIteHkpIGJ5IG1eMiBhdCBlYWNoIHN0ZXAgdG8ga2VlcCBzaXplIGJvdW5kZWQuXG4gICAgLy8gSlMgbXVsdGlwbHkgXCJvdmVyZmxvd3NcIiBkaWZmZXJlbnRseSBmcm9tIEMvQysrLCBzbyBjYXJlIGlzIG5lZWRlZCBoZXJlLlxuICAgIGZ1bmN0aW9uIGJucEludkRpZ2l0KCkge1xuICAgICAgaWYodGhpcy50IDwgMSkgcmV0dXJuIDA7XG4gICAgICB2YXIgeCA9IHRoaXNbMF07XG4gICAgICBpZigoeCYxKSA9PSAwKSByZXR1cm4gMDtcbiAgICAgIHZhciB5ID0geCYzOyAgICAgICAvLyB5ID09IDEveCBtb2QgMl4yXG4gICAgICB5ID0gKHkqKDItKHgmMHhmKSp5KSkmMHhmOyAvLyB5ID09IDEveCBtb2QgMl40XG4gICAgICB5ID0gKHkqKDItKHgmMHhmZikqeSkpJjB4ZmY7ICAgLy8geSA9PSAxL3ggbW9kIDJeOFxuICAgICAgeSA9ICh5KigyLSgoKHgmMHhmZmZmKSp5KSYweGZmZmYpKSkmMHhmZmZmOyAgICAvLyB5ID09IDEveCBtb2QgMl4xNlxuICAgICAgLy8gbGFzdCBzdGVwIC0gY2FsY3VsYXRlIGludmVyc2UgbW9kIERWIGRpcmVjdGx5O1xuICAgICAgLy8gYXNzdW1lcyAxNiA8IERCIDw9IDMyIGFuZCBhc3N1bWVzIGFiaWxpdHkgdG8gaGFuZGxlIDQ4LWJpdCBpbnRzXG4gICAgICB5ID0gKHkqKDIteCp5JXRoaXMuRFYpKSV0aGlzLkRWOyAgICAgICAvLyB5ID09IDEveCBtb2QgMl5kYml0c1xuICAgICAgLy8gd2UgcmVhbGx5IHdhbnQgdGhlIG5lZ2F0aXZlIGludmVyc2UsIGFuZCAtRFYgPCB5IDwgRFZcbiAgICAgIHJldHVybiAoeT4wKT90aGlzLkRWLXk6LXk7XG4gICAgfVxuXG4gICAgLy8gTW9udGdvbWVyeSByZWR1Y3Rpb25cbiAgICBmdW5jdGlvbiBNb250Z29tZXJ5KG0pIHtcbiAgICAgIHRoaXMubSA9IG07XG4gICAgICB0aGlzLm1wID0gbS5pbnZEaWdpdCgpO1xuICAgICAgdGhpcy5tcGwgPSB0aGlzLm1wJjB4N2ZmZjtcbiAgICAgIHRoaXMubXBoID0gdGhpcy5tcD4+MTU7XG4gICAgICB0aGlzLnVtID0gKDE8PChtLkRCLTE1KSktMTtcbiAgICAgIHRoaXMubXQyID0gMiptLnQ7XG4gICAgfVxuXG4gICAgLy8geFIgbW9kIG1cbiAgICBmdW5jdGlvbiBtb250Q29udmVydCh4KSB7XG4gICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgeC5hYnMoKS5kbFNoaWZ0VG8odGhpcy5tLnQscik7XG4gICAgICByLmRpdlJlbVRvKHRoaXMubSxudWxsLHIpO1xuICAgICAgaWYoeC5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgdGhpcy5tLnN1YlRvKHIscik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyB4L1IgbW9kIG1cbiAgICBmdW5jdGlvbiBtb250UmV2ZXJ0KHgpIHtcbiAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICB4LmNvcHlUbyhyKTtcbiAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8geCA9IHgvUiBtb2QgbSAoSEFDIDE0LjMyKVxuICAgIGZ1bmN0aW9uIG1vbnRSZWR1Y2UoeCkge1xuICAgICAgd2hpbGUoeC50IDw9IHRoaXMubXQyKSAvLyBwYWQgeCBzbyBhbSBoYXMgZW5vdWdoIHJvb20gbGF0ZXJcbiAgICAgICAgeFt4LnQrK10gPSAwO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubS50OyArK2kpIHtcbiAgICAgICAgLy8gZmFzdGVyIHdheSBvZiBjYWxjdWxhdGluZyB1MCA9IHhbaV0qbXAgbW9kIERWXG4gICAgICAgIHZhciBqID0geFtpXSYweDdmZmY7XG4gICAgICAgIHZhciB1MCA9IChqKnRoaXMubXBsKygoKGoqdGhpcy5tcGgrKHhbaV0+PjE1KSp0aGlzLm1wbCkmdGhpcy51bSk8PDE1KSkmeC5ETTtcbiAgICAgICAgLy8gdXNlIGFtIHRvIGNvbWJpbmUgdGhlIG11bHRpcGx5LXNoaWZ0LWFkZCBpbnRvIG9uZSBjYWxsXG4gICAgICAgIGogPSBpK3RoaXMubS50O1xuICAgICAgICB4W2pdICs9IHRoaXMubS5hbSgwLHUwLHgsaSwwLHRoaXMubS50KTtcbiAgICAgICAgLy8gcHJvcGFnYXRlIGNhcnJ5XG4gICAgICAgIHdoaWxlKHhbal0gPj0geC5EVikgeyB4W2pdIC09IHguRFY7IHhbKytqXSsrOyB9XG4gICAgICB9XG4gICAgICB4LmNsYW1wKCk7XG4gICAgICB4LmRyU2hpZnRUbyh0aGlzLm0udCx4KTtcbiAgICAgIGlmKHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgeC5zdWJUbyh0aGlzLm0seCk7XG4gICAgfVxuXG4gICAgLy8gciA9IFwieF4yL1IgbW9kIG1cIjsgeCAhPSByXG4gICAgZnVuY3Rpb24gbW9udFNxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG4gICAgLy8gciA9IFwieHkvUiBtb2QgbVwiOyB4LHkgIT0gclxuICAgIGZ1bmN0aW9uIG1vbnRNdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLmNvbnZlcnQgPSBtb250Q29udmVydDtcbiAgICBNb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBtb250UmV2ZXJ0O1xuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLnJlZHVjZSA9IG1vbnRSZWR1Y2U7XG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUubXVsVG8gPSBtb250TXVsVG87XG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBtb250U3FyVG87XG5cbiAgICAvLyAocHJvdGVjdGVkKSB0cnVlIGlmZiB0aGlzIGlzIGV2ZW5cbiAgICBmdW5jdGlvbiBibnBJc0V2ZW4oKSB7IHJldHVybiAoKHRoaXMudD4wKT8odGhpc1swXSYxKTp0aGlzLnMpID09IDA7IH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXNeZSwgZSA8IDJeMzIsIGRvaW5nIHNxciBhbmQgbXVsIHdpdGggXCJyXCIgKEhBQyAxNC43OSlcbiAgICBmdW5jdGlvbiBibnBFeHAoZSx6KSB7XG4gICAgICBpZihlID4gMHhmZmZmZmZmZiB8fCBlIDwgMSkgcmV0dXJuIEJpZ0ludGVnZXIuT05FO1xuICAgICAgdmFyIHIgPSBuYmkoKSwgcjIgPSBuYmkoKSwgZyA9IHouY29udmVydCh0aGlzKSwgaSA9IG5iaXRzKGUpLTE7XG4gICAgICBnLmNvcHlUbyhyKTtcbiAgICAgIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgICAgIHouc3FyVG8ocixyMik7XG4gICAgICAgIGlmKChlJigxPDxpKSkgPiAwKSB6Lm11bFRvKHIyLGcscik7XG4gICAgICAgIGVsc2UgeyB2YXIgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gei5yZXZlcnQocik7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpc15lICUgbSwgMCA8PSBlIDwgMl4zMlxuICAgIGZ1bmN0aW9uIGJuTW9kUG93SW50KGUsbSkge1xuICAgICAgdmFyIHo7XG4gICAgICBpZihlIDwgMjU2IHx8IG0uaXNFdmVuKCkpIHogPSBuZXcgQ2xhc3NpYyhtKTsgZWxzZSB6ID0gbmV3IE1vbnRnb21lcnkobSk7XG4gICAgICByZXR1cm4gdGhpcy5leHAoZSx6KTtcbiAgICB9XG5cbiAgICAvLyBwcm90ZWN0ZWRcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb3B5VG8gPSBibnBDb3B5VG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbUludCA9IGJucEZyb21JbnQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGJucEZyb21TdHJpbmc7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY2xhbXAgPSBibnBDbGFtcDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kbFNoaWZ0VG8gPSBibnBETFNoaWZ0VG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZHJTaGlmdFRvID0gYm5wRFJTaGlmdFRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmxTaGlmdFRvID0gYm5wTFNoaWZ0VG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuclNoaWZ0VG8gPSBibnBSU2hpZnRUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJUbyA9IGJucFN1YlRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VG8gPSBibnBNdWx0aXBseVRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZVRvID0gYm5wU3F1YXJlVG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2UmVtVG8gPSBibnBEaXZSZW1UbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnZEaWdpdCA9IGJucEludkRpZ2l0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGJucElzRXZlbjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5leHAgPSBibnBFeHA7XG5cbiAgICAvLyBwdWJsaWNcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGJuVG9TdHJpbmc7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubmVnYXRlID0gYm5OZWdhdGU7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWJzID0gYm5BYnM7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gYm5Db21wYXJlVG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoID0gYm5CaXRMZW5ndGg7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kID0gYm5Nb2Q7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93SW50ID0gYm5Nb2RQb3dJbnQ7XG5cbiAgICAvLyBcImNvbnN0YW50c1wiXG4gICAgQmlnSW50ZWdlci5aRVJPID0gbmJ2KDApO1xuICAgIEJpZ0ludGVnZXIuT05FID0gbmJ2KDEpO1xuXG4gICAgLy8gQ29weXJpZ2h0IChjKSAyMDA1LTIwMDkgIFRvbSBXdVxuICAgIC8vIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgLy8gU2VlIFwiTElDRU5TRVwiIGZvciBkZXRhaWxzLlxuXG4gICAgLy8gRXh0ZW5kZWQgSmF2YVNjcmlwdCBCTiBmdW5jdGlvbnMsIHJlcXVpcmVkIGZvciBSU0EgcHJpdmF0ZSBvcHMuXG5cbiAgICAvLyBWZXJzaW9uIDEuMTogbmV3IEJpZ0ludGVnZXIoXCIwXCIsIDEwKSByZXR1cm5zIFwicHJvcGVyXCIgemVyb1xuICAgIC8vIFZlcnNpb24gMS4yOiBzcXVhcmUoKSBBUEksIGlzUHJvYmFibGVQcmltZSBmaXhcblxuICAgIC8vIChwdWJsaWMpXG4gICAgZnVuY3Rpb24gYm5DbG9uZSgpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5jb3B5VG8ocik7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgaW50ZWdlclxuICAgIGZ1bmN0aW9uIGJuSW50VmFsdWUoKSB7XG4gICAgICBpZih0aGlzLnMgPCAwKSB7XG4gICAgICAgIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpc1swXS10aGlzLkRWO1xuICAgICAgICBlbHNlIGlmKHRoaXMudCA9PSAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpc1swXTtcbiAgICAgIGVsc2UgaWYodGhpcy50ID09IDApIHJldHVybiAwO1xuICAgICAgLy8gYXNzdW1lcyAxNiA8IERCIDwgMzJcbiAgICAgIHJldHVybiAoKHRoaXNbMV0mKCgxPDwoMzItdGhpcy5EQikpLTEpKTw8dGhpcy5EQil8dGhpc1swXTtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgYnl0ZVxuICAgIGZ1bmN0aW9uIGJuQnl0ZVZhbHVlKCkgeyByZXR1cm4gKHRoaXMudD09MCk/dGhpcy5zOih0aGlzWzBdPDwyNCk+PjI0OyB9XG5cbiAgICAvLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgc2hvcnQgKGFzc3VtZXMgREI+PTE2KVxuICAgIGZ1bmN0aW9uIGJuU2hvcnRWYWx1ZSgpIHsgcmV0dXJuICh0aGlzLnQ9PTApP3RoaXMuczoodGhpc1swXTw8MTYpPj4xNjsgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgcmV0dXJuIHggcy50LiByXnggPCBEVlxuICAgIGZ1bmN0aW9uIGJucENodW5rU2l6ZShyKSB7IHJldHVybiBNYXRoLmZsb29yKE1hdGguTE4yKnRoaXMuREIvTWF0aC5sb2cocikpOyB9XG5cbiAgICAvLyAocHVibGljKSAwIGlmIHRoaXMgPT0gMCwgMSBpZiB0aGlzID4gMFxuICAgIGZ1bmN0aW9uIGJuU2lnTnVtKCkge1xuICAgICAgaWYodGhpcy5zIDwgMCkgcmV0dXJuIC0xO1xuICAgICAgZWxzZSBpZih0aGlzLnQgPD0gMCB8fCAodGhpcy50ID09IDEgJiYgdGhpc1swXSA8PSAwKSkgcmV0dXJuIDA7XG4gICAgICBlbHNlIHJldHVybiAxO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIGNvbnZlcnQgdG8gcmFkaXggc3RyaW5nXG4gICAgZnVuY3Rpb24gYm5wVG9SYWRpeChiKSB7XG4gICAgICBpZihiID09IG51bGwpIGIgPSAxMDtcbiAgICAgIGlmKHRoaXMuc2lnbnVtKCkgPT0gMCB8fCBiIDwgMiB8fCBiID4gMzYpIHJldHVybiBcIjBcIjtcbiAgICAgIHZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpO1xuICAgICAgdmFyIGEgPSBNYXRoLnBvdyhiLGNzKTtcbiAgICAgIHZhciBkID0gbmJ2KGEpLCB5ID0gbmJpKCksIHogPSBuYmkoKSwgciA9IFwiXCI7XG4gICAgICB0aGlzLmRpdlJlbVRvKGQseSx6KTtcbiAgICAgIHdoaWxlKHkuc2lnbnVtKCkgPiAwKSB7XG4gICAgICAgIHIgPSAoYSt6LmludFZhbHVlKCkpLnRvU3RyaW5nKGIpLnN1YnN0cigxKSArIHI7XG4gICAgICAgIHkuZGl2UmVtVG8oZCx5LHopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHouaW50VmFsdWUoKS50b1N0cmluZyhiKSArIHI7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgY29udmVydCBmcm9tIHJhZGl4IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGJucEZyb21SYWRpeChzLGIpIHtcbiAgICAgIHRoaXMuZnJvbUludCgwKTtcbiAgICAgIGlmKGIgPT0gbnVsbCkgYiA9IDEwO1xuICAgICAgdmFyIGNzID0gdGhpcy5jaHVua1NpemUoYik7XG4gICAgICB2YXIgZCA9IE1hdGgucG93KGIsY3MpLCBtaSA9IGZhbHNlLCBqID0gMCwgdyA9IDA7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgeCA9IGludEF0KHMsaSk7XG4gICAgICAgIGlmKHggPCAwKSB7XG4gICAgICAgICAgaWYocy5jaGFyQXQoaSkgPT0gXCItXCIgJiYgdGhpcy5zaWdudW0oKSA9PSAwKSBtaSA9IHRydWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdyA9IGIqdyt4O1xuICAgICAgICBpZigrK2ogPj0gY3MpIHtcbiAgICAgICAgICB0aGlzLmRNdWx0aXBseShkKTtcbiAgICAgICAgICB0aGlzLmRBZGRPZmZzZXQodywwKTtcbiAgICAgICAgICBqID0gMDtcbiAgICAgICAgICB3ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoaiA+IDApIHtcbiAgICAgICAgdGhpcy5kTXVsdGlwbHkoTWF0aC5wb3coYixqKSk7XG4gICAgICAgIHRoaXMuZEFkZE9mZnNldCh3LDApO1xuICAgICAgfVxuICAgICAgaWYobWkpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLHRoaXMpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIGFsdGVybmF0ZSBjb25zdHJ1Y3RvclxuICAgIGZ1bmN0aW9uIGJucEZyb21OdW1iZXIoYSxiLGMpIHtcbiAgICAgIGlmKFwibnVtYmVyXCIgPT0gdHlwZW9mIGIpIHtcbiAgICAgICAgLy8gbmV3IEJpZ0ludGVnZXIoaW50LGludCxSTkcpXG4gICAgICAgIGlmKGEgPCAyKSB0aGlzLmZyb21JbnQoMSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuZnJvbU51bWJlcihhLGMpO1xuICAgICAgICAgIGlmKCF0aGlzLnRlc3RCaXQoYS0xKSlcdC8vIGZvcmNlIE1TQiBzZXRcbiAgICAgICAgICAgIHRoaXMuYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhLTEpLG9wX29yLHRoaXMpO1xuICAgICAgICAgIGlmKHRoaXMuaXNFdmVuKCkpIHRoaXMuZEFkZE9mZnNldCgxLDApOyAvLyBmb3JjZSBvZGRcbiAgICAgICAgICB3aGlsZSghdGhpcy5pc1Byb2JhYmxlUHJpbWUoYikpIHtcbiAgICAgICAgICAgIHRoaXMuZEFkZE9mZnNldCgyLDApO1xuICAgICAgICAgICAgaWYodGhpcy5iaXRMZW5ndGgoKSA+IGEpIHRoaXMuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEtMSksdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gbmV3IEJpZ0ludGVnZXIoaW50LFJORylcbiAgICAgICAgdmFyIHggPSBuZXcgQXJyYXkoKSwgdCA9IGEmNztcbiAgICAgICAgeC5sZW5ndGggPSAoYT4+MykrMTtcbiAgICAgICAgYi5uZXh0Qnl0ZXMoeCk7XG4gICAgICAgIGlmKHQgPiAwKSB4WzBdICY9ICgoMTw8dCktMSk7IGVsc2UgeFswXSA9IDA7XG4gICAgICAgIHRoaXMuZnJvbVN0cmluZyh4LDI1Nik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgY29udmVydCB0byBiaWdlbmRpYW4gYnl0ZSBhcnJheVxuICAgIGZ1bmN0aW9uIGJuVG9CeXRlQXJyYXkoKSB7XG4gICAgICB2YXIgaSA9IHRoaXMudCwgciA9IG5ldyBBcnJheSgpO1xuICAgICAgclswXSA9IHRoaXMucztcbiAgICAgIHZhciBwID0gdGhpcy5EQi0oaSp0aGlzLkRCKSU4LCBkLCBrID0gMDtcbiAgICAgIGlmKGktLSA+IDApIHtcbiAgICAgICAgaWYocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzW2ldPj5wKSAhPSAodGhpcy5zJnRoaXMuRE0pPj5wKVxuICAgICAgICAgIHJbaysrXSA9IGR8KHRoaXMuczw8KHRoaXMuREItcCkpO1xuICAgICAgICB3aGlsZShpID49IDApIHtcbiAgICAgICAgICBpZihwIDwgOCkge1xuICAgICAgICAgICAgZCA9ICh0aGlzW2ldJigoMTw8cCktMSkpPDwoOC1wKTtcbiAgICAgICAgICAgIGQgfD0gdGhpc1stLWldPj4ocCs9dGhpcy5EQi04KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkID0gKHRoaXNbaV0+PihwLT04KSkmMHhmZjtcbiAgICAgICAgICAgIGlmKHAgPD0gMCkgeyBwICs9IHRoaXMuREI7IC0taTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZigoZCYweDgwKSAhPSAwKSBkIHw9IC0yNTY7XG4gICAgICAgICAgaWYoayA9PSAwICYmICh0aGlzLnMmMHg4MCkgIT0gKGQmMHg4MCkpICsraztcbiAgICAgICAgICBpZihrID4gMCB8fCBkICE9IHRoaXMucykgcltrKytdID0gZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYm5FcXVhbHMoYSkgeyByZXR1cm4odGhpcy5jb21wYXJlVG8oYSk9PTApOyB9XG4gICAgZnVuY3Rpb24gYm5NaW4oYSkgeyByZXR1cm4odGhpcy5jb21wYXJlVG8oYSk8MCk/dGhpczphOyB9XG4gICAgZnVuY3Rpb24gYm5NYXgoYSkgeyByZXR1cm4odGhpcy5jb21wYXJlVG8oYSk+MCk/dGhpczphOyB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyBvcCBhIChiaXR3aXNlKVxuICAgIGZ1bmN0aW9uIGJucEJpdHdpc2VUbyhhLG9wLHIpIHtcbiAgICAgIHZhciBpLCBmLCBtID0gTWF0aC5taW4oYS50LHRoaXMudCk7XG4gICAgICBmb3IoaSA9IDA7IGkgPCBtOyArK2kpIHJbaV0gPSBvcCh0aGlzW2ldLGFbaV0pO1xuICAgICAgaWYoYS50IDwgdGhpcy50KSB7XG4gICAgICAgIGYgPSBhLnMmdGhpcy5ETTtcbiAgICAgICAgZm9yKGkgPSBtOyBpIDwgdGhpcy50OyArK2kpIHJbaV0gPSBvcCh0aGlzW2ldLGYpO1xuICAgICAgICByLnQgPSB0aGlzLnQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZiA9IHRoaXMucyZ0aGlzLkRNO1xuICAgICAgICBmb3IoaSA9IG07IGkgPCBhLnQ7ICsraSkgcltpXSA9IG9wKGYsYVtpXSk7XG4gICAgICAgIHIudCA9IGEudDtcbiAgICAgIH1cbiAgICAgIHIucyA9IG9wKHRoaXMucyxhLnMpO1xuICAgICAgci5jbGFtcCgpO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgJiBhXG4gICAgZnVuY3Rpb24gb3BfYW5kKHgseSkgeyByZXR1cm4geCZ5OyB9XG4gICAgZnVuY3Rpb24gYm5BbmQoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX2FuZCxyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgfCBhXG4gICAgZnVuY3Rpb24gb3Bfb3IoeCx5KSB7IHJldHVybiB4fHk7IH1cbiAgICBmdW5jdGlvbiBibk9yKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9vcixyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgXiBhXG4gICAgZnVuY3Rpb24gb3BfeG9yKHgseSkgeyByZXR1cm4geF55OyB9XG4gICAgZnVuY3Rpb24gYm5Yb3IoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX3hvcixyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgJiB+YVxuICAgIGZ1bmN0aW9uIG9wX2FuZG5vdCh4LHkpIHsgcmV0dXJuIHgmfnk7IH1cbiAgICBmdW5jdGlvbiBibkFuZE5vdChhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYml0d2lzZVRvKGEsb3BfYW5kbm90LHIpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHB1YmxpYykgfnRoaXNcbiAgICBmdW5jdGlvbiBibk5vdCgpIHtcbiAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpIHJbaV0gPSB0aGlzLkRNJn50aGlzW2ldO1xuICAgICAgci50ID0gdGhpcy50O1xuICAgICAgci5zID0gfnRoaXMucztcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgPDwgblxuICAgIGZ1bmN0aW9uIGJuU2hpZnRMZWZ0KG4pIHtcbiAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICBpZihuIDwgMCkgdGhpcy5yU2hpZnRUbygtbixyKTsgZWxzZSB0aGlzLmxTaGlmdFRvKG4scik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzID4+IG5cbiAgICBmdW5jdGlvbiBiblNoaWZ0UmlnaHQobikge1xuICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgIGlmKG4gPCAwKSB0aGlzLmxTaGlmdFRvKC1uLHIpOyBlbHNlIHRoaXMuclNoaWZ0VG8obixyKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBpbmRleCBvZiBsb3dlc3QgMS1iaXQgaW4geCwgeCA8IDJeMzFcbiAgICBmdW5jdGlvbiBsYml0KHgpIHtcbiAgICAgIGlmKHggPT0gMCkgcmV0dXJuIC0xO1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgaWYoKHgmMHhmZmZmKSA9PSAwKSB7IHggPj49IDE2OyByICs9IDE2OyB9XG4gICAgICBpZigoeCYweGZmKSA9PSAwKSB7IHggPj49IDg7IHIgKz0gODsgfVxuICAgICAgaWYoKHgmMHhmKSA9PSAwKSB7IHggPj49IDQ7IHIgKz0gNDsgfVxuICAgICAgaWYoKHgmMykgPT0gMCkgeyB4ID4+PSAyOyByICs9IDI7IH1cbiAgICAgIGlmKCh4JjEpID09IDApICsrcjtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHJldHVybnMgaW5kZXggb2YgbG93ZXN0IDEtYml0IChvciAtMSBpZiBub25lKVxuICAgIGZ1bmN0aW9uIGJuR2V0TG93ZXN0U2V0Qml0KCkge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKVxuICAgICAgICBpZih0aGlzW2ldICE9IDApIHJldHVybiBpKnRoaXMuREIrbGJpdCh0aGlzW2ldKTtcbiAgICAgIGlmKHRoaXMucyA8IDApIHJldHVybiB0aGlzLnQqdGhpcy5EQjtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gbnVtYmVyIG9mIDEgYml0cyBpbiB4XG4gICAgZnVuY3Rpb24gY2JpdCh4KSB7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICB3aGlsZSh4ICE9IDApIHsgeCAmPSB4LTE7ICsrcjsgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIG51bWJlciBvZiBzZXQgYml0c1xuICAgIGZ1bmN0aW9uIGJuQml0Q291bnQoKSB7XG4gICAgICB2YXIgciA9IDAsIHggPSB0aGlzLnMmdGhpcy5ETTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkgciArPSBjYml0KHRoaXNbaV1eeCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSB0cnVlIGlmZiBudGggYml0IGlzIHNldFxuICAgIGZ1bmN0aW9uIGJuVGVzdEJpdChuKSB7XG4gICAgICB2YXIgaiA9IE1hdGguZmxvb3Iobi90aGlzLkRCKTtcbiAgICAgIGlmKGogPj0gdGhpcy50KSByZXR1cm4odGhpcy5zIT0wKTtcbiAgICAgIHJldHVybigodGhpc1tqXSYoMTw8KG4ldGhpcy5EQikpKSE9MCk7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgdGhpcyBvcCAoMTw8bilcbiAgICBmdW5jdGlvbiBibnBDaGFuZ2VCaXQobixvcCkge1xuICAgICAgdmFyIHIgPSBCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQobik7XG4gICAgICB0aGlzLmJpdHdpc2VUbyhyLG9wLHIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyB8ICgxPDxuKVxuICAgIGZ1bmN0aW9uIGJuU2V0Qml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3Bfb3IpOyB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzICYgfigxPDxuKVxuICAgIGZ1bmN0aW9uIGJuQ2xlYXJCaXQobikgeyByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF9hbmRub3QpOyB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzIF4gKDE8PG4pXG4gICAgZnVuY3Rpb24gYm5GbGlwQml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3BfeG9yKTsgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgKyBhXG4gICAgZnVuY3Rpb24gYm5wQWRkVG8oYSxyKSB7XG4gICAgICB2YXIgaSA9IDAsIGMgPSAwLCBtID0gTWF0aC5taW4oYS50LHRoaXMudCk7XG4gICAgICB3aGlsZShpIDwgbSkge1xuICAgICAgICBjICs9IHRoaXNbaV0rYVtpXTtcbiAgICAgICAgcltpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgfVxuICAgICAgaWYoYS50IDwgdGhpcy50KSB7XG4gICAgICAgIGMgKz0gYS5zO1xuICAgICAgICB3aGlsZShpIDwgdGhpcy50KSB7XG4gICAgICAgICAgYyArPSB0aGlzW2ldO1xuICAgICAgICAgIHJbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICB9XG4gICAgICAgIGMgKz0gdGhpcy5zO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGMgKz0gdGhpcy5zO1xuICAgICAgICB3aGlsZShpIDwgYS50KSB7XG4gICAgICAgICAgYyArPSBhW2ldO1xuICAgICAgICAgIHJbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICB9XG4gICAgICAgIGMgKz0gYS5zO1xuICAgICAgfVxuICAgICAgci5zID0gKGM8MCk/LTE6MDtcbiAgICAgIGlmKGMgPiAwKSByW2krK10gPSBjO1xuICAgICAgZWxzZSBpZihjIDwgLTEpIHJbaSsrXSA9IHRoaXMuRFYrYztcbiAgICAgIHIudCA9IGk7XG4gICAgICByLmNsYW1wKCk7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyArIGFcbiAgICBmdW5jdGlvbiBibkFkZChhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYWRkVG8oYSxyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgLSBhXG4gICAgZnVuY3Rpb24gYm5TdWJ0cmFjdChhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuc3ViVG8oYSxyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgKiBhXG4gICAgZnVuY3Rpb24gYm5NdWx0aXBseShhKSB7IHZhciByID0gbmJpKCk7IHRoaXMubXVsdGlwbHlUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpc14yXG4gICAgZnVuY3Rpb24gYm5TcXVhcmUoKSB7IHZhciByID0gbmJpKCk7IHRoaXMuc3F1YXJlVG8ocik7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzIC8gYVxuICAgIGZ1bmN0aW9uIGJuRGl2aWRlKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLHIsbnVsbCk7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzICUgYVxuICAgIGZ1bmN0aW9uIGJuUmVtYWluZGVyKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLG51bGwscik7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSBbdGhpcy9hLHRoaXMlYV1cbiAgICBmdW5jdGlvbiBibkRpdmlkZUFuZFJlbWFpbmRlcihhKSB7XG4gICAgICB2YXIgcSA9IG5iaSgpLCByID0gbmJpKCk7XG4gICAgICB0aGlzLmRpdlJlbVRvKGEscSxyKTtcbiAgICAgIHJldHVybiBuZXcgQXJyYXkocSxyKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSB0aGlzICo9IG4sIHRoaXMgPj0gMCwgMSA8IG4gPCBEVlxuICAgIGZ1bmN0aW9uIGJucERNdWx0aXBseShuKSB7XG4gICAgICB0aGlzW3RoaXMudF0gPSB0aGlzLmFtKDAsbi0xLHRoaXMsMCwwLHRoaXMudCk7XG4gICAgICArK3RoaXMudDtcbiAgICAgIHRoaXMuY2xhbXAoKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSB0aGlzICs9IG4gPDwgdyB3b3JkcywgdGhpcyA+PSAwXG4gICAgZnVuY3Rpb24gYm5wREFkZE9mZnNldChuLHcpIHtcbiAgICAgIGlmKG4gPT0gMCkgcmV0dXJuO1xuICAgICAgd2hpbGUodGhpcy50IDw9IHcpIHRoaXNbdGhpcy50KytdID0gMDtcbiAgICAgIHRoaXNbd10gKz0gbjtcbiAgICAgIHdoaWxlKHRoaXNbd10gPj0gdGhpcy5EVikge1xuICAgICAgICB0aGlzW3ddIC09IHRoaXMuRFY7XG4gICAgICAgIGlmKCsrdyA+PSB0aGlzLnQpIHRoaXNbdGhpcy50KytdID0gMDtcbiAgICAgICAgKyt0aGlzW3ddO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEEgXCJudWxsXCIgcmVkdWNlclxuICAgIGZ1bmN0aW9uIE51bGxFeHAoKSB7fVxuICAgIGZ1bmN0aW9uIG5Ob3AoeCkgeyByZXR1cm4geDsgfVxuICAgIGZ1bmN0aW9uIG5NdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgfVxuICAgIGZ1bmN0aW9uIG5TcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgfVxuXG4gICAgTnVsbEV4cC5wcm90b3R5cGUuY29udmVydCA9IG5Ob3A7XG4gICAgTnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0ID0gbk5vcDtcbiAgICBOdWxsRXhwLnByb3RvdHlwZS5tdWxUbyA9IG5NdWxUbztcbiAgICBOdWxsRXhwLnByb3RvdHlwZS5zcXJUbyA9IG5TcXJUbztcblxuICAgIC8vIChwdWJsaWMpIHRoaXNeZVxuICAgIGZ1bmN0aW9uIGJuUG93KGUpIHsgcmV0dXJuIHRoaXMuZXhwKGUsbmV3IE51bGxFeHAoKSk7IH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSBsb3dlciBuIHdvcmRzIG9mIFwidGhpcyAqIGFcIiwgYS50IDw9IG5cbiAgICAvLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG4gICAgZnVuY3Rpb24gYm5wTXVsdGlwbHlMb3dlclRvKGEsbixyKSB7XG4gICAgICB2YXIgaSA9IE1hdGgubWluKHRoaXMudCthLnQsbik7XG4gICAgICByLnMgPSAwOyAvLyBhc3N1bWVzIGEsdGhpcyA+PSAwXG4gICAgICByLnQgPSBpO1xuICAgICAgd2hpbGUoaSA+IDApIHJbLS1pXSA9IDA7XG4gICAgICB2YXIgajtcbiAgICAgIGZvcihqID0gci50LXRoaXMudDsgaSA8IGo7ICsraSkgcltpK3RoaXMudF0gPSB0aGlzLmFtKDAsYVtpXSxyLGksMCx0aGlzLnQpO1xuICAgICAgZm9yKGogPSBNYXRoLm1pbihhLnQsbik7IGkgPCBqOyArK2kpIHRoaXMuYW0oMCxhW2ldLHIsaSwwLG4taSk7XG4gICAgICByLmNsYW1wKCk7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IFwidGhpcyAqIGFcIiB3aXRob3V0IGxvd2VyIG4gd29yZHMsIG4gPiAwXG4gICAgLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuICAgIGZ1bmN0aW9uIGJucE11bHRpcGx5VXBwZXJUbyhhLG4scikge1xuICAgICAgLS1uO1xuICAgICAgdmFyIGkgPSByLnQgPSB0aGlzLnQrYS50LW47XG4gICAgICByLnMgPSAwOyAvLyBhc3N1bWVzIGEsdGhpcyA+PSAwXG4gICAgICB3aGlsZSgtLWkgPj0gMCkgcltpXSA9IDA7XG4gICAgICBmb3IoaSA9IE1hdGgubWF4KG4tdGhpcy50LDApOyBpIDwgYS50OyArK2kpXG4gICAgICAgIHJbdGhpcy50K2ktbl0gPSB0aGlzLmFtKG4taSxhW2ldLHIsMCwwLHRoaXMudCtpLW4pO1xuICAgICAgci5jbGFtcCgpO1xuICAgICAgci5kclNoaWZ0VG8oMSxyKTtcbiAgICB9XG5cbiAgICAvLyBCYXJyZXR0IG1vZHVsYXIgcmVkdWN0aW9uXG4gICAgZnVuY3Rpb24gQmFycmV0dChtKSB7XG4gICAgICAvLyBzZXR1cCBCYXJyZXR0XG4gICAgICB0aGlzLnIyID0gbmJpKCk7XG4gICAgICB0aGlzLnEzID0gbmJpKCk7XG4gICAgICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oMiptLnQsdGhpcy5yMik7XG4gICAgICB0aGlzLm11ID0gdGhpcy5yMi5kaXZpZGUobSk7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJhcnJldHRDb252ZXJ0KHgpIHtcbiAgICAgIGlmKHgucyA8IDAgfHwgeC50ID4gMip0aGlzLm0udCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG4gICAgICBlbHNlIGlmKHguY29tcGFyZVRvKHRoaXMubSkgPCAwKSByZXR1cm4geDtcbiAgICAgIGVsc2UgeyB2YXIgciA9IG5iaSgpOyB4LmNvcHlUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IHJldHVybiByOyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmFycmV0dFJldmVydCh4KSB7IHJldHVybiB4OyB9XG5cbiAgICAvLyB4ID0geCBtb2QgbSAoSEFDIDE0LjQyKVxuICAgIGZ1bmN0aW9uIGJhcnJldHRSZWR1Y2UoeCkge1xuICAgICAgeC5kclNoaWZ0VG8odGhpcy5tLnQtMSx0aGlzLnIyKTtcbiAgICAgIGlmKHgudCA+IHRoaXMubS50KzEpIHsgeC50ID0gdGhpcy5tLnQrMTsgeC5jbGFtcCgpOyB9XG4gICAgICB0aGlzLm11Lm11bHRpcGx5VXBwZXJUbyh0aGlzLnIyLHRoaXMubS50KzEsdGhpcy5xMyk7XG4gICAgICB0aGlzLm0ubXVsdGlwbHlMb3dlclRvKHRoaXMucTMsdGhpcy5tLnQrMSx0aGlzLnIyKTtcbiAgICAgIHdoaWxlKHguY29tcGFyZVRvKHRoaXMucjIpIDwgMCkgeC5kQWRkT2Zmc2V0KDEsdGhpcy5tLnQrMSk7XG4gICAgICB4LnN1YlRvKHRoaXMucjIseCk7XG4gICAgICB3aGlsZSh4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHguc3ViVG8odGhpcy5tLHgpO1xuICAgIH1cblxuICAgIC8vIHIgPSB4XjIgbW9kIG07IHggIT0gclxuICAgIGZ1bmN0aW9uIGJhcnJldHRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuICAgIC8vIHIgPSB4KnkgbW9kIG07IHgseSAhPSByXG4gICAgZnVuY3Rpb24gYmFycmV0dE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG4gICAgQmFycmV0dC5wcm90b3R5cGUuY29udmVydCA9IGJhcnJldHRDb252ZXJ0O1xuICAgIEJhcnJldHQucHJvdG90eXBlLnJldmVydCA9IGJhcnJldHRSZXZlcnQ7XG4gICAgQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gYmFycmV0dFJlZHVjZTtcbiAgICBCYXJyZXR0LnByb3RvdHlwZS5tdWxUbyA9IGJhcnJldHRNdWxUbztcbiAgICBCYXJyZXR0LnByb3RvdHlwZS5zcXJUbyA9IGJhcnJldHRTcXJUbztcblxuICAgIC8vIChwdWJsaWMpIHRoaXNeZSAlIG0gKEhBQyAxNC44NSlcbiAgICBmdW5jdGlvbiBibk1vZFBvdyhlLG0pIHtcbiAgICAgIHZhciBpID0gZS5iaXRMZW5ndGgoKSwgaywgciA9IG5idigxKSwgejtcbiAgICAgIGlmKGkgPD0gMCkgcmV0dXJuIHI7XG4gICAgICBlbHNlIGlmKGkgPCAxOCkgayA9IDE7XG4gICAgICBlbHNlIGlmKGkgPCA0OCkgayA9IDM7XG4gICAgICBlbHNlIGlmKGkgPCAxNDQpIGsgPSA0O1xuICAgICAgZWxzZSBpZihpIDwgNzY4KSBrID0gNTtcbiAgICAgIGVsc2UgayA9IDY7XG4gICAgICBpZihpIDwgOClcbiAgICAgICAgeiA9IG5ldyBDbGFzc2ljKG0pO1xuICAgICAgZWxzZSBpZihtLmlzRXZlbigpKVxuICAgICAgICB6ID0gbmV3IEJhcnJldHQobSk7XG4gICAgICBlbHNlXG4gICAgICAgIHogPSBuZXcgTW9udGdvbWVyeShtKTtcblxuICAgICAgLy8gcHJlY29tcHV0YXRpb25cbiAgICAgIHZhciBnID0gbmV3IEFycmF5KCksIG4gPSAzLCBrMSA9IGstMSwga20gPSAoMTw8ayktMTtcbiAgICAgIGdbMV0gPSB6LmNvbnZlcnQodGhpcyk7XG4gICAgICBpZihrID4gMSkge1xuICAgICAgICB2YXIgZzIgPSBuYmkoKTtcbiAgICAgICAgei5zcXJUbyhnWzFdLGcyKTtcbiAgICAgICAgd2hpbGUobiA8PSBrbSkge1xuICAgICAgICAgIGdbbl0gPSBuYmkoKTtcbiAgICAgICAgICB6Lm11bFRvKGcyLGdbbi0yXSxnW25dKTtcbiAgICAgICAgICBuICs9IDI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGogPSBlLnQtMSwgdywgaXMxID0gdHJ1ZSwgcjIgPSBuYmkoKSwgdDtcbiAgICAgIGkgPSBuYml0cyhlW2pdKS0xO1xuICAgICAgd2hpbGUoaiA+PSAwKSB7XG4gICAgICAgIGlmKGkgPj0gazEpIHcgPSAoZVtqXT4+KGktazEpKSZrbTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdyA9IChlW2pdJigoMTw8KGkrMSkpLTEpKTw8KGsxLWkpO1xuICAgICAgICAgIGlmKGogPiAwKSB3IHw9IGVbai0xXT4+KHRoaXMuREIraS1rMSk7XG4gICAgICAgIH1cblxuICAgICAgICBuID0gaztcbiAgICAgICAgd2hpbGUoKHcmMSkgPT0gMCkgeyB3ID4+PSAxOyAtLW47IH1cbiAgICAgICAgaWYoKGkgLT0gbikgPCAwKSB7IGkgKz0gdGhpcy5EQjsgLS1qOyB9XG4gICAgICAgIGlmKGlzMSkge1x0Ly8gcmV0ID09IDEsIGRvbid0IGJvdGhlciBzcXVhcmluZyBvciBtdWx0aXBseWluZyBpdFxuICAgICAgICAgIGdbd10uY29weVRvKHIpO1xuICAgICAgICAgIGlzMSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHdoaWxlKG4gPiAxKSB7IHouc3FyVG8ocixyMik7IHouc3FyVG8ocjIscik7IG4gLT0gMjsgfVxuICAgICAgICAgIGlmKG4gPiAwKSB6LnNxclRvKHIscjIpOyBlbHNlIHsgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gICAgICAgICAgei5tdWxUbyhyMixnW3ddLHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUoaiA+PSAwICYmIChlW2pdJigxPDxpKSkgPT0gMCkge1xuICAgICAgICAgIHouc3FyVG8ocixyMik7IHQgPSByOyByID0gcjI7IHIyID0gdDtcbiAgICAgICAgICBpZigtLWkgPCAwKSB7IGkgPSB0aGlzLkRCLTE7IC0tajsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gei5yZXZlcnQocik7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgZ2NkKHRoaXMsYSkgKEhBQyAxNC41NClcbiAgICBmdW5jdGlvbiBibkdDRChhKSB7XG4gICAgICB2YXIgeCA9ICh0aGlzLnM8MCk/dGhpcy5uZWdhdGUoKTp0aGlzLmNsb25lKCk7XG4gICAgICB2YXIgeSA9IChhLnM8MCk/YS5uZWdhdGUoKTphLmNsb25lKCk7XG4gICAgICBpZih4LmNvbXBhcmVUbyh5KSA8IDApIHsgdmFyIHQgPSB4OyB4ID0geTsgeSA9IHQ7IH1cbiAgICAgIHZhciBpID0geC5nZXRMb3dlc3RTZXRCaXQoKSwgZyA9IHkuZ2V0TG93ZXN0U2V0Qml0KCk7XG4gICAgICBpZihnIDwgMCkgcmV0dXJuIHg7XG4gICAgICBpZihpIDwgZykgZyA9IGk7XG4gICAgICBpZihnID4gMCkge1xuICAgICAgICB4LnJTaGlmdFRvKGcseCk7XG4gICAgICAgIHkuclNoaWZ0VG8oZyx5KTtcbiAgICAgIH1cbiAgICAgIHdoaWxlKHguc2lnbnVtKCkgPiAwKSB7XG4gICAgICAgIGlmKChpID0geC5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB4LnJTaGlmdFRvKGkseCk7XG4gICAgICAgIGlmKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB5LnJTaGlmdFRvKGkseSk7XG4gICAgICAgIGlmKHguY29tcGFyZVRvKHkpID49IDApIHtcbiAgICAgICAgICB4LnN1YlRvKHkseCk7XG4gICAgICAgICAgeC5yU2hpZnRUbygxLHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHkuc3ViVG8oeCx5KTtcbiAgICAgICAgICB5LnJTaGlmdFRvKDEseSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKGcgPiAwKSB5LmxTaGlmdFRvKGcseSk7XG4gICAgICByZXR1cm4geTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSB0aGlzICUgbiwgbiA8IDJeMjZcbiAgICBmdW5jdGlvbiBibnBNb2RJbnQobikge1xuICAgICAgaWYobiA8PSAwKSByZXR1cm4gMDtcbiAgICAgIHZhciBkID0gdGhpcy5EViVuLCByID0gKHRoaXMuczwwKT9uLTE6MDtcbiAgICAgIGlmKHRoaXMudCA+IDApXG4gICAgICAgIGlmKGQgPT0gMCkgciA9IHRoaXNbMF0lbjtcbiAgICAgICAgZWxzZSBmb3IodmFyIGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHIgPSAoZCpyK3RoaXNbaV0pJW47XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSAxL3RoaXMgJSBtIChIQUMgMTQuNjEpXG4gICAgZnVuY3Rpb24gYm5Nb2RJbnZlcnNlKG0pIHtcbiAgICAgIHZhciBhYyA9IG0uaXNFdmVuKCk7XG4gICAgICBpZigodGhpcy5pc0V2ZW4oKSAmJiBhYykgfHwgbS5zaWdudW0oKSA9PSAwKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xuICAgICAgdmFyIHUgPSBtLmNsb25lKCksIHYgPSB0aGlzLmNsb25lKCk7XG4gICAgICB2YXIgYSA9IG5idigxKSwgYiA9IG5idigwKSwgYyA9IG5idigwKSwgZCA9IG5idigxKTtcbiAgICAgIHdoaWxlKHUuc2lnbnVtKCkgIT0gMCkge1xuICAgICAgICB3aGlsZSh1LmlzRXZlbigpKSB7XG4gICAgICAgICAgdS5yU2hpZnRUbygxLHUpO1xuICAgICAgICAgIGlmKGFjKSB7XG4gICAgICAgICAgICBpZighYS5pc0V2ZW4oKSB8fCAhYi5pc0V2ZW4oKSkgeyBhLmFkZFRvKHRoaXMsYSk7IGIuc3ViVG8obSxiKTsgfVxuICAgICAgICAgICAgYS5yU2hpZnRUbygxLGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKCFiLmlzRXZlbigpKSBiLnN1YlRvKG0sYik7XG4gICAgICAgICAgYi5yU2hpZnRUbygxLGIpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKHYuaXNFdmVuKCkpIHtcbiAgICAgICAgICB2LnJTaGlmdFRvKDEsdik7XG4gICAgICAgICAgaWYoYWMpIHtcbiAgICAgICAgICAgIGlmKCFjLmlzRXZlbigpIHx8ICFkLmlzRXZlbigpKSB7IGMuYWRkVG8odGhpcyxjKTsgZC5zdWJUbyhtLGQpOyB9XG4gICAgICAgICAgICBjLnJTaGlmdFRvKDEsYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYoIWQuaXNFdmVuKCkpIGQuc3ViVG8obSxkKTtcbiAgICAgICAgICBkLnJTaGlmdFRvKDEsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodS5jb21wYXJlVG8odikgPj0gMCkge1xuICAgICAgICAgIHUuc3ViVG8odix1KTtcbiAgICAgICAgICBpZihhYykgYS5zdWJUbyhjLGEpO1xuICAgICAgICAgIGIuc3ViVG8oZCxiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2LnN1YlRvKHUsdik7XG4gICAgICAgICAgaWYoYWMpIGMuc3ViVG8oYSxjKTtcbiAgICAgICAgICBkLnN1YlRvKGIsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKHYuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xuICAgICAgaWYoZC5jb21wYXJlVG8obSkgPj0gMCkgcmV0dXJuIGQuc3VidHJhY3QobSk7XG4gICAgICBpZihkLnNpZ251bSgpIDwgMCkgZC5hZGRUbyhtLGQpOyBlbHNlIHJldHVybiBkO1xuICAgICAgaWYoZC5zaWdudW0oKSA8IDApIHJldHVybiBkLmFkZChtKTsgZWxzZSByZXR1cm4gZDtcbiAgICB9XG5cbiAgICB2YXIgbG93cHJpbWVzID0gWzIsMyw1LDcsMTEsMTMsMTcsMTksMjMsMjksMzEsMzcsNDEsNDMsNDcsNTMsNTksNjEsNjcsNzEsNzMsNzksODMsODksOTcsMTAxLDEwMywxMDcsMTA5LDExMywxMjcsMTMxLDEzNywxMzksMTQ5LDE1MSwxNTcsMTYzLDE2NywxNzMsMTc5LDE4MSwxOTEsMTkzLDE5NywxOTksMjExLDIyMywyMjcsMjI5LDIzMywyMzksMjQxLDI1MSwyNTcsMjYzLDI2OSwyNzEsMjc3LDI4MSwyODMsMjkzLDMwNywzMTEsMzEzLDMxNywzMzEsMzM3LDM0NywzNDksMzUzLDM1OSwzNjcsMzczLDM3OSwzODMsMzg5LDM5Nyw0MDEsNDA5LDQxOSw0MjEsNDMxLDQzMyw0MzksNDQzLDQ0OSw0NTcsNDYxLDQ2Myw0NjcsNDc5LDQ4Nyw0OTEsNDk5LDUwMyw1MDksNTIxLDUyMyw1NDEsNTQ3LDU1Nyw1NjMsNTY5LDU3MSw1NzcsNTg3LDU5Myw1OTksNjAxLDYwNyw2MTMsNjE3LDYxOSw2MzEsNjQxLDY0Myw2NDcsNjUzLDY1OSw2NjEsNjczLDY3Nyw2ODMsNjkxLDcwMSw3MDksNzE5LDcyNyw3MzMsNzM5LDc0Myw3NTEsNzU3LDc2MSw3NjksNzczLDc4Nyw3OTcsODA5LDgxMSw4MjEsODIzLDgyNyw4MjksODM5LDg1Myw4NTcsODU5LDg2Myw4NzcsODgxLDg4Myw4ODcsOTA3LDkxMSw5MTksOTI5LDkzNyw5NDEsOTQ3LDk1Myw5NjcsOTcxLDk3Nyw5ODMsOTkxLDk5N107XG4gICAgdmFyIGxwbGltID0gKDE8PDI2KS9sb3dwcmltZXNbbG93cHJpbWVzLmxlbmd0aC0xXTtcblxuICAgIC8vIChwdWJsaWMpIHRlc3QgcHJpbWFsaXR5IHdpdGggY2VydGFpbnR5ID49IDEtLjVedFxuICAgIGZ1bmN0aW9uIGJuSXNQcm9iYWJsZVByaW1lKHQpIHtcbiAgICAgIHZhciBpLCB4ID0gdGhpcy5hYnMoKTtcbiAgICAgIGlmKHgudCA9PSAxICYmIHhbMF0gPD0gbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV0pIHtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbG93cHJpbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmKHhbMF0gPT0gbG93cHJpbWVzW2ldKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYoeC5pc0V2ZW4oKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaSA9IDE7XG4gICAgICB3aGlsZShpIDwgbG93cHJpbWVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbSA9IGxvd3ByaW1lc1tpXSwgaiA9IGkrMTtcbiAgICAgICAgd2hpbGUoaiA8IGxvd3ByaW1lcy5sZW5ndGggJiYgbSA8IGxwbGltKSBtICo9IGxvd3ByaW1lc1tqKytdO1xuICAgICAgICBtID0geC5tb2RJbnQobSk7XG4gICAgICAgIHdoaWxlKGkgPCBqKSBpZihtJWxvd3ByaW1lc1tpKytdID09IDApIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4Lm1pbGxlclJhYmluKHQpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHRydWUgaWYgcHJvYmFibHkgcHJpbWUgKEhBQyA0LjI0LCBNaWxsZXItUmFiaW4pXG4gICAgZnVuY3Rpb24gYm5wTWlsbGVyUmFiaW4odCkge1xuICAgICAgdmFyIG4xID0gdGhpcy5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICB2YXIgayA9IG4xLmdldExvd2VzdFNldEJpdCgpO1xuICAgICAgaWYoayA8PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgciA9IG4xLnNoaWZ0UmlnaHQoayk7XG4gICAgICB0ID0gKHQrMSk+PjE7XG4gICAgICBpZih0ID4gbG93cHJpbWVzLmxlbmd0aCkgdCA9IGxvd3ByaW1lcy5sZW5ndGg7XG4gICAgICB2YXIgYSA9IG5iaSgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHQ7ICsraSkge1xuICAgICAgICAvL1BpY2sgYmFzZXMgYXQgcmFuZG9tLCBpbnN0ZWFkIG9mIHN0YXJ0aW5nIGF0IDJcbiAgICAgICAgYS5mcm9tSW50KGxvd3ByaW1lc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqbG93cHJpbWVzLmxlbmd0aCldKTtcbiAgICAgICAgdmFyIHkgPSBhLm1vZFBvdyhyLHRoaXMpO1xuICAgICAgICBpZih5LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgIT0gMCAmJiB5LmNvbXBhcmVUbyhuMSkgIT0gMCkge1xuICAgICAgICAgIHZhciBqID0gMTtcbiAgICAgICAgICB3aGlsZShqKysgPCBrICYmIHkuY29tcGFyZVRvKG4xKSAhPSAwKSB7XG4gICAgICAgICAgICB5ID0geS5tb2RQb3dJbnQoMix0aGlzKTtcbiAgICAgICAgICAgIGlmKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHkuY29tcGFyZVRvKG4xKSAhPSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIHByb3RlY3RlZFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNodW5rU2l6ZSA9IGJucENodW5rU2l6ZTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1JhZGl4ID0gYm5wVG9SYWRpeDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tUmFkaXggPSBibnBGcm9tUmFkaXg7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbU51bWJlciA9IGJucEZyb21OdW1iZXI7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYml0d2lzZVRvID0gYm5wQml0d2lzZVRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNoYW5nZUJpdCA9IGJucENoYW5nZUJpdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGRUbyA9IGJucEFkZFRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRNdWx0aXBseSA9IGJucERNdWx0aXBseTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kQWRkT2Zmc2V0ID0gYm5wREFkZE9mZnNldDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseUxvd2VyVG8gPSBibnBNdWx0aXBseUxvd2VyVG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlVcHBlclRvID0gYm5wTXVsdGlwbHlVcHBlclRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludCA9IGJucE1vZEludDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5taWxsZXJSYWJpbiA9IGJucE1pbGxlclJhYmluO1xuXG4gICAgLy8gcHVibGljXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY2xvbmUgPSBibkNsb25lO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmludFZhbHVlID0gYm5JbnRWYWx1ZTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ieXRlVmFsdWUgPSBibkJ5dGVWYWx1ZTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaG9ydFZhbHVlID0gYm5TaG9ydFZhbHVlO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNpZ251bSA9IGJuU2lnTnVtO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5ID0gYm5Ub0J5dGVBcnJheTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBibkVxdWFscztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5taW4gPSBibk1pbjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBibk1heDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBibkFuZDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5vciA9IGJuT3I7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUueG9yID0gYm5Yb3I7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kTm90ID0gYm5BbmROb3Q7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubm90ID0gYm5Ob3Q7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gYm5TaGlmdExlZnQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodCA9IGJuU2hpZnRSaWdodDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nZXRMb3dlc3RTZXRCaXQgPSBibkdldExvd2VzdFNldEJpdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRDb3VudCA9IGJuQml0Q291bnQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudGVzdEJpdCA9IGJuVGVzdEJpdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zZXRCaXQgPSBiblNldEJpdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGVhckJpdCA9IGJuQ2xlYXJCaXQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZmxpcEJpdCA9IGJuRmxpcEJpdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBibkFkZDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGJuU3VidHJhY3Q7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHkgPSBibk11bHRpcGx5O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZSA9IGJuRGl2aWRlO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IGJuUmVtYWluZGVyO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZUFuZFJlbWFpbmRlciA9IGJuRGl2aWRlQW5kUmVtYWluZGVyO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdyA9IGJuTW9kUG93O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBibk1vZEludmVyc2U7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUucG93ID0gYm5Qb3c7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZ2NkID0gYm5HQ0Q7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gYm5Jc1Byb2JhYmxlUHJpbWU7XG5cbiAgICAvLyBKU0JOLXNwZWNpZmljIGV4dGVuc2lvblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGJuU3F1YXJlO1xuXG4gICAgLy8gRXhwb3NlIHRoZSBCYXJyZXR0IGZ1bmN0aW9uXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuQmFycmV0dCA9IEJhcnJldHRcblxuICAgIC8vIEJpZ0ludGVnZXIgaW50ZXJmYWNlcyBub3QgaW1wbGVtZW50ZWQgaW4ganNibjpcblxuICAgIC8vIEJpZ0ludGVnZXIoaW50IHNpZ251bSwgYnl0ZVtdIG1hZ25pdHVkZSlcbiAgICAvLyBkb3VibGUgZG91YmxlVmFsdWUoKVxuICAgIC8vIGZsb2F0IGZsb2F0VmFsdWUoKVxuICAgIC8vIGludCBoYXNoQ29kZSgpXG4gICAgLy8gbG9uZyBsb25nVmFsdWUoKVxuICAgIC8vIHN0YXRpYyBCaWdJbnRlZ2VyIHZhbHVlT2YobG9uZyB2YWwpXG5cblx0Ly8gUmFuZG9tIG51bWJlciBnZW5lcmF0b3IgLSByZXF1aXJlcyBhIFBSTkcgYmFja2VuZCwgZS5nLiBwcm5nNC5qc1xuXG5cdC8vIEZvciBiZXN0IHJlc3VsdHMsIHB1dCBjb2RlIGxpa2Vcblx0Ly8gPGJvZHkgb25DbGljaz0ncm5nX3NlZWRfdGltZSgpOycgb25LZXlQcmVzcz0ncm5nX3NlZWRfdGltZSgpOyc+XG5cdC8vIGluIHlvdXIgbWFpbiBIVE1MIGRvY3VtZW50LlxuXG5cdHZhciBybmdfc3RhdGU7XG5cdHZhciBybmdfcG9vbDtcblx0dmFyIHJuZ19wcHRyO1xuXG5cdC8vIE1peCBpbiBhIDMyLWJpdCBpbnRlZ2VyIGludG8gdGhlIHBvb2xcblx0ZnVuY3Rpb24gcm5nX3NlZWRfaW50KHgpIHtcblx0ICBybmdfcG9vbFtybmdfcHB0cisrXSBePSB4ICYgMjU1O1xuXHQgIHJuZ19wb29sW3JuZ19wcHRyKytdIF49ICh4ID4+IDgpICYgMjU1O1xuXHQgIHJuZ19wb29sW3JuZ19wcHRyKytdIF49ICh4ID4+IDE2KSAmIDI1NTtcblx0ICBybmdfcG9vbFtybmdfcHB0cisrXSBePSAoeCA+PiAyNCkgJiAyNTU7XG5cdCAgaWYocm5nX3BwdHIgPj0gcm5nX3BzaXplKSBybmdfcHB0ciAtPSBybmdfcHNpemU7XG5cdH1cblxuXHQvLyBNaXggaW4gdGhlIGN1cnJlbnQgdGltZSAody9taWxsaXNlY29uZHMpIGludG8gdGhlIHBvb2xcblx0ZnVuY3Rpb24gcm5nX3NlZWRfdGltZSgpIHtcblx0ICBybmdfc2VlZF9pbnQobmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuXHR9XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgcG9vbCB3aXRoIGp1bmsgaWYgbmVlZGVkLlxuXHRpZihybmdfcG9vbCA9PSBudWxsKSB7XG5cdCAgcm5nX3Bvb2wgPSBuZXcgQXJyYXkoKTtcblx0ICBybmdfcHB0ciA9IDA7XG5cdCAgdmFyIHQ7XG5cdCAgaWYodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY3J5cHRvKSB7XG5cdFx0aWYgKHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG5cdFx0ICAvLyBVc2Ugd2ViY3J5cHRvIGlmIGF2YWlsYWJsZVxuXHRcdCAgdmFyIHVhID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuXHRcdCAgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXModWEpO1xuXHRcdCAgZm9yKHQgPSAwOyB0IDwgMzI7ICsrdClcblx0XHRcdHJuZ19wb29sW3JuZ19wcHRyKytdID0gdWFbdF07XG5cdFx0fVxuXHRcdGVsc2UgaWYobmF2aWdhdG9yLmFwcE5hbWUgPT0gXCJOZXRzY2FwZVwiICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uIDwgXCI1XCIpIHtcblx0XHQgIC8vIEV4dHJhY3QgZW50cm9weSAoMjU2IGJpdHMpIGZyb20gTlM0IFJORyBpZiBhdmFpbGFibGVcblx0XHQgIHZhciB6ID0gd2luZG93LmNyeXB0by5yYW5kb20oMzIpO1xuXHRcdCAgZm9yKHQgPSAwOyB0IDwgei5sZW5ndGg7ICsrdClcblx0XHRcdHJuZ19wb29sW3JuZ19wcHRyKytdID0gei5jaGFyQ29kZUF0KHQpICYgMjU1O1xuXHRcdH1cblx0ICB9XG5cdCAgd2hpbGUocm5nX3BwdHIgPCBybmdfcHNpemUpIHsgIC8vIGV4dHJhY3Qgc29tZSByYW5kb21uZXNzIGZyb20gTWF0aC5yYW5kb20oKVxuXHRcdHQgPSBNYXRoLmZsb29yKDY1NTM2ICogTWF0aC5yYW5kb20oKSk7XG5cdFx0cm5nX3Bvb2xbcm5nX3BwdHIrK10gPSB0ID4+PiA4O1xuXHRcdHJuZ19wb29sW3JuZ19wcHRyKytdID0gdCAmIDI1NTtcblx0ICB9XG5cdCAgcm5nX3BwdHIgPSAwO1xuXHQgIHJuZ19zZWVkX3RpbWUoKTtcblx0ICAvL3JuZ19zZWVkX2ludCh3aW5kb3cuc2NyZWVuWCk7XG5cdCAgLy9ybmdfc2VlZF9pbnQod2luZG93LnNjcmVlblkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm5nX2dldF9ieXRlKCkge1xuXHQgIGlmKHJuZ19zdGF0ZSA9PSBudWxsKSB7XG5cdFx0cm5nX3NlZWRfdGltZSgpO1xuXHRcdHJuZ19zdGF0ZSA9IHBybmdfbmV3c3RhdGUoKTtcblx0XHRybmdfc3RhdGUuaW5pdChybmdfcG9vbCk7XG5cdFx0Zm9yKHJuZ19wcHRyID0gMDsgcm5nX3BwdHIgPCBybmdfcG9vbC5sZW5ndGg7ICsrcm5nX3BwdHIpXG5cdFx0ICBybmdfcG9vbFtybmdfcHB0cl0gPSAwO1xuXHRcdHJuZ19wcHRyID0gMDtcblx0XHQvL3JuZ19wb29sID0gbnVsbDtcblx0ICB9XG5cdCAgLy8gVE9ETzogYWxsb3cgcmVzZWVkaW5nIGFmdGVyIGZpcnN0IHJlcXVlc3Rcblx0ICByZXR1cm4gcm5nX3N0YXRlLm5leHQoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJuZ19nZXRfYnl0ZXMoYmEpIHtcblx0ICB2YXIgaTtcblx0ICBmb3IoaSA9IDA7IGkgPCBiYS5sZW5ndGg7ICsraSkgYmFbaV0gPSBybmdfZ2V0X2J5dGUoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIFNlY3VyZVJhbmRvbSgpIHt9XG5cblx0U2VjdXJlUmFuZG9tLnByb3RvdHlwZS5uZXh0Qnl0ZXMgPSBybmdfZ2V0X2J5dGVzO1xuXG5cdC8vIHBybmc0LmpzIC0gdXNlcyBBcmNmb3VyIGFzIGEgUFJOR1xuXG5cdGZ1bmN0aW9uIEFyY2ZvdXIoKSB7XG5cdCAgdGhpcy5pID0gMDtcblx0ICB0aGlzLmogPSAwO1xuXHQgIHRoaXMuUyA9IG5ldyBBcnJheSgpO1xuXHR9XG5cblx0Ly8gSW5pdGlhbGl6ZSBhcmNmb3VyIGNvbnRleHQgZnJvbSBrZXksIGFuIGFycmF5IG9mIGludHMsIGVhY2ggZnJvbSBbMC4uMjU1XVxuXHRmdW5jdGlvbiBBUkM0aW5pdChrZXkpIHtcblx0ICB2YXIgaSwgaiwgdDtcblx0ICBmb3IoaSA9IDA7IGkgPCAyNTY7ICsraSlcblx0XHR0aGlzLlNbaV0gPSBpO1xuXHQgIGogPSAwO1xuXHQgIGZvcihpID0gMDsgaSA8IDI1NjsgKytpKSB7XG5cdFx0aiA9IChqICsgdGhpcy5TW2ldICsga2V5W2kgJSBrZXkubGVuZ3RoXSkgJiAyNTU7XG5cdFx0dCA9IHRoaXMuU1tpXTtcblx0XHR0aGlzLlNbaV0gPSB0aGlzLlNbal07XG5cdFx0dGhpcy5TW2pdID0gdDtcblx0ICB9XG5cdCAgdGhpcy5pID0gMDtcblx0ICB0aGlzLmogPSAwO1xuXHR9XG5cblx0ZnVuY3Rpb24gQVJDNG5leHQoKSB7XG5cdCAgdmFyIHQ7XG5cdCAgdGhpcy5pID0gKHRoaXMuaSArIDEpICYgMjU1O1xuXHQgIHRoaXMuaiA9ICh0aGlzLmogKyB0aGlzLlNbdGhpcy5pXSkgJiAyNTU7XG5cdCAgdCA9IHRoaXMuU1t0aGlzLmldO1xuXHQgIHRoaXMuU1t0aGlzLmldID0gdGhpcy5TW3RoaXMual07XG5cdCAgdGhpcy5TW3RoaXMual0gPSB0O1xuXHQgIHJldHVybiB0aGlzLlNbKHQgKyB0aGlzLlNbdGhpcy5pXSkgJiAyNTVdO1xuXHR9XG5cblx0QXJjZm91ci5wcm90b3R5cGUuaW5pdCA9IEFSQzRpbml0O1xuXHRBcmNmb3VyLnByb3RvdHlwZS5uZXh0ID0gQVJDNG5leHQ7XG5cblx0Ly8gUGx1ZyBpbiB5b3VyIFJORyBjb25zdHJ1Y3RvciBoZXJlXG5cdGZ1bmN0aW9uIHBybmdfbmV3c3RhdGUoKSB7XG5cdCAgcmV0dXJuIG5ldyBBcmNmb3VyKCk7XG5cdH1cblxuXHQvLyBQb29sIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQgYW5kIGdyZWF0ZXIgdGhhbiAzMi5cblx0Ly8gQW4gYXJyYXkgb2YgYnl0ZXMgdGhlIHNpemUgb2YgdGhlIHBvb2wgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpXG5cdHZhciBybmdfcHNpemUgPSAyNTY7XG5cbiAgQmlnSW50ZWdlci5TZWN1cmVSYW5kb20gPSBTZWN1cmVSYW5kb207XG4gIEJpZ0ludGVnZXIuQmlnSW50ZWdlciA9IEJpZ0ludGVnZXI7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBCaWdJbnRlZ2VyO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuQmlnSW50ZWdlciA9IEJpZ0ludGVnZXI7XG4gICAgdGhpcy5TZWN1cmVSYW5kb20gPSBTZWN1cmVSYW5kb207XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9pZHRva2VuLXZlcmlmaWVyL34vanNibi9pbmRleC5qcyIsInZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKTtcblxuZnVuY3Rpb24gcGFkZGluZyhzdHIpIHtcbiAgdmFyIG1vZCA9IChzdHIubGVuZ3RoICUgNCk7XG4gIHZhciBwYWQgPSA0IC0gbW9kO1xuXG4gIGlmIChtb2QgPT09IDApIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0ciArIChuZXcgQXJyYXkoMSArIHBhZCkpLmpvaW4oJz0nKTtcbn1cblxuZnVuY3Rpb24gYnl0ZUFycmF5VG9TdHJpbmcoYXJyYXkpIHtcbiAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlQXJyYXkoc3RyKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkoc3RyLmxlbmd0aCk7XG4gIGZvciAodmFyIGEgPSAwOyBhIDwgc3RyLmxlbmd0aDsgYSsrKSB7XG4gICAgYXJyW2FdID0gc3RyLmNoYXJDb2RlQXQoYSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gYnl0ZUFycmF5VG9IZXgocmF3KSB7XG4gIHZhciBIRVggPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfaGV4ID0gcmF3W2ldLnRvU3RyaW5nKDE2KTtcbiAgICBIRVggKz0gKF9oZXgubGVuZ3RoID09PSAyID8gX2hleCA6ICcwJyArIF9oZXgpO1xuICB9XG5cbiAgcmV0dXJuIEhFWDtcbn1cblxuZnVuY3Rpb24gZW5jb2RlU3RyaW5nKHN0cikge1xuICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoc3RyaW5nVG9CeXRlQXJyYXkoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvJShbMC05QS1GXXsyfSkvZywgZnVuY3Rpb24gKG1hdGNoLCBwMSkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCcweCcgKyBwMSk7XG4gIH0pKSlcbiAgLnJlcGxhY2UoL1xcKy9nLCAnLScpIC8vIENvbnZlcnQgJysnIHRvICctJ1xuICAucmVwbGFjZSgvXFwvL2csICdfJyk7IC8vIENvbnZlcnQgJy8nIHRvICdfJztcbn1cblxuZnVuY3Rpb24gZGVjb2RlVG9TdHJpbmcoc3RyKSB7XG4gIHN0ciA9IHBhZGRpbmcoc3RyKVxuICAgIC5yZXBsYWNlKC9cXC0vZywgJysnKSAvLyBDb252ZXJ0ICctJyB0byAnKydcbiAgICAucmVwbGFjZSgvXy9nLCAnLycpOyAvLyBDb252ZXJ0ICdfJyB0byAnLydcblxuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGJ5dGVBcnJheVRvU3RyaW5nKGJhc2U2NC50b0J5dGVBcnJheShzdHIpKS5zcGxpdCgnJykubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArICgnMDAnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICB9KS5qb2luKCcnKSk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVRvSEVYKHN0cikge1xuICByZXR1cm4gYnl0ZUFycmF5VG9IZXgoYmFzZTY0LnRvQnl0ZUFycmF5KHBhZGRpbmcoc3RyKSkpO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0Jhc2U2NFVybChiYXNlNjRTdHJpbmcpIHtcbiAgdmFyIFNBRkVfVVJMX0VOQ09ESU5HX01BUFBJTkcgPSB7XG4gICAgXCIrXCI6IFwiLVwiLFxuICAgIFwiL1wiOiBcIl9cIixcbiAgICBcIj1cIjogXCJcIlxuICB9O1xuXG4gIHJldHVybiBiYXNlNjRTdHJpbmcucmVwbGFjZSgvWysvPV0vZywgZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBTQUZFX1VSTF9FTkNPRElOR19NQVBQSU5HW21dO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuY29kZVN0cmluZzogZW5jb2RlU3RyaW5nLFxuICBkZWNvZGVUb1N0cmluZzogZGVjb2RlVG9TdHJpbmcsXG4gIGJ5dGVBcnJheVRvU3RyaW5nOiBieXRlQXJyYXlUb1N0cmluZyxcbiAgc3RyaW5nVG9CeXRlQXJyYXk6IHN0cmluZ1RvQnl0ZUFycmF5LFxuICBwYWRkaW5nOiBwYWRkaW5nLFxuICBieXRlQXJyYXlUb0hleDogYnl0ZUFycmF5VG9IZXgsXG4gIGRlY29kZVRvSEVYOiBkZWNvZGVUb0hFWCxcbiAgYmFzZTY0VG9CYXNlNjRVcmw6IGJhc2U2NFRvQmFzZTY0VXJsXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2lkdG9rZW4tdmVyaWZpZXIvc3JjL2hlbHBlcnMvYmFzZTY0LmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2lkdG9rZW4tdmVyaWZpZXIvfi9iYXNlNjQtanMvaW5kZXguanMiLCJ2YXIgdXJsam9pbiA9IHJlcXVpcmUoJ3VybC1qb2luJyk7XG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcbnZhciByZXF1ZXN0ID0gcmVxdWlyZSgnc3VwZXJhZ2VudCcpO1xuXG5mdW5jdGlvbiBwcm9jZXNzKGp3a3MpIHtcbiAgdmFyIG1vZHVsdXMgPSBiYXNlNjQuZGVjb2RlVG9IRVgoandrcy5uKTtcbiAgdmFyIGV4cCA9IGJhc2U2NC5kZWNvZGVUb0hFWChqd2tzLmUpO1xuXG4gIHJldHVybiB7XG4gICAgbW9kdWx1czogbW9kdWx1cyxcbiAgICBleHA6IGV4cFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRKV0tTKG9wdGlvbnMpIHtcbiAgdmFyIHVybCA9IG9wdGlvbnMuandrc1VSSSB8fCB1cmxqb2luKG9wdGlvbnMuaXNzLCAnLndlbGwta25vd24nLCAnandrcy5qc29uJyk7XG5cbiAgcmV0dXJuIHJlcXVlc3RcbiAgICAuZ2V0KHVybClcbiAgICAuZW5kKGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgIHZhciBtYXRjaGluZ0tleSA9IG51bGw7XG4gICAgICB2YXIgYTtcbiAgICAgIHZhciBrZXk7XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wbHVzcGx1c1xuICAgICAgZm9yIChhID0gMDsgYSA8IGRhdGEuYm9keS5rZXlzLmxlbmd0aCAmJiBtYXRjaGluZ0tleSA9PT0gbnVsbDsgYSsrKSB7XG4gICAgICAgIGtleSA9IGRhdGEuYm9keS5rZXlzW2FdO1xuICAgICAgICBpZiAoa2V5LmtpZCA9PT0gb3B0aW9ucy5raWQpIHtcbiAgICAgICAgICBtYXRjaGluZ0tleSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2Nlc3MobWF0Y2hpbmdLZXkpKTtcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHByb2Nlc3M6IHByb2Nlc3MsXG4gIGdldEpXS1M6IGdldEpXS1Ncbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vaWR0b2tlbi12ZXJpZmllci9zcmMvaGVscGVycy9qd2tzLmpzIiwiKGZ1bmN0aW9uIChuYW1lLCBjb250ZXh0LCBkZWZpbml0aW9uKSB7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGRlZmluaXRpb24pO1xuICBlbHNlIGNvbnRleHRbbmFtZV0gPSBkZWZpbml0aW9uKCk7XG59KSgndXJsam9pbicsIHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICBmdW5jdGlvbiBub3JtYWxpemUgKHN0ciwgb3B0aW9ucykge1xuXG4gICAgLy8gbWFrZSBzdXJlIHByb3RvY29sIGlzIGZvbGxvd2VkIGJ5IHR3byBzbGFzaGVzXG4gICAgc3RyID0gc3RyLnJlcGxhY2UoLzpcXC8vZywgJzovLycpO1xuXG4gICAgLy8gcmVtb3ZlIGNvbnNlY3V0aXZlIHNsYXNoZXNcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFteOlxcc10pXFwvKy9nLCAnJDEvJyk7XG5cbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2ggYmVmb3JlIHBhcmFtZXRlcnMgb3IgaGFzaFxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXC8oXFw/fCZ8I1teIV0pL2csICckMScpO1xuXG4gICAgLy8gcmVwbGFjZSA/IGluIHBhcmFtZXRlcnMgd2l0aCAmXG4gICAgc3RyID0gc3RyLnJlcGxhY2UoLyhcXD8uKylcXD8vZywgJyQxJicpO1xuXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlucHV0ID0gYXJndW1lbnRzO1xuICAgIHZhciBvcHRpb25zID0ge307XG5cbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIG5ldyBzeW50YXggd2l0aCBhcnJheSBhbmQgb3B0aW9uc1xuICAgICAgaW5wdXQgPSBhcmd1bWVudHNbMF07XG4gICAgICBvcHRpb25zID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuICAgIH1cblxuICAgIHZhciBqb2luZWQgPSBbXS5zbGljZS5jYWxsKGlucHV0LCAwKS5qb2luKCcvJyk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZShqb2luZWQsIG9wdGlvbnMpO1xuICB9O1xuXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9pZHRva2VuLXZlcmlmaWVyL34vdXJsLWpvaW4vbGliL3VybC1qb2luLmpzIiwiLyoqXG4gKiBSb290IHJlZmVyZW5jZSBmb3IgaWZyYW1lcy5cbiAqL1xuXG52YXIgcm9vdDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyAvLyBCcm93c2VyIHdpbmRvd1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gV2ViIFdvcmtlclxuICByb290ID0gc2VsZjtcbn0gZWxzZSB7IC8vIE90aGVyIGVudmlyb25tZW50c1xuICBjb25zb2xlLndhcm4oXCJVc2luZyBicm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGluIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuICByb290ID0gdGhpcztcbn1cblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIFJlcXVlc3RCYXNlID0gcmVxdWlyZSgnLi9yZXF1ZXN0LWJhc2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG52YXIgUmVzcG9uc2VCYXNlID0gcmVxdWlyZSgnLi9yZXNwb25zZS1iYXNlJyk7XG52YXIgQWdlbnQgPSByZXF1aXJlKCcuL2FnZW50LWJhc2UnKTtcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIG5vb3AoKXt9O1xuXG4vKipcbiAqIEV4cG9zZSBgcmVxdWVzdGAuXG4gKi9cblxudmFyIHJlcXVlc3QgPSBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIHVybCkge1xuICAvLyBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QoJ0dFVCcsIG1ldGhvZCkuZW5kKHVybCk7XG4gIH1cblxuICAvLyB1cmwgZmlyc3RcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QobWV0aG9kLCB1cmwpO1xufVxuXG5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIERldGVybWluZSBYSFIuXG4gKi9cblxucmVxdWVzdC5nZXRYSFIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChyb290LlhNTEh0dHBSZXF1ZXN0XG4gICAgICAmJiAoIXJvb3QubG9jYXRpb24gfHwgJ2ZpbGU6JyAhPSByb290LmxvY2F0aW9uLnByb3RvY29sXG4gICAgICAgICAgfHwgIXJvb3QuQWN0aXZlWE9iamVjdCkpIHtcbiAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0O1xuICB9IGVsc2Uge1xuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuNi4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjMuMCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gIH1cbiAgdGhyb3cgRXJyb3IoXCJCcm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGNvdWxkIG5vdCBmaW5kIFhIUlwiKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBhZGRlZCB0byBzdXBwb3J0IElFLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgdHJpbSA9ICcnLnRyaW1cbiAgPyBmdW5jdGlvbihzKSB7IHJldHVybiBzLnRyaW0oKTsgfVxuICA6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvKF5cXHMqfFxccyokKS9nLCAnJyk7IH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgdmFyIHBhaXJzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCBvYmpba2V5XSk7XG4gIH1cbiAgcmV0dXJuIHBhaXJzLmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBIZWxwcyAnc2VyaWFsaXplJyB3aXRoIHNlcmlhbGl6aW5nIGFycmF5cy5cbiAqIE11dGF0ZXMgdGhlIHBhaXJzIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCB2YWwpIHtcbiAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFsLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCB2KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgZm9yKHZhciBzdWJrZXkgaW4gdmFsKSB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXkgKyAnWycgKyBzdWJrZXkgKyAnXScsIHZhbFtzdWJrZXldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KVxuICAgICAgICArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2Ugc2VyaWFsaXphdGlvbiBtZXRob2QuXG4gKi9cblxucmVxdWVzdC5zZXJpYWxpemVPYmplY3QgPSBzZXJpYWxpemU7XG5cbi8qKlxuICAqIFBhcnNlIHRoZSBnaXZlbiB4LXd3dy1mb3JtLXVybGVuY29kZWQgYHN0cmAuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICogQHJldHVybiB7T2JqZWN0fVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICB2YXIgcGFpcnMgPSBzdHIuc3BsaXQoJyYnKTtcbiAgdmFyIHBhaXI7XG4gIHZhciBwb3M7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcGFpciA9IHBhaXJzW2ldO1xuICAgIHBvcyA9IHBhaXIuaW5kZXhPZignPScpO1xuICAgIGlmIChwb3MgPT0gLTEpIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpcildID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZSgwLCBwb3MpKV0gPVxuICAgICAgICBkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZShwb3MgKyAxKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBFeHBvc2UgcGFyc2VyLlxuICovXG5cbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcblxuLyoqXG4gKiBEZWZhdWx0IE1JTUUgdHlwZSBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICovXG5cbnJlcXVlc3QudHlwZXMgPSB7XG4gIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICBqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG4gIHhtbDogJ3RleHQveG1sJyxcbiAgdXJsZW5jb2RlZDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtLWRhdGEnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogc2VyaWFsaXplLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04uc3RyaW5naWZ5LFxufTtcblxuLyoqXG4gICogRGVmYXVsdCBwYXJzZXJzLlxuICAqXG4gICogICAgIHN1cGVyYWdlbnQucGFyc2VbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24oc3RyKXtcbiAgKiAgICAgICByZXR1cm4geyBvYmplY3QgcGFyc2VkIGZyb20gc3RyIH07XG4gICogICAgIH07XG4gICpcbiAgKi9cblxucmVxdWVzdC5wYXJzZSA9IHtcbiAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6IHBhcnNlU3RyaW5nLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04ucGFyc2UsXG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBoZWFkZXIgYHN0cmAgaW50b1xuICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hcHBlZCBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoc3RyKSB7XG4gIHZhciBsaW5lcyA9IHN0ci5zcGxpdCgvXFxyP1xcbi8pO1xuICB2YXIgZmllbGRzID0ge307XG4gIHZhciBpbmRleDtcbiAgdmFyIGxpbmU7XG4gIHZhciBmaWVsZDtcbiAgdmFyIHZhbDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG4gICAgaW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7IC8vIGNvdWxkIGJlIGVtcHR5IGxpbmUsIGp1c3Qgc2tpcCBpdFxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZpZWxkID0gbGluZS5zbGljZSgwLCBpbmRleCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB0cmltKGxpbmUuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgZmllbGRzW2ZpZWxkXSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiBmaWVsZHM7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG1pbWVgIGlzIGpzb24gb3IgaGFzICtqc29uIHN0cnVjdHVyZWQgc3ludGF4IHN1ZmZpeC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzSlNPTihtaW1lKSB7XG4gIC8vIHNob3VsZCBtYXRjaCAvanNvbiBvciAranNvblxuICAvLyBidXQgbm90IC9qc29uLXNlcVxuICByZXR1cm4gL1tcXC8rXWpzb24oJHxbXi1cXHddKS8udGVzdChtaW1lKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZWAgd2l0aCB0aGUgZ2l2ZW4gYHhocmAuXG4gKlxuICogIC0gc2V0IGZsYWdzICgub2ssIC5lcnJvciwgZXRjKVxuICogIC0gcGFyc2UgaGVhZGVyXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogIEFsaWFzaW5nIGBzdXBlcmFnZW50YCBhcyBgcmVxdWVzdGAgaXMgbmljZTpcbiAqXG4gKiAgICAgIHJlcXVlc3QgPSBzdXBlcmFnZW50O1xuICpcbiAqICBXZSBjYW4gdXNlIHRoZSBwcm9taXNlLWxpa2UgQVBJLCBvciBwYXNzIGNhbGxiYWNrczpcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJykuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJywgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgU2VuZGluZyBkYXRhIGNhbiBiZSBjaGFpbmVkOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5zZW5kKClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnBvc3QoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIE9yIGZ1cnRoZXIgcmVkdWNlZCB0byBhIHNpbmdsZSBjYWxsIGZvciBzaW1wbGUgY2FzZXM6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogQHBhcmFtIHtYTUxIVFRQUmVxdWVzdH0geGhyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2UocmVxKSB7XG4gIHRoaXMucmVxID0gcmVxO1xuICB0aGlzLnhociA9IHRoaXMucmVxLnhocjtcbiAgLy8gcmVzcG9uc2VUZXh0IGlzIGFjY2Vzc2libGUgb25seSBpZiByZXNwb25zZVR5cGUgaXMgJycgb3IgJ3RleHQnIGFuZCBvbiBvbGRlciBicm93c2Vyc1xuICB0aGlzLnRleHQgPSAoKHRoaXMucmVxLm1ldGhvZCAhPSdIRUFEJyAmJiAodGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAnJyB8fCB0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JykpIHx8IHR5cGVvZiB0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICd1bmRlZmluZWQnKVxuICAgICA/IHRoaXMueGhyLnJlc3BvbnNlVGV4dFxuICAgICA6IG51bGw7XG4gIHRoaXMuc3RhdHVzVGV4dCA9IHRoaXMucmVxLnhoci5zdGF0dXNUZXh0O1xuICB2YXIgc3RhdHVzID0gdGhpcy54aHIuc3RhdHVzO1xuICAvLyBoYW5kbGUgSUU5IGJ1ZzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDA0Njk3Mi9tc2llLXJldHVybnMtc3RhdHVzLWNvZGUtb2YtMTIyMy1mb3ItYWpheC1yZXF1ZXN0XG4gIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICBzdGF0dXMgPSAyMDQ7XG4gIH1cbiAgdGhpcy5fc2V0U3RhdHVzUHJvcGVydGllcyhzdGF0dXMpO1xuICB0aGlzLmhlYWRlciA9IHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVyKHRoaXMueGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcbiAgLy8gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIHNvbWV0aW1lcyBmYWxzZWx5IHJldHVybnMgXCJcIiBmb3IgQ09SUyByZXF1ZXN0cywgYnV0XG4gIC8vIGdldFJlc3BvbnNlSGVhZGVyIHN0aWxsIHdvcmtzLiBzbyB3ZSBnZXQgY29udGVudC10eXBlIGV2ZW4gaWYgZ2V0dGluZ1xuICAvLyBvdGhlciBoZWFkZXJzIGZhaWxzLlxuICB0aGlzLmhlYWRlclsnY29udGVudC10eXBlJ10gPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJyk7XG4gIHRoaXMuX3NldEhlYWRlclByb3BlcnRpZXModGhpcy5oZWFkZXIpO1xuXG4gIGlmIChudWxsID09PSB0aGlzLnRleHQgJiYgcmVxLl9yZXNwb25zZVR5cGUpIHtcbiAgICB0aGlzLmJvZHkgPSB0aGlzLnhoci5yZXNwb25zZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmJvZHkgPSB0aGlzLnJlcS5tZXRob2QgIT0gJ0hFQUQnXG4gICAgICA/IHRoaXMuX3BhcnNlQm9keSh0aGlzLnRleHQgPyB0aGlzLnRleHQgOiB0aGlzLnhoci5yZXNwb25zZSlcbiAgICAgIDogbnVsbDtcbiAgfVxufVxuXG5SZXNwb25zZUJhc2UoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYm9keSBgc3RyYC5cbiAqXG4gKiBVc2VkIGZvciBhdXRvLXBhcnNpbmcgb2YgYm9kaWVzLiBQYXJzZXJzXG4gKiBhcmUgZGVmaW5lZCBvbiB0aGUgYHN1cGVyYWdlbnQucGFyc2VgIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5fcGFyc2VCb2R5ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciBwYXJzZSA9IHJlcXVlc3QucGFyc2VbdGhpcy50eXBlXTtcbiAgaWYgKHRoaXMucmVxLl9wYXJzZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZXEuX3BhcnNlcih0aGlzLCBzdHIpO1xuICB9XG4gIGlmICghcGFyc2UgJiYgaXNKU09OKHRoaXMudHlwZSkpIHtcbiAgICBwYXJzZSA9IHJlcXVlc3QucGFyc2VbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgfVxuICByZXR1cm4gcGFyc2UgJiYgc3RyICYmIChzdHIubGVuZ3RoIHx8IHN0ciBpbnN0YW5jZW9mIE9iamVjdClcbiAgICA/IHBhcnNlKHN0cilcbiAgICA6IG51bGw7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbiBgRXJyb3JgIHJlcHJlc2VudGF0aXZlIG9mIHRoaXMgcmVzcG9uc2UuXG4gKlxuICogQHJldHVybiB7RXJyb3J9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS50b0Vycm9yID0gZnVuY3Rpb24oKXtcbiAgdmFyIHJlcSA9IHRoaXMucmVxO1xuICB2YXIgbWV0aG9kID0gcmVxLm1ldGhvZDtcbiAgdmFyIHVybCA9IHJlcS51cmw7XG5cbiAgdmFyIG1zZyA9ICdjYW5ub3QgJyArIG1ldGhvZCArICcgJyArIHVybCArICcgKCcgKyB0aGlzLnN0YXR1cyArICcpJztcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSBtZXRob2Q7XG4gIGVyci51cmwgPSB1cmw7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBSZXNwb25zZWAuXG4gKi9cblxucmVxdWVzdC5SZXNwb25zZSA9IFJlc3BvbnNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlcXVlc3RgIHdpdGggdGhlIGdpdmVuIGBtZXRob2RgIGFuZCBgdXJsYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9xdWVyeSA9IHRoaXMuX3F1ZXJ5IHx8IFtdO1xuICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgdGhpcy51cmwgPSB1cmw7XG4gIHRoaXMuaGVhZGVyID0ge307IC8vIHByZXNlcnZlcyBoZWFkZXIgbmFtZSBjYXNlXG4gIHRoaXMuX2hlYWRlciA9IHt9OyAvLyBjb2VyY2VzIGhlYWRlciBuYW1lcyB0byBsb3dlcmNhc2VcbiAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24oKXtcbiAgICB2YXIgZXJyID0gbnVsbDtcbiAgICB2YXIgcmVzID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICByZXMgPSBuZXcgUmVzcG9uc2Uoc2VsZik7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBlcnIgPSBuZXcgRXJyb3IoJ1BhcnNlciBpcyB1bmFibGUgdG8gcGFyc2UgdGhlIHJlc3BvbnNlJyk7XG4gICAgICBlcnIucGFyc2UgPSB0cnVlO1xuICAgICAgZXJyLm9yaWdpbmFsID0gZTtcbiAgICAgIC8vIGlzc3VlICM2NzU6IHJldHVybiB0aGUgcmF3IHJlc3BvbnNlIGlmIHRoZSByZXNwb25zZSBwYXJzaW5nIGZhaWxzXG4gICAgICBpZiAoc2VsZi54aHIpIHtcbiAgICAgICAgLy8gaWU5IGRvZXNuJ3QgaGF2ZSAncmVzcG9uc2UnIHByb3BlcnR5XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IHR5cGVvZiBzZWxmLnhoci5yZXNwb25zZVR5cGUgPT0gJ3VuZGVmaW5lZCcgPyBzZWxmLnhoci5yZXNwb25zZVRleHQgOiBzZWxmLnhoci5yZXNwb25zZTtcbiAgICAgICAgLy8gaXNzdWUgIzg3NjogcmV0dXJuIHRoZSBodHRwIHN0YXR1cyBjb2RlIGlmIHRoZSByZXNwb25zZSBwYXJzaW5nIGZhaWxzXG4gICAgICAgIGVyci5zdGF0dXMgPSBzZWxmLnhoci5zdGF0dXMgPyBzZWxmLnhoci5zdGF0dXMgOiBudWxsO1xuICAgICAgICBlcnIuc3RhdHVzQ29kZSA9IGVyci5zdGF0dXM7IC8vIGJhY2t3YXJkcy1jb21wYXQgb25seVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyLnJhd1Jlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1cyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlcyk7XG5cbiAgICB2YXIgbmV3X2VycjtcbiAgICB0cnkge1xuICAgICAgaWYgKCFzZWxmLl9pc1Jlc3BvbnNlT0socmVzKSkge1xuICAgICAgICBuZXdfZXJyID0gbmV3IEVycm9yKHJlcy5zdGF0dXNUZXh0IHx8ICdVbnN1Y2Nlc3NmdWwgSFRUUCByZXNwb25zZScpO1xuICAgICAgfVxuICAgIH0gY2F0Y2goY3VzdG9tX2Vycikge1xuICAgICAgbmV3X2VyciA9IGN1c3RvbV9lcnI7IC8vIG9rKCkgY2FsbGJhY2sgY2FuIHRocm93XG4gICAgfVxuXG4gICAgLy8gIzEwMDAgZG9uJ3QgY2F0Y2ggZXJyb3JzIGZyb20gdGhlIGNhbGxiYWNrIHRvIGF2b2lkIGRvdWJsZSBjYWxsaW5nIGl0XG4gICAgaWYgKG5ld19lcnIpIHtcbiAgICAgIG5ld19lcnIub3JpZ2luYWwgPSBlcnI7XG4gICAgICBuZXdfZXJyLnJlc3BvbnNlID0gcmVzO1xuICAgICAgbmV3X2Vyci5zdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgc2VsZi5jYWxsYmFjayhuZXdfZXJyLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBNaXhpbiBgRW1pdHRlcmAgYW5kIGBSZXF1ZXN0QmFzZWAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5SZXF1ZXN0QmFzZShSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0IENvbnRlbnQtVHlwZSB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgnYXBwbGljYXRpb24veG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odHlwZSl7XG4gIHRoaXMuc2V0KCdDb250ZW50LVR5cGUnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IEFjY2VwdCB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy5qc29uID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjZXB0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odHlwZSl7XG4gIHRoaXMuc2V0KCdBY2NlcHQnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IEF1dGhvcml6YXRpb24gZmllbGQgdmFsdWUgd2l0aCBgdXNlcmAgYW5kIGBwYXNzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXNlclxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXNzXSBvcHRpb25hbCBpbiBjYXNlIG9mIHVzaW5nICdiZWFyZXInIGFzIHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHdpdGggJ3R5cGUnIHByb3BlcnR5ICdhdXRvJywgJ2Jhc2ljJyBvciAnYmVhcmVyJyAoZGVmYXVsdCAnYmFzaWMnKVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbih1c2VyLCBwYXNzLCBvcHRpb25zKXtcbiAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHBhc3MgPSAnJztcbiAgaWYgKHR5cGVvZiBwYXNzID09PSAnb2JqZWN0JyAmJiBwYXNzICE9PSBudWxsKSB7IC8vIHBhc3MgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZXBsYWNlZCB3aXRoIG9wdGlvbnNcbiAgICBvcHRpb25zID0gcGFzcztcbiAgICBwYXNzID0gJyc7XG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6ICdmdW5jdGlvbicgPT09IHR5cGVvZiBidG9hID8gJ2Jhc2ljJyA6ICdhdXRvJyxcbiAgICB9O1xuICB9XG5cbiAgdmFyIGVuY29kZXIgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGJ0b2EpIHtcbiAgICAgIHJldHVybiBidG9hKHN0cmluZyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBiYXNpYyBhdXRoLCBidG9hIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH07XG5cbiAgcmV0dXJuIHRoaXMuX2F1dGgodXNlciwgcGFzcywgb3B0aW9ucywgZW5jb2Rlcik7XG59O1xuXG4vKipcbiAqIEFkZCBxdWVyeS1zdHJpbmcgYHZhbGAuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICByZXF1ZXN0LmdldCgnL3Nob2VzJylcbiAqICAgICAucXVlcnkoJ3NpemU9MTAnKVxuICogICAgIC5xdWVyeSh7IGNvbG9yOiAnYmx1ZScgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24odmFsKXtcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiB2YWwpIHZhbCA9IHNlcmlhbGl6ZSh2YWwpO1xuICBpZiAodmFsKSB0aGlzLl9xdWVyeS5wdXNoKHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBRdWV1ZSB0aGUgZ2l2ZW4gYGZpbGVgIGFzIGFuIGF0dGFjaG1lbnQgdG8gdGhlIHNwZWNpZmllZCBgZmllbGRgLFxuICogd2l0aCBvcHRpb25hbCBgb3B0aW9uc2AgKG9yIGZpbGVuYW1lKS5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5hdHRhY2goJ2NvbnRlbnQnLCBuZXcgQmxvYihbJzxhIGlkPVwiYVwiPjxiIGlkPVwiYlwiPmhleSE8L2I+PC9hPiddLCB7IHR5cGU6IFwidGV4dC9odG1sXCJ9KSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7QmxvYnxGaWxlfSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbihmaWVsZCwgZmlsZSwgb3B0aW9ucyl7XG4gIGlmIChmaWxlKSB7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHRocm93IEVycm9yKFwic3VwZXJhZ2VudCBjYW4ndCBtaXggLnNlbmQoKSBhbmQgLmF0dGFjaCgpXCIpO1xuICAgIH1cblxuICAgIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKGZpZWxkLCBmaWxlLCBvcHRpb25zIHx8IGZpbGUubmFtZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fZ2V0Rm9ybURhdGEgPSBmdW5jdGlvbigpe1xuICBpZiAoIXRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgdGhpcy5fZm9ybURhdGEgPSBuZXcgcm9vdC5Gb3JtRGF0YSgpO1xuICB9XG4gIHJldHVybiB0aGlzLl9mb3JtRGF0YTtcbn07XG5cbi8qKlxuICogSW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGBlcnJgIGFuZCBgcmVzYFxuICogYW5kIGhhbmRsZSBhcml0eSBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIHJlcyl7XG4gIGlmICh0aGlzLl9zaG91bGRSZXRyeShlcnIsIHJlcykpIHtcbiAgICByZXR1cm4gdGhpcy5fcmV0cnkoKTtcbiAgfVxuXG4gIHZhciBmbiA9IHRoaXMuX2NhbGxiYWNrO1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gIGlmIChlcnIpIHtcbiAgICBpZiAodGhpcy5fbWF4UmV0cmllcykgZXJyLnJldHJpZXMgPSB0aGlzLl9yZXRyaWVzIC0gMTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuXG4gIGZuKGVyciwgcmVzKTtcbn07XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggeC1kb21haW4gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3Jvc3NEb21haW5FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgaGFzIGJlZW4gdGVybWluYXRlZFxcblBvc3NpYmxlIGNhdXNlczogdGhlIG5ldHdvcmsgaXMgb2ZmbGluZSwgT3JpZ2luIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiwgdGhlIHBhZ2UgaXMgYmVpbmcgdW5sb2FkZWQsIGV0Yy4nKTtcbiAgZXJyLmNyb3NzRG9tYWluID0gdHJ1ZTtcblxuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSB0aGlzLm1ldGhvZDtcbiAgZXJyLnVybCA9IHRoaXMudXJsO1xuXG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8vIFRoaXMgb25seSB3YXJucywgYmVjYXVzZSB0aGUgcmVxdWVzdCBpcyBzdGlsbCBsaWtlbHkgdG8gd29ya1xuUmVxdWVzdC5wcm90b3R5cGUuYnVmZmVyID0gUmVxdWVzdC5wcm90b3R5cGUuY2EgPSBSZXF1ZXN0LnByb3RvdHlwZS5hZ2VudCA9IGZ1bmN0aW9uKCl7XG4gIGNvbnNvbGUud2FybihcIlRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2Ygc3VwZXJhZ2VudFwiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBUaGlzIHRocm93cywgYmVjYXVzZSBpdCBjYW4ndCBzZW5kL3JlY2VpdmUgZGF0YSBhcyBleHBlY3RlZFxuUmVxdWVzdC5wcm90b3R5cGUucGlwZSA9IFJlcXVlc3QucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oKXtcbiAgdGhyb3cgRXJyb3IoXCJTdHJlYW1pbmcgaXMgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2Ygc3VwZXJhZ2VudFwiKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBob3N0IG9iamVjdCxcbiAqIHdlIGRvbid0IHdhbnQgdG8gc2VyaWFsaXplIHRoZXNlIDopXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5SZXF1ZXN0LnByb3RvdHlwZS5faXNIb3N0ID0gZnVuY3Rpb24gX2lzSG9zdChvYmopIHtcbiAgLy8gTmF0aXZlIG9iamVjdHMgc3RyaW5naWZ5IHRvIFtvYmplY3QgRmlsZV0sIFtvYmplY3QgQmxvYl0sIFtvYmplY3QgRm9ybURhdGFdLCBldGMuXG4gIHJldHVybiBvYmogJiYgJ29iamVjdCcgPT09IHR5cGVvZiBvYmogJiYgIUFycmF5LmlzQXJyYXkob2JqKSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSAhPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogSW5pdGlhdGUgcmVxdWVzdCwgaW52b2tpbmcgY2FsbGJhY2sgYGZuKHJlcylgXG4gKiB3aXRoIGFuIGluc3RhbmNlb2YgYFJlc3BvbnNlYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGZuKXtcbiAgaWYgKHRoaXMuX2VuZENhbGxlZCkge1xuICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IC5lbmQoKSB3YXMgY2FsbGVkIHR3aWNlLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gc3VwZXJhZ2VudFwiKTtcbiAgfVxuICB0aGlzLl9lbmRDYWxsZWQgPSB0cnVlO1xuXG4gIC8vIHN0b3JlIGNhbGxiYWNrXG4gIHRoaXMuX2NhbGxiYWNrID0gZm4gfHwgbm9vcDtcblxuICAvLyBxdWVyeXN0cmluZ1xuICB0aGlzLl9maW5hbGl6ZVF1ZXJ5U3RyaW5nKCk7XG5cbiAgcmV0dXJuIHRoaXMuX2VuZCgpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2VuZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB4aHIgPSAodGhpcy54aHIgPSByZXF1ZXN0LmdldFhIUigpKTtcbiAgdmFyIGRhdGEgPSB0aGlzLl9mb3JtRGF0YSB8fCB0aGlzLl9kYXRhO1xuXG4gIHRoaXMuX3NldFRpbWVvdXRzKCk7XG5cbiAgLy8gc3RhdGUgY2hhbmdlXG4gIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPj0gMiAmJiBzZWxmLl9yZXNwb25zZVRpbWVvdXRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3Jlc3BvbnNlVGltZW91dFRpbWVyKTtcbiAgICB9XG4gICAgaWYgKDQgIT0gcmVhZHlTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluIElFOSwgcmVhZHMgdG8gYW55IHByb3BlcnR5IChlLmcuIHN0YXR1cykgb2ZmIG9mIGFuIGFib3J0ZWQgWEhSIHdpbGxcbiAgICAvLyByZXN1bHQgaW4gdGhlIGVycm9yIFwiQ291bGQgbm90IGNvbXBsZXRlIHRoZSBvcGVyYXRpb24gZHVlIHRvIGVycm9yIGMwMGMwMjNmXCJcbiAgICB2YXIgc3RhdHVzO1xuICAgIHRyeSB7IHN0YXR1cyA9IHhoci5zdGF0dXMgfSBjYXRjaChlKSB7IHN0YXR1cyA9IDA7IH1cblxuICAgIGlmICghc3RhdHVzKSB7XG4gICAgICBpZiAoc2VsZi50aW1lZG91dCB8fCBzZWxmLl9hYm9ydGVkKSByZXR1cm47XG4gICAgICByZXR1cm4gc2VsZi5jcm9zc0RvbWFpbkVycm9yKCk7XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZW5kJyk7XG4gIH07XG5cbiAgLy8gcHJvZ3Jlc3NcbiAgdmFyIGhhbmRsZVByb2dyZXNzID0gZnVuY3Rpb24oZGlyZWN0aW9uLCBlKSB7XG4gICAgaWYgKGUudG90YWwgPiAwKSB7XG4gICAgICBlLnBlcmNlbnQgPSBlLmxvYWRlZCAvIGUudG90YWwgKiAxMDA7XG4gICAgfVxuICAgIGUuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHNlbGYuZW1pdCgncHJvZ3Jlc3MnLCBlKTtcbiAgfTtcbiAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKCdwcm9ncmVzcycpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHhoci5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAnZG93bmxvYWQnKTtcbiAgICAgIGlmICh4aHIudXBsb2FkKSB7XG4gICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzLmJpbmQobnVsbCwgJ3VwbG9hZCcpO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgLy8gQWNjZXNzaW5nIHhoci51cGxvYWQgZmFpbHMgaW4gSUUgZnJvbSBhIHdlYiB3b3JrZXIsIHNvIGp1c3QgcHJldGVuZCBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgLy8gUmVwb3J0ZWQgaGVyZTpcbiAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvODM3MjQ1L3htbGh0dHByZXF1ZXN0LXVwbG9hZC10aHJvd3MtaW52YWxpZC1hcmd1bWVudC13aGVuLXVzZWQtZnJvbS13ZWItd29ya2VyLWNvbnRleHRcbiAgICB9XG4gIH1cblxuICAvLyBpbml0aWF0ZSByZXF1ZXN0XG4gIHRyeSB7XG4gICAgaWYgKHRoaXMudXNlcm5hbWUgJiYgdGhpcy5wYXNzd29yZCkge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlLCB0aGlzLnVzZXJuYW1lLCB0aGlzLnBhc3N3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIHNlZSAjMTE0OVxuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKGVycik7XG4gIH1cblxuICAvLyBDT1JTXG4gIGlmICh0aGlzLl93aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXG4gIC8vIGJvZHlcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSAmJiAnR0VUJyAhPSB0aGlzLm1ldGhvZCAmJiAnSEVBRCcgIT0gdGhpcy5tZXRob2QgJiYgJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgJiYgIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIC8vIHNlcmlhbGl6ZSBzdHVmZlxuICAgIHZhciBjb250ZW50VHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG4gICAgdmFyIHNlcmlhbGl6ZSA9IHRoaXMuX3NlcmlhbGl6ZXIgfHwgcmVxdWVzdC5zZXJpYWxpemVbY29udGVudFR5cGUgPyBjb250ZW50VHlwZS5zcGxpdCgnOycpWzBdIDogJyddO1xuICAgIGlmICghc2VyaWFsaXplICYmIGlzSlNPTihjb250ZW50VHlwZSkpIHtcbiAgICAgIHNlcmlhbGl6ZSA9IHJlcXVlc3Quc2VyaWFsaXplWydhcHBsaWNhdGlvbi9qc29uJ107XG4gICAgfVxuICAgIGlmIChzZXJpYWxpemUpIGRhdGEgPSBzZXJpYWxpemUoZGF0YSk7XG4gIH1cblxuICAvLyBzZXQgaGVhZGVyIGZpZWxkc1xuICBmb3IgKHZhciBmaWVsZCBpbiB0aGlzLmhlYWRlcikge1xuICAgIGlmIChudWxsID09IHRoaXMuaGVhZGVyW2ZpZWxkXSkgY29udGludWU7XG5cbiAgICBpZiAodGhpcy5oZWFkZXIuaGFzT3duUHJvcGVydHkoZmllbGQpKVxuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoZmllbGQsIHRoaXMuaGVhZGVyW2ZpZWxkXSk7XG4gIH1cblxuICBpZiAodGhpcy5fcmVzcG9uc2VUeXBlKSB7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IHRoaXMuX3Jlc3BvbnNlVHlwZTtcbiAgfVxuXG4gIC8vIHNlbmQgc3R1ZmZcbiAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgdGhpcyk7XG5cbiAgLy8gSUUxMSB4aHIuc2VuZCh1bmRlZmluZWQpIHNlbmRzICd1bmRlZmluZWQnIHN0cmluZyBhcyBQT1NUIHBheWxvYWQgKGluc3RlYWQgb2Ygbm90aGluZylcbiAgLy8gV2UgbmVlZCBudWxsIGhlcmUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgeGhyLnNlbmQodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnID8gZGF0YSA6IG51bGwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnJlcXVlc3QuYWdlbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBBZ2VudCgpO1xufTtcblxuW1wiR0VUXCIsIFwiUE9TVFwiLCBcIk9QVElPTlNcIiwgXCJQQVRDSFwiLCBcIlBVVFwiLCBcIkRFTEVURVwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBBZ2VudC5wcm90b3R5cGVbbWV0aG9kLnRvTG93ZXJDYXNlKCldID0gZnVuY3Rpb24odXJsLCBmbikge1xuICAgIHZhciByZXEgPSBuZXcgcmVxdWVzdC5SZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbiAgICB0aGlzLl9zZXREZWZhdWx0cyhyZXEpO1xuICAgIGlmIChmbikge1xuICAgICAgcmVxLmVuZChmbik7XG4gICAgfVxuICAgIHJldHVybiByZXE7XG4gIH07XG59KTtcblxuQWdlbnQucHJvdG90eXBlLmRlbCA9IEFnZW50LnByb3RvdHlwZVsnZGVsZXRlJ107XG5cbi8qKlxuICogR0VUIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5nZXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdHRVQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEucXVlcnkoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIEhFQUQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmhlYWQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdIRUFEJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBPUFRJT05TIHF1ZXJ5IHRvIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5vcHRpb25zID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnT1BUSU9OUycsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBERUxFVEUgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlbCh1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdERUxFVEUnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn1cblxucmVxdWVzdFsnZGVsJ10gPSBkZWw7XG5yZXF1ZXN0WydkZWxldGUnXSA9IGRlbDtcblxuLyoqXG4gKiBQQVRDSCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wYXRjaCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BBVENIJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBPU1QgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucG9zdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BPU1QnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUFVUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnB1dCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BVVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9pZHRva2VuLXZlcmlmaWVyL34vc3VwZXJhZ2VudC9saWIvY2xpZW50LmpzIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2lkdG9rZW4tdmVyaWZpZXIvfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgb2YgbWl4ZWQtaW4gZnVuY3Rpb25zIHNoYXJlZCBiZXR3ZWVuIG5vZGUgYW5kIGNsaWVudCBjb2RlXG4gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5cbi8qKlxuICogRXhwb3NlIGBSZXF1ZXN0QmFzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0QmFzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0QmFzZWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0QmFzZShvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59XG5cbi8qKlxuICogTWl4aW4gdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gUmVxdWVzdEJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIENsZWFyIHByZXZpb3VzIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCl7XG4gIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIGNsZWFyVGltZW91dCh0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcik7XG4gIGRlbGV0ZSB0aGlzLl90aW1lcjtcbiAgZGVsZXRlIHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXNwb25zZSBib2R5IHBhcnNlclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBpbmNvbWluZyBkYXRhIGludG8gcmVxdWVzdC5ib2R5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoZm4pe1xuICB0aGlzLl9wYXJzZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBmb3JtYXQgb2YgYmluYXJ5IHJlc3BvbnNlIGJvZHkuXG4gKiBJbiBicm93c2VyIHZhbGlkIGZvcm1hdHMgYXJlICdibG9iJyBhbmQgJ2FycmF5YnVmZmVyJyxcbiAqIHdoaWNoIHJldHVybiBCbG9iIGFuZCBBcnJheUJ1ZmZlciwgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEluIE5vZGUgYWxsIHZhbHVlcyByZXN1bHQgaW4gQnVmZmVyLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnJlc3BvbnNlVHlwZSgnYmxvYicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZXNwb25zZVR5cGUgPSBmdW5jdGlvbih2YWwpe1xuICB0aGlzLl9yZXNwb25zZVR5cGUgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlcXVlc3QgYm9keSBzZXJpYWxpemVyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGRhdGEgc2V0IHZpYSAuc2VuZCBvciAuYXR0YWNoIGludG8gcGF5bG9hZCB0byBzZW5kXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZShmbil7XG4gIHRoaXMuX3NlcmlhbGl6ZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aW1lb3V0cy5cbiAqXG4gKiAtIHJlc3BvbnNlIHRpbWVvdXQgaXMgdGltZSBiZXR3ZWVuIHNlbmRpbmcgcmVxdWVzdCBhbmQgcmVjZWl2aW5nIHRoZSBmaXJzdCBieXRlIG9mIHRoZSByZXNwb25zZS4gSW5jbHVkZXMgRE5TIGFuZCBjb25uZWN0aW9uIHRpbWUuXG4gKiAtIGRlYWRsaW5lIGlzIHRoZSB0aW1lIGZyb20gc3RhcnQgb2YgdGhlIHJlcXVlc3QgdG8gcmVjZWl2aW5nIHJlc3BvbnNlIGJvZHkgaW4gZnVsbC4gSWYgdGhlIGRlYWRsaW5lIGlzIHRvbyBzaG9ydCBsYXJnZSBmaWxlcyBtYXkgbm90IGxvYWQgYXQgYWxsIG9uIHNsb3cgY29ubmVjdGlvbnMuXG4gKlxuICogVmFsdWUgb2YgMCBvciBmYWxzZSBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gbXMgb3Ige3Jlc3BvbnNlLCBkZWFkbGluZX1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIHRpbWVvdXQob3B0aW9ucyl7XG4gIGlmICghb3B0aW9ucyB8fCAnb2JqZWN0JyAhPT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucztcbiAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZm9yKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgIHN3aXRjaChvcHRpb24pIHtcbiAgICAgIGNhc2UgJ2RlYWRsaW5lJzpcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnMuZGVhZGxpbmU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVzcG9uc2UnOlxuICAgICAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gdGltZW91dCBvcHRpb25cIiwgb3B0aW9uKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBudW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgb24gZXJyb3IuXG4gKlxuICogRmFpbGVkIHJlcXVlc3RzIHdpbGwgYmUgcmV0cmllZCAnY291bnQnIHRpbWVzIGlmIHRpbWVvdXQgb3IgZXJyLmNvZGUgPj0gNTAwLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZXRyeSA9IGZ1bmN0aW9uIHJldHJ5KGNvdW50LCBmbil7XG4gIC8vIERlZmF1bHQgdG8gMSBpZiBubyBjb3VudCBwYXNzZWQgb3IgdHJ1ZVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBjb3VudCA9PT0gdHJ1ZSkgY291bnQgPSAxO1xuICBpZiAoY291bnQgPD0gMCkgY291bnQgPSAwO1xuICB0aGlzLl9tYXhSZXRyaWVzID0gY291bnQ7XG4gIHRoaXMuX3JldHJpZXMgPSAwO1xuICB0aGlzLl9yZXRyeUNhbGxiYWNrID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIEVSUk9SX0NPREVTID0gW1xuICAnRUNPTk5SRVNFVCcsXG4gICdFVElNRURPVVQnLFxuICAnRUFERFJJTkZPJyxcbiAgJ0VTT0NLRVRUSU1FRE9VVCdcbl07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgcmVxdWVzdCBzaG91bGQgYmUgcmV0cmllZC5cbiAqIChCb3Jyb3dlZCBmcm9tIHNlZ21lbnRpby9zdXBlcmFnZW50LXJldHJ5KVxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gW3Jlc11cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3Nob3VsZFJldHJ5ID0gZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgaWYgKCF0aGlzLl9tYXhSZXRyaWVzIHx8IHRoaXMuX3JldHJpZXMrKyA+PSB0aGlzLl9tYXhSZXRyaWVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLl9yZXRyeUNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvdmVycmlkZSA9IHRoaXMuX3JldHJ5Q2FsbGJhY2soZXJyLCByZXMpO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIHVuZGVmaW5lZCBmYWxscyBiYWNrIHRvIGRlZmF1bHRzXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBpZiAocmVzICYmIHJlcy5zdGF0dXMgJiYgcmVzLnN0YXR1cyA+PSA1MDAgJiYgcmVzLnN0YXR1cyAhPSA1MDEpIHJldHVybiB0cnVlO1xuICBpZiAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICYmIH5FUlJPUl9DT0RFUy5pbmRleE9mKGVyci5jb2RlKSkgcmV0dXJuIHRydWU7XG4gICAgLy8gU3VwZXJhZ2VudCB0aW1lb3V0XG4gICAgaWYgKGVyci50aW1lb3V0ICYmIGVyci5jb2RlID09ICdFQ09OTkFCT1JURUQnKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXJyLmNyb3NzRG9tYWluKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHJ5IHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fcmV0cnkgPSBmdW5jdGlvbigpIHtcblxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gIC8vIG5vZGVcbiAgaWYgKHRoaXMucmVxKSB7XG4gICAgdGhpcy5yZXEgPSBudWxsO1xuICAgIHRoaXMucmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIH1cblxuICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7XG4gIHRoaXMudGltZWRvdXQgPSBmYWxzZTtcblxuICByZXR1cm4gdGhpcy5fZW5kKCk7XG59O1xuXG4vKipcbiAqIFByb21pc2Ugc3VwcG9ydFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gdGhlbihyZXNvbHZlLCByZWplY3QpIHtcbiAgaWYgKCF0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5fZW5kQ2FsbGVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBzdXBlcmFnZW50IHJlcXVlc3Qgd2FzIHNlbnQgdHdpY2UsIGJlY2F1c2UgYm90aCAuZW5kKCkgYW5kIC50aGVuKCkgd2VyZSBjYWxsZWQuIE5ldmVyIGNhbGwgLmVuZCgpIGlmIHlvdSB1c2UgcHJvbWlzZXNcIik7XG4gICAgfVxuICAgIHRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24oaW5uZXJSZXNvbHZlLCBpbm5lclJlamVjdCkge1xuICAgICAgc2VsZi5lbmQoZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKGVycikgaW5uZXJSZWplY3QoZXJyKTtcbiAgICAgICAgZWxzZSBpbm5lclJlc29sdmUocmVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihjYikge1xuICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgY2IpO1xufTtcblxuLyoqXG4gKiBBbGxvdyBmb3IgZXh0ZW5zaW9uXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmbikge1xuICBmbih0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUub2sgPSBmdW5jdGlvbihjYikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGNiKSB0aHJvdyBFcnJvcihcIkNhbGxiYWNrIHJlcXVpcmVkXCIpO1xuICB0aGlzLl9va0NhbGxiYWNrID0gY2I7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9pc1Jlc3BvbnNlT0sgPSBmdW5jdGlvbihyZXMpIHtcbiAgaWYgKCFyZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fb2tDYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9va0NhbGxiYWNrKHJlcyk7XG4gIH1cblxuICByZXR1cm4gcmVzLnN0YXR1cyA+PSAyMDAgJiYgcmVzLnN0YXR1cyA8IDMwMDtcbn07XG5cbi8qKlxuICogR2V0IHJlcXVlc3QgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICByZXR1cm4gdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBkZXByZWNhdGVkIGludGVybmFsIEFQSS4gVXNlIGAuZ2V0KGZpZWxkKWAgaW5zdGVhZC5cbiAqXG4gKiAoZ2V0SGVhZGVyIGlzIG5vIGxvbmdlciB1c2VkIGludGVybmFsbHkgYnkgdGhlIHN1cGVyYWdlbnQgY29kZSBiYXNlKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXRIZWFkZXIgPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgYGZpZWxkYCB0byBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLnNldCgnWC1BUEktS2V5JywgJ2Zvb2JhcicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KHsgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsICdYLUFQSS1LZXknOiAnZm9vYmFyJyB9KVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oZmllbGQsIHZhbCl7XG4gIGlmIChpc09iamVjdChmaWVsZCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZmllbGQpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgZmllbGRba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcbiAgdGhpcy5oZWFkZXJbZmllbGRdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnVuc2V0KCdVc2VyLUFnZW50JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICBkZWxldGUgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xuICBkZWxldGUgdGhpcy5oZWFkZXJbZmllbGRdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGUgdGhlIGZpZWxkIGBuYW1lYCBhbmQgYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3RcbiAqIGZvciBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiByZXF1ZXN0IGJvZGllcy5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCgnZm9vJywgJ2JhcicpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCh7IGZvbzogJ2JhcicsIGJhejogJ3F1eCcgfSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfEJsb2J8RmlsZXxCdWZmZXJ8ZnMuUmVhZFN0cmVhbX0gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5maWVsZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAvLyBuYW1lIHNob3VsZCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0LlxuICBpZiAobnVsbCA9PT0gbmFtZSB8fCB1bmRlZmluZWQgPT09IG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIG5hbWUgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiLmZpZWxkKCkgY2FuJ3QgYmUgdXNlZCBpZiAuc2VuZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIik7XG4gIH1cblxuICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgdGhpcy5maWVsZChrZXksIG5hbWVba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGZvciAodmFyIGkgaW4gdmFsKSB7XG4gICAgICB0aGlzLmZpZWxkKG5hbWUsIHZhbFtpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdmFsIHNob3VsZCBiZSBkZWZpbmVkIG5vd1xuICBpZiAobnVsbCA9PT0gdmFsIHx8IHVuZGVmaW5lZCA9PT0gdmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuZmllbGQobmFtZSwgdmFsKSB2YWwgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG4gIGlmICgnYm9vbGVhbicgPT09IHR5cGVvZiB2YWwpIHtcbiAgICB2YWwgPSAnJyArIHZhbDtcbiAgfVxuICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChuYW1lLCB2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWJvcnQgdGhlIHJlcXVlc3QsIGFuZCBjbGVhciBwb3RlbnRpYWwgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTtcbiAgdGhpcy54aHIgJiYgdGhpcy54aHIuYWJvcnQoKTsgLy8gYnJvd3NlclxuICB0aGlzLnJlcSAmJiB0aGlzLnJlcS5hYm9ydCgpOyAvLyBub2RlXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gIHRoaXMuZW1pdCgnYWJvcnQnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2F1dGggPSBmdW5jdGlvbih1c2VyLCBwYXNzLCBvcHRpb25zLCBiYXNlNjRFbmNvZGVyKSB7XG4gIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIGJhc2U2NEVuY29kZXIodXNlciArICc6JyArIHBhc3MpKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcjtcbiAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiZWFyZXInOiAvLyB1c2FnZSB3b3VsZCBiZSAuYXV0aChhY2Nlc3NUb2tlbiwgeyB0eXBlOiAnYmVhcmVyJyB9KVxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyB1c2VyKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbmFibGUgdHJhbnNtaXNzaW9uIG9mIGNvb2tpZXMgd2l0aCB4LWRvbWFpbiByZXF1ZXN0cy5cbiAqXG4gKiBOb3RlIHRoYXQgZm9yIHRoaXMgdG8gd29yayB0aGUgb3JpZ2luIG11c3Qgbm90IGJlXG4gKiB1c2luZyBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiIHdpdGggYSB3aWxkY2FyZCxcbiAqIGFuZCBhbHNvIG11c3Qgc2V0IFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHNcIlxuICogdG8gXCJ0cnVlXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUud2l0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24ob24pIHtcbiAgLy8gVGhpcyBpcyBicm93c2VyLW9ubHkgZnVuY3Rpb25hbGl0eS4gTm9kZSBzaWRlIGlzIG5vLW9wLlxuICBpZiAob24gPT0gdW5kZWZpbmVkKSBvbiA9IHRydWU7XG4gIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IG9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggcmVkaXJlY3RzIHRvIGBuYC4gRG9lcyBub3RpbmcgaW4gYnJvd3NlciBYSFIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmVkaXJlY3RzID0gZnVuY3Rpb24obil7XG4gIHRoaXMuX21heFJlZGlyZWN0cyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNYXhpbXVtIHNpemUgb2YgYnVmZmVyZWQgcmVzcG9uc2UgYm9keSwgaW4gYnl0ZXMuIENvdW50cyB1bmNvbXByZXNzZWQgc2l6ZS5cbiAqIERlZmF1bHQgMjAwTUIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUubWF4UmVzcG9uc2VTaXplID0gZnVuY3Rpb24obil7XG4gIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIG4pIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICB9XG4gIHRoaXMuX21heFJlc3BvbnNlU2l6ZSA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgKG5vdCBKU09OIHN0cmluZykgb2Ygc2NhbGFyIHByb3BlcnRpZXMuXG4gKiBOb3RlIGFzIHRoaXMgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIHJldHVybiBhIHVzZWZ1bCBub24tdGhpcyB2YWx1ZSxcbiAqIGl0IGNhbm5vdCBiZSBjaGFpbmVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVzY3JpYmluZyBtZXRob2QsIHVybCwgYW5kIGRhdGEgb2YgdGhpcyByZXF1ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgIHVybDogdGhpcy51cmwsXG4gICAgZGF0YTogdGhpcy5fZGF0YSxcbiAgICBoZWFkZXJzOiB0aGlzLl9oZWFkZXIsXG4gIH07XG59O1xuXG4vKipcbiAqIFNlbmQgYGRhdGFgIGFzIHRoZSByZXF1ZXN0IGJvZHksIGRlZmF1bHRpbmcgdGhlIGAudHlwZSgpYCB0byBcImpzb25cIiB3aGVuXG4gKiBhbiBvYmplY3QgaXMgZ2l2ZW4uXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gbWFudWFsIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnanNvbicpXG4gKiAgICAgICAgIC5zZW5kKCd7XCJuYW1lXCI6XCJ0alwifScpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gbWFudWFsIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoJ25hbWU9dGonKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0cyB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoJ25hbWU9dG9iaScpXG4gKiAgICAgICAgLnNlbmQoJ3NwZWNpZXM9ZmVycmV0JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZGF0YVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBpc09iaiA9IGlzT2JqZWN0KGRhdGEpO1xuICB2YXIgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG5cbiAgaWYgKHRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgY29uc29sZS5lcnJvcihcIi5zZW5kKCkgY2FuJ3QgYmUgdXNlZCBpZiAuYXR0YWNoKCkgb3IgLmZpZWxkKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKTtcbiAgfVxuXG4gIGlmIChpc09iaiAmJiAhdGhpcy5fZGF0YSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgfSBlbHNlIGlmICghdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGEgJiYgdGhpcy5fZGF0YSAmJiB0aGlzLl9pc0hvc3QodGhpcy5fZGF0YSkpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbid0IG1lcmdlIHRoZXNlIHNlbmQgY2FsbHNcIik7XG4gIH1cblxuICAvLyBtZXJnZVxuICBpZiAoaXNPYmogJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgIH1cbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSkge1xuICAgIC8vIGRlZmF1bHQgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gICAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2Zvcm0nKTtcbiAgICB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBpZiAoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgPT0gdHlwZSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGFcbiAgICAgICAgPyB0aGlzLl9kYXRhICsgJyYnICsgZGF0YVxuICAgICAgICA6IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGEgPSAodGhpcy5fZGF0YSB8fCAnJykgKyBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGlmICghaXNPYmogfHwgdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkZWZhdWx0IHRvIGpzb25cbiAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2pzb24nKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNvcnQgYHF1ZXJ5c3RyaW5nYCBieSB0aGUgc29ydCBmdW5jdGlvblxuICpcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0IG9yZGVyXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeSgpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gY3VzdG9taXplZCBzb3J0IGZ1bmN0aW9uXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeShmdW5jdGlvbihhLCBiKXtcbiAqICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zb3J0UXVlcnkgPSBmdW5jdGlvbihzb3J0KSB7XG4gIC8vIF9zb3J0IGRlZmF1bHQgdG8gdHJ1ZSBidXQgb3RoZXJ3aXNlIGNhbiBiZSBhIGZ1bmN0aW9uIG9yIGJvb2xlYW5cbiAgdGhpcy5fc29ydCA9IHR5cGVvZiBzb3J0ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBzb3J0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tcG9zZSBxdWVyeXN0cmluZyB0byBhcHBlbmQgdG8gcmVxLnVybFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2ZpbmFsaXplUXVlcnlTdHJpbmcgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLl9xdWVyeS5qb2luKCcmJyk7XG4gIGlmIChxdWVyeSkge1xuICAgIHRoaXMudXJsICs9ICh0aGlzLnVybC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JykgKyBxdWVyeTtcbiAgfVxuICB0aGlzLl9xdWVyeS5sZW5ndGggPSAwOyAvLyBNYWtlcyB0aGUgY2FsbCBpZGVtcG90ZW50XG5cbiAgaWYgKHRoaXMuX3NvcnQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBxdWVyeUFyciA9IHRoaXMudXJsLnN1YnN0cmluZyhpbmRleCArIDEpLnNwbGl0KCcmJyk7XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHRoaXMuX3NvcnQpIHtcbiAgICAgICAgcXVlcnlBcnIuc29ydCh0aGlzLl9zb3J0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5QXJyLnNvcnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gdGhpcy51cmwuc3Vic3RyaW5nKDAsIGluZGV4KSArICc/JyArIHF1ZXJ5QXJyLmpvaW4oJyYnKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEZvciBiYWNrd2FyZHMgY29tcGF0IG9ubHlcblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fYXBwZW5kUXVlcnlTdHJpbmcgPSBmdW5jdGlvbigpIHtjb25zb2xlLnRyYWNlKFwiVW5zdXBwb3J0ZWRcIik7fVxuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHRpbWVvdXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl90aW1lb3V0RXJyb3IgPSBmdW5jdGlvbihyZWFzb24sIHRpbWVvdXQsIGVycm5vKXtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGVyciA9IG5ldyBFcnJvcihyZWFzb24gKyB0aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyk7XG4gIGVyci50aW1lb3V0ID0gdGltZW91dDtcbiAgZXJyLmNvZGUgPSAnRUNPTk5BQk9SVEVEJztcbiAgZXJyLmVycm5vID0gZXJybm87XG4gIHRoaXMudGltZWRvdXQgPSB0cnVlO1xuICB0aGlzLmFib3J0KCk7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fc2V0VGltZW91dHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIGRlYWRsaW5lXG4gIGlmICh0aGlzLl90aW1lb3V0ICYmICF0aGlzLl90aW1lcikge1xuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdUaW1lb3V0IG9mICcsIHNlbGYuX3RpbWVvdXQsICdFVElNRScpO1xuICAgIH0sIHRoaXMuX3RpbWVvdXQpO1xuICB9XG4gIC8vIHJlc3BvbnNlIHRpbWVvdXRcbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVGltZW91dCAmJiAhdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpIHtcbiAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcignUmVzcG9uc2UgdGltZW91dCBvZiAnLCBzZWxmLl9yZXNwb25zZVRpbWVvdXQsICdFVElNRURPVVQnKTtcbiAgICB9LCB0aGlzLl9yZXNwb25zZVRpbWVvdXQpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2lkdG9rZW4tdmVyaWZpZXIvfi9zdXBlcmFnZW50L2xpYi9yZXF1ZXN0LWJhc2UuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG51bGwgIT09IG9iaiAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9pZHRva2VuLXZlcmlmaWVyL34vc3VwZXJhZ2VudC9saWIvaXMtb2JqZWN0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VCYXNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3BvbnNlQmFzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZUJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2VCYXNlKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cblxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBSZXNwb25zZUJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXNwb25zZUJhc2UucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBgZmllbGRgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiB0aGlzLmhlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogU2V0IGhlYWRlciByZWxhdGVkIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGAudHlwZWAgdGhlIGNvbnRlbnQgdHlwZSB3aXRob3V0IHBhcmFtc1xuICpcbiAqIEEgcmVzcG9uc2Ugb2YgXCJDb250ZW50LVR5cGU6IHRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICogd2lsbCBwcm92aWRlIHlvdSB3aXRoIGEgYC50eXBlYCBvZiBcInRleHQvcGxhaW5cIi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRIZWFkZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24oaGVhZGVyKXtcbiAgICAvLyBUT0RPOiBtb2FyIVxuICAgIC8vIFRPRE86IG1ha2UgdGhpcyBhIHV0aWxcblxuICAgIC8vIGNvbnRlbnQtdHlwZVxuICAgIHZhciBjdCA9IGhlYWRlclsnY29udGVudC10eXBlJ10gfHwgJyc7XG4gICAgdGhpcy50eXBlID0gdXRpbHMudHlwZShjdCk7XG5cbiAgICAvLyBwYXJhbXNcbiAgICB2YXIgcGFyYW1zID0gdXRpbHMucGFyYW1zKGN0KTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB0aGlzW2tleV0gPSBwYXJhbXNba2V5XTtcblxuICAgIHRoaXMubGlua3MgPSB7fTtcblxuICAgIC8vIGxpbmtzXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGhlYWRlci5saW5rKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtzID0gdXRpbHMucGFyc2VMaW5rcyhoZWFkZXIubGluayk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgZmxhZ3Mgc3VjaCBhcyBgLm9rYCBiYXNlZCBvbiBgc3RhdHVzYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBhIDJ4eCByZXNwb25zZSB3aWxsIGdpdmUgeW91IGEgYC5va2Agb2YgX190cnVlX19cbiAqIHdoZXJlYXMgNXh4IHdpbGwgYmUgX19mYWxzZV9fIGFuZCBgLmVycm9yYCB3aWxsIGJlIF9fdHJ1ZV9fLiBUaGVcbiAqIGAuY2xpZW50RXJyb3JgIGFuZCBgLnNlcnZlckVycm9yYCBhcmUgYWxzbyBhdmFpbGFibGUgdG8gYmUgbW9yZVxuICogc3BlY2lmaWMsIGFuZCBgLnN0YXR1c1R5cGVgIGlzIHRoZSBjbGFzcyBvZiBlcnJvciByYW5naW5nIGZyb20gMS4uNVxuICogc29tZXRpbWVzIHVzZWZ1bCBmb3IgbWFwcGluZyByZXNwb25kIGNvbG9ycyBldGMuXG4gKlxuICogXCJzdWdhclwiIHByb3BlcnRpZXMgYXJlIGFsc28gZGVmaW5lZCBmb3IgY29tbW9uIGNhc2VzLiBDdXJyZW50bHkgcHJvdmlkaW5nOlxuICpcbiAqICAgLSAubm9Db250ZW50XG4gKiAgIC0gLmJhZFJlcXVlc3RcbiAqICAgLSAudW5hdXRob3JpemVkXG4gKiAgIC0gLm5vdEFjY2VwdGFibGVcbiAqICAgLSAubm90Rm91bmRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRTdGF0dXNQcm9wZXJ0aWVzID0gZnVuY3Rpb24oc3RhdHVzKXtcbiAgICB2YXIgdHlwZSA9IHN0YXR1cyAvIDEwMCB8IDA7XG5cbiAgICAvLyBzdGF0dXMgLyBjbGFzc1xuICAgIHRoaXMuc3RhdHVzID0gdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVHlwZSA9IHR5cGU7XG5cbiAgICAvLyBiYXNpY3NcbiAgICB0aGlzLmluZm8gPSAxID09IHR5cGU7XG4gICAgdGhpcy5vayA9IDIgPT0gdHlwZTtcbiAgICB0aGlzLnJlZGlyZWN0ID0gMyA9PSB0eXBlO1xuICAgIHRoaXMuY2xpZW50RXJyb3IgPSA0ID09IHR5cGU7XG4gICAgdGhpcy5zZXJ2ZXJFcnJvciA9IDUgPT0gdHlwZTtcbiAgICB0aGlzLmVycm9yID0gKDQgPT0gdHlwZSB8fCA1ID09IHR5cGUpXG4gICAgICAgID8gdGhpcy50b0Vycm9yKClcbiAgICAgICAgOiBmYWxzZTtcblxuICAgIC8vIHN1Z2FyXG4gICAgdGhpcy5hY2NlcHRlZCA9IDIwMiA9PSBzdGF0dXM7XG4gICAgdGhpcy5ub0NvbnRlbnQgPSAyMDQgPT0gc3RhdHVzO1xuICAgIHRoaXMuYmFkUmVxdWVzdCA9IDQwMCA9PSBzdGF0dXM7XG4gICAgdGhpcy51bmF1dGhvcml6ZWQgPSA0MDEgPT0gc3RhdHVzO1xuICAgIHRoaXMubm90QWNjZXB0YWJsZSA9IDQwNiA9PSBzdGF0dXM7XG4gICAgdGhpcy5mb3JiaWRkZW4gPSA0MDMgPT0gc3RhdHVzO1xuICAgIHRoaXMubm90Rm91bmQgPSA0MDQgPT0gc3RhdHVzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9pZHRva2VuLXZlcmlmaWVyL34vc3VwZXJhZ2VudC9saWIvcmVzcG9uc2UtYmFzZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykuc2hpZnQoKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhlYWRlciBmaWVsZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucGFyYW1zID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICo7ICovKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBzdHIpe1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo9ICovKTtcbiAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKTtcbiAgICB2YXIgdmFsID0gcGFydHMuc2hpZnQoKTtcblxuICAgIGlmIChrZXkgJiYgdmFsKSBvYmpba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIExpbmsgaGVhZGVyIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhcnNlTGlua3MgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKiwgKi8pLnJlZHVjZShmdW5jdGlvbihvYmosIHN0cil7XG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KC8gKjsgKi8pO1xuICAgIHZhciB1cmwgPSBwYXJ0c1swXS5zbGljZSgxLCAtMSk7XG4gICAgdmFyIHJlbCA9IHBhcnRzWzFdLnNwbGl0KC8gKj0gKi8pWzFdLnNsaWNlKDEsIC0xKTtcbiAgICBvYmpbcmVsXSA9IHVybDtcbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG59O1xuXG4vKipcbiAqIFN0cmlwIGNvbnRlbnQgcmVsYXRlZCBmaWVsZHMgZnJvbSBgaGVhZGVyYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAcmV0dXJuIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5jbGVhbkhlYWRlciA9IGZ1bmN0aW9uKGhlYWRlciwgY2hhbmdlc09yaWdpbil7XG4gIGRlbGV0ZSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICBkZWxldGUgaGVhZGVyWydjb250ZW50LWxlbmd0aCddO1xuICBkZWxldGUgaGVhZGVyWyd0cmFuc2Zlci1lbmNvZGluZyddO1xuICBkZWxldGUgaGVhZGVyWydob3N0J107XG4gIC8vIHNlY3VpcnR5XG4gIGlmIChjaGFuZ2VzT3JpZ2luKSB7XG4gICAgZGVsZXRlIGhlYWRlclsnYXV0aG9yaXphdGlvbiddO1xuICAgIGRlbGV0ZSBoZWFkZXJbJ2Nvb2tpZSddO1xuICB9XG4gIHJldHVybiBoZWFkZXI7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2lkdG9rZW4tdmVyaWZpZXIvfi9zdXBlcmFnZW50L2xpYi91dGlscy5qcyIsImZ1bmN0aW9uIEFnZW50KCkge1xuICB0aGlzLl9kZWZhdWx0cyA9IFtdO1xufVxuXG5bXCJ1c2VcIiwgXCJvblwiLCBcIm9uY2VcIiwgXCJzZXRcIiwgXCJxdWVyeVwiLCBcInR5cGVcIiwgXCJhY2NlcHRcIiwgXCJhdXRoXCIsIFwid2l0aENyZWRlbnRpYWxzXCIsIFwic29ydFF1ZXJ5XCIsIFwicmV0cnlcIiwgXCJva1wiLCBcInJlZGlyZWN0c1wiLFxuIFwidGltZW91dFwiLCBcImJ1ZmZlclwiLCBcInNlcmlhbGl6ZVwiLCBcInBhcnNlXCIsIFwiY2FcIiwgXCJrZXlcIiwgXCJwZnhcIiwgXCJjZXJ0XCJdLmZvckVhY2goZnVuY3Rpb24oZm4pIHtcbiAgLyoqIERlZmF1bHQgc2V0dGluZyBmb3IgYWxsIHJlcXVlc3RzIGZyb20gdGhpcyBhZ2VudCAqL1xuICBBZ2VudC5wcm90b3R5cGVbZm5dID0gZnVuY3Rpb24oLyp2YXJhcmdzKi8pIHtcbiAgICB0aGlzLl9kZWZhdWx0cy5wdXNoKHtmbjpmbiwgYXJndW1lbnRzOmFyZ3VtZW50c30pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuQWdlbnQucHJvdG90eXBlLl9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uKHJlcSkge1xuICAgIHRoaXMuX2RlZmF1bHRzLmZvckVhY2goZnVuY3Rpb24oZGVmKSB7XG4gICAgICByZXFbZGVmLmZuXS5hcHBseShyZXEsIGRlZi5hcmd1bWVudHMpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2VudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9pZHRva2VuLXZlcmlmaWVyL34vc3VwZXJhZ2VudC9saWIvYWdlbnQtYmFzZS5qcyIsImZ1bmN0aW9uIENvbmZpZ3VyYXRpb25FcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9ICdDb25maWd1cmF0aW9uRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSAobWVzc2FnZSB8fCAnJyk7XG59XG5Db25maWd1cmF0aW9uRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBUb2tlblZhbGlkYXRpb25FcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9ICdUb2tlblZhbGlkYXRpb25FcnJvcic7XG4gIHRoaXMubWVzc2FnZSA9IChtZXNzYWdlIHx8ICcnKTtcbn1cblRva2VuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENvbmZpZ3VyYXRpb25FcnJvcjogQ29uZmlndXJhdGlvbkVycm9yLFxuICBUb2tlblZhbGlkYXRpb25FcnJvcjogVG9rZW5WYWxpZGF0aW9uRXJyb3Jcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vaWR0b2tlbi12ZXJpZmllci9zcmMvaGVscGVycy9lcnJvci5qcyIsImZ1bmN0aW9uIER1bW15Q2FjaGUoKSB7fVxuXG5EdW1teUNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBudWxsO1xufTtcblxuRHVtbXlDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5EdW1teUNhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoKSB7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1bW15Q2FjaGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vaWR0b2tlbi12ZXJpZmllci9zcmMvaGVscGVycy9kdW1teS1jYWNoZS5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBMb2cgZnJvbSAnLi9Mb2cnO1xuaW1wb3J0IFVybFV0aWxpdHkgZnJvbSAnLi9VcmxVdGlsaXR5JztcbmltcG9ydCBTaWduaW5TdGF0ZSBmcm9tICcuL1NpZ25pblN0YXRlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lnbmluUmVxdWVzdCB7XG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICAvLyBtYW5kYXRvcnlcbiAgICAgICAgdXJsLCBjbGllbnRfaWQsIHJlZGlyZWN0X3VyaSwgcmVzcG9uc2VfdHlwZSwgc2NvcGUsIGF1dGhvcml0eSxcbiAgICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICAgZGF0YSwgcHJvbXB0LCBkaXNwbGF5LCBtYXhfYWdlLCB1aV9sb2NhbGVzLCBpZF90b2tlbl9oaW50LCBsb2dpbl9oaW50LCBhY3JfdmFsdWVzLCByZXNvdXJjZSxcbiAgICAgICAgcmVxdWVzdCwgcmVxdWVzdF91cmksIGV4dHJhUXVlcnlQYXJhbXMsXG4gICAgfSkge1xuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiTm8gdXJsIHBhc3NlZCB0byBTaWduaW5SZXF1ZXN0XCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXJsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2xpZW50X2lkKSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoXCJObyBjbGllbnRfaWQgcGFzc2VkIHRvIFNpZ25pblJlcXVlc3RcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjbGllbnRfaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWRpcmVjdF91cmkpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIk5vIHJlZGlyZWN0X3VyaSBwYXNzZWQgdG8gU2lnbmluUmVxdWVzdFwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlZGlyZWN0X3VyaVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlX3R5cGUpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIk5vIHJlc3BvbnNlX3R5cGUgcGFzc2VkIHRvIFNpZ25pblJlcXVlc3RcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXNwb25zZV90eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2NvcGUpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIk5vIHNjb3BlIHBhc3NlZCB0byBTaWduaW5SZXF1ZXN0XCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NvcGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhdXRob3JpdHkpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIk5vIGF1dGhvcml0eSBwYXNzZWQgdG8gU2lnbmluUmVxdWVzdFwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF1dGhvcml0eVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvaWRjID0gU2lnbmluUmVxdWVzdC5pc09pZGMocmVzcG9uc2VfdHlwZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgU2lnbmluU3RhdGUoeyBub25jZTogb2lkYywgZGF0YSwgY2xpZW50X2lkLCBhdXRob3JpdHkgfSk7XG5cbiAgICAgICAgdXJsID0gVXJsVXRpbGl0eS5hZGRRdWVyeVBhcmFtKHVybCwgXCJjbGllbnRfaWRcIiwgY2xpZW50X2lkKTtcbiAgICAgICAgdXJsID0gVXJsVXRpbGl0eS5hZGRRdWVyeVBhcmFtKHVybCwgXCJyZWRpcmVjdF91cmlcIiwgcmVkaXJlY3RfdXJpKTtcbiAgICAgICAgdXJsID0gVXJsVXRpbGl0eS5hZGRRdWVyeVBhcmFtKHVybCwgXCJyZXNwb25zZV90eXBlXCIsIHJlc3BvbnNlX3R5cGUpO1xuICAgICAgICB1cmwgPSBVcmxVdGlsaXR5LmFkZFF1ZXJ5UGFyYW0odXJsLCBcInNjb3BlXCIsIHNjb3BlKTtcbiAgICAgICAgXG4gICAgICAgIHVybCA9IFVybFV0aWxpdHkuYWRkUXVlcnlQYXJhbSh1cmwsIFwic3RhdGVcIiwgdGhpcy5zdGF0ZS5pZCk7XG4gICAgICAgIGlmIChvaWRjKSB7XG4gICAgICAgICAgICB1cmwgPSBVcmxVdGlsaXR5LmFkZFF1ZXJ5UGFyYW0odXJsLCBcIm5vbmNlXCIsIHRoaXMuc3RhdGUubm9uY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbmFsID0geyBwcm9tcHQsIGRpc3BsYXksIG1heF9hZ2UsIHVpX2xvY2FsZXMsIGlkX3Rva2VuX2hpbnQsIGxvZ2luX2hpbnQsIGFjcl92YWx1ZXMsIHJlc291cmNlLCByZXF1ZXN0LCByZXF1ZXN0X3VyaSB9O1xuICAgICAgICBmb3IobGV0IGtleSBpbiBvcHRpb25hbCl7XG4gICAgICAgICAgICBpZiAob3B0aW9uYWxba2V5XSkge1xuICAgICAgICAgICAgICAgIHVybCA9IFVybFV0aWxpdHkuYWRkUXVlcnlQYXJhbSh1cmwsIGtleSwgb3B0aW9uYWxba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IobGV0IGtleSBpbiBleHRyYVF1ZXJ5UGFyYW1zKXtcbiAgICAgICAgICAgIHVybCA9IFVybFV0aWxpdHkuYWRkUXVlcnlQYXJhbSh1cmwsIGtleSwgZXh0cmFRdWVyeVBhcmFtc1trZXldKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzT2lkYyhyZXNwb25zZV90eXBlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZXNwb25zZV90eXBlLnNwbGl0KC9cXHMrL2cpLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbSA9PT0gXCJpZF90b2tlblwiO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICEhKHJlc3VsdFswXSk7XG4gICAgfVxuICAgIFxuICAgIHN0YXRpYyBpc09BdXRoKHJlc3BvbnNlX3R5cGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3BvbnNlX3R5cGUuc3BsaXQoL1xccysvZykuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtID09PSBcInRva2VuXCI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gISEocmVzdWx0WzBdKTtcbiAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1NpZ25pblJlcXVlc3QuanMiLCIvLyBDb3B5cmlnaHQgKGMpIEJyb2NrIEFsbGVuICYgRG9taW5pY2sgQmFpZXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTElDRU5TRSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG5pbXBvcnQgTG9nIGZyb20gJy4vTG9nJztcbmltcG9ydCBHbG9iYWwgZnJvbSAnLi9HbG9iYWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVcmxVdGlsaXR5IHtcbiAgICBzdGF0aWMgYWRkUXVlcnlQYXJhbSh1cmwsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh1cmwuaW5kZXhPZignPycpIDwgMCkge1xuICAgICAgICAgICAgdXJsICs9IFwiP1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVybFt1cmwubGVuZ3RoIC0gMV0gIT09IFwiP1wiKSB7XG4gICAgICAgICAgICB1cmwgKz0gXCImXCI7XG4gICAgICAgIH1cblxuICAgICAgICB1cmwgKz0gZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpO1xuICAgICAgICB1cmwgKz0gXCI9XCI7XG4gICAgICAgIHVybCArPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlVXJsRnJhZ21lbnQodmFsdWUsIGRlbGltaXRlciA9IFwiI1wiLCBnbG9iYWwgPSBHbG9iYWwpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiVXJsVXRpbGl0eS5wYXJzZVVybEZyYWdtZW50XCIpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKXtcbiAgICAgICAgICAgIHZhbHVlID0gZ2xvYmFsLmxvY2F0aW9uLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWR4ID0gdmFsdWUubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cihpZHggKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJhbXMgPSB7fSxcbiAgICAgICAgICAgIHJlZ2V4ID0gLyhbXiY9XSspPShbXiZdKikvZyxcbiAgICAgICAgICAgIG07XG5cbiAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgICB3aGlsZSAobSA9IHJlZ2V4LmV4ZWModmFsdWUpKSB7XG4gICAgICAgICAgICBwYXJhbXNbZGVjb2RlVVJJQ29tcG9uZW50KG1bMV0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChtWzJdKTtcbiAgICAgICAgICAgIGlmIChjb3VudGVyKysgPiA1MCkge1xuICAgICAgICAgICAgICAgIExvZy5lcnJvcihcInJlc3BvbnNlIGV4Y2VlZGVkIGV4cGVjdGVkIG51bWJlciBvZiBwYXJhbWV0ZXJzXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogXCJSZXNwb25zZSBleGNlZWRlZCBleHBlY3RlZCBudW1iZXIgb2YgcGFyYW1ldGVyc1wiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9VcmxVdGlsaXR5LmpzIiwiLy8gQ29weXJpZ2h0IChjKSBCcm9jayBBbGxlbiAmIERvbWluaWNrIEJhaWVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuaW1wb3J0IExvZyBmcm9tICcuL0xvZyc7XG5pbXBvcnQgU3RhdGUgZnJvbSAnLi9TdGF0ZSc7XG5pbXBvcnQgcmFuZG9tIGZyb20gJy4vcmFuZG9tJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lnbmluU3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3Ioe25vbmNlLCBhdXRob3JpdHksIGNsaWVudF9pZH0gPSB7fSkge1xuICAgICAgICBzdXBlcihhcmd1bWVudHNbMF0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKG5vbmNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9ub25jZSA9IHJhbmRvbSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9ub25jZSA9IG5vbmNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9hdXRob3JpdHkgPSBhdXRob3JpdHk7XG4gICAgICAgIHRoaXMuX2NsaWVudF9pZCA9IGNsaWVudF9pZDtcbiAgICB9XG5cbiAgICBnZXQgbm9uY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub25jZTtcbiAgICB9XG4gICAgZ2V0IGF1dGhvcml0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGhvcml0eTtcbiAgICB9XG4gICAgZ2V0IGNsaWVudF9pZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudF9pZDtcbiAgICB9XG4gICAgXG4gICAgdG9TdG9yYWdlU3RyaW5nKCkge1xuICAgICAgICBMb2cuZGVidWcoXCJTaWduaW5TdGF0ZS50b1N0b3JhZ2VTdHJpbmdcIik7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGNyZWF0ZWQ6IHRoaXMuY3JlYXRlZCxcbiAgICAgICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlLFxuICAgICAgICAgICAgYXV0aG9yaXR5OiB0aGlzLmF1dGhvcml0eSxcbiAgICAgICAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21TdG9yYWdlU3RyaW5nKHN0b3JhZ2VTdHJpbmcpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiU2lnbmluU3RhdGUuZnJvbVN0b3JhZ2VTdHJpbmdcIik7XG4gICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShzdG9yYWdlU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduaW5TdGF0ZShkYXRhKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU2lnbmluU3RhdGUuanMiLCIvLyBDb3B5cmlnaHQgKGMpIEJyb2NrIEFsbGVuICYgRG9taW5pY2sgQmFpZXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTElDRU5TRSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG5pbXBvcnQgTG9nIGZyb20gJy4vTG9nJztcbmltcG9ydCByYW5kb20gZnJvbSAnLi9yYW5kb20nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3Ioe2lkLCBkYXRhLCBjcmVhdGVkfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2lkID0gaWQgfHwgcmFuZG9tKCk7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY3JlYXRlZCA9PT0gJ251bWJlcicgJiYgY3JlYXRlZCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZWQgPSBjcmVhdGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlZCA9IHBhcnNlSW50KERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuICAgIGdldCBjcmVhdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlZDtcbiAgICB9XG5cbiAgICB0b1N0b3JhZ2VTdHJpbmcoKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIlN0YXRlLnRvU3RvcmFnZVN0cmluZ1wiKTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgY3JlYXRlZDogdGhpcy5jcmVhdGVkXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBzdGF0aWMgZnJvbVN0b3JhZ2VTdHJpbmcoc3RvcmFnZVN0cmluZykge1xuICAgICAgICBMb2cuZGVidWcoXCJTdGF0ZS5mcm9tU3RvcmFnZVN0cmluZ1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZShKU09OLnBhcnNlKHN0b3JhZ2VTdHJpbmcpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xlYXJTdGFsZVN0YXRlKHN0b3JhZ2UsIGFnZSkge1xuICAgICAgICBMb2cuZGVidWcoXCJTdGF0ZS5jbGVhclN0YWxlU3RhdGVcIik7XG5cbiAgICAgICAgdmFyIGN1dG9mZiA9IERhdGUubm93KCkgLyAxMDAwIC0gYWdlO1xuXG4gICAgICAgIHJldHVybiBzdG9yYWdlLmdldEFsbEtleXMoKS50aGVuKGtleXMgPT4ge1xuICAgICAgICAgICAgTG9nLmRlYnVnKFwiZ290IGtleXNcIiwga2V5cyk7XG5cbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBzdG9yYWdlLmdldChrZXkpLnRoZW4oaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZW1vdmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBTdGF0ZS5mcm9tU3RvcmFnZVN0cmluZyhpdGVtKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmRlYnVnKFwiZ290IGl0ZW0gZnJvbSBrZXk6IFwiLCBrZXksIHN0YXRlLmNyZWF0ZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmNyZWF0ZWQgPD0gY3V0b2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2cuZXJyb3IoXCJFcnJvciBwYXJzaW5nIHN0YXRlIGZvciBrZXlcIiwga2V5LCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJubyBpdGVtIGluIHN0b3JhZ2UgZm9yIGtleTogXCIsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmRlYnVnKFwicmVtb3ZlZCBpdGVtIGZvciBrZXk6IFwiLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2UucmVtb3ZlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIExvZy5kZWJ1ZyhcIndhaXRpbmcgb24gcHJvbWlzZSBjb3VudDpcIiwgcHJvbWlzZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TdGF0ZS5qcyIsIi8vIE5PVElDRTogdGhlIGNvZGUgaW4gdGhpcyBmaWxlIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGJ5IE1pY3Jvc29mdFxuLy8gb3JpZ2luYWwgc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vQXp1cmVBRC9henVyZS1hY3RpdmVkaXJlY3RvcnktbGlicmFyeS1mb3ItanMvYmxvYi9tYXN0ZXIvbGliL2FkYWwuanMjTDEwMjlcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQWRhbEpTIHYxLjAuOFxuLy8gQHByZXNlcnZlIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IE9wZW4gVGVjaG5vbG9naWVzLCBJbmMuXG4vLyBBbGwgUmlnaHRzIFJlc2VydmVkXG4vLyBBcGFjaGUgTGljZW5zZSAyLjBcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByYW5kb20oKSB7XG4gICAgdmFyIGd1aWRIb2xkZXIgPSAneHh4eHh4eHh4eHh4NHh4eHl4eHh4eHh4eHh4eHh4eHgnO1xuICAgIHZhciBoZXggPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBndWlkUmVzcG9uc2UgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3VpZEhvbGRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZ3VpZEhvbGRlcltpXSAhPT0gJy0nICYmIGd1aWRIb2xkZXJbaV0gIT09ICc0Jykge1xuICAgICAgICAgICAgLy8gZWFjaCB4IGFuZCB5IG5lZWRzIHRvIGJlIHJhbmRvbVxuICAgICAgICAgICAgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3VpZEhvbGRlcltpXSA9PT0gJ3gnKSB7XG4gICAgICAgICAgICBndWlkUmVzcG9uc2UgKz0gaGV4W3JdO1xuICAgICAgICB9IGVsc2UgaWYgKGd1aWRIb2xkZXJbaV0gPT09ICd5Jykge1xuICAgICAgICAgICAgLy8gY2xvY2stc2VxLWFuZC1yZXNlcnZlZCBmaXJzdCBoZXggaXMgZmlsdGVyZWQgYW5kIHJlbWFpbmluZyBoZXggdmFsdWVzIGFyZSByYW5kb21cbiAgICAgICAgICAgIHIgJj0gMHgzOyAvLyBiaXQgYW5kIHdpdGggMDAxMSB0byBzZXQgcG9zIDIgdG8gemVybyA/MD8/XG4gICAgICAgICAgICByIHw9IDB4ODsgLy8gc2V0IHBvcyAzIHRvIDEgYXMgMT8/P1xuICAgICAgICAgICAgZ3VpZFJlc3BvbnNlICs9IGhleFtyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGd1aWRSZXNwb25zZSArPSBndWlkSG9sZGVyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBndWlkUmVzcG9uc2U7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JhbmRvbS5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBVcmxVdGlsaXR5IGZyb20gJy4vVXJsVXRpbGl0eSc7XG5cbmNvbnN0IE9pZGNTY29wZSA9IFwib3BlbmlkXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpZ25pblJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcblxuICAgICAgICB2YXIgdmFsdWVzID0gVXJsVXRpbGl0eS5wYXJzZVVybEZyYWdtZW50KHVybCwgXCIjXCIpO1xuXG4gICAgICAgIHRoaXMuZXJyb3IgPSB2YWx1ZXMuZXJyb3I7XG4gICAgICAgIHRoaXMuZXJyb3JfZGVzY3JpcHRpb24gPSB2YWx1ZXMuZXJyb3JfZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuZXJyb3JfdXJpID0gdmFsdWVzLmVycm9yX3VyaTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc3RhdGUgPSB2YWx1ZXMuc3RhdGU7XG4gICAgICAgIHRoaXMuaWRfdG9rZW4gPSB2YWx1ZXMuaWRfdG9rZW47XG4gICAgICAgIHRoaXMuc2Vzc2lvbl9zdGF0ZSA9IHZhbHVlcy5zZXNzaW9uX3N0YXRlO1xuICAgICAgICB0aGlzLmFjY2Vzc190b2tlbiA9IHZhbHVlcy5hY2Nlc3NfdG9rZW47XG4gICAgICAgIHRoaXMudG9rZW5fdHlwZSA9IHZhbHVlcy50b2tlbl90eXBlO1xuICAgICAgICB0aGlzLnNjb3BlID0gdmFsdWVzLnNjb3BlO1xuICAgICAgICB0aGlzLnByb2ZpbGUgPSB1bmRlZmluZWQ7IC8vIHdpbGwgYmUgc2V0IGZyb20gUmVzcG9uc2VWYWxpZGF0b3JcblxuICAgICAgICBsZXQgZXhwaXJlc19pbiA9IHBhcnNlSW50KHZhbHVlcy5leHBpcmVzX2luKTtcbiAgICAgICAgaWYgKHR5cGVvZiBleHBpcmVzX2luID09PSAnbnVtYmVyJyAmJiBleHBpcmVzX2luID4gMCkge1xuICAgICAgICAgICAgbGV0IG5vdyA9IHBhcnNlSW50KERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgICAgIHRoaXMuZXhwaXJlc19hdCA9IG5vdyArIGV4cGlyZXNfaW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZXhwaXJlc19pbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhwaXJlc19hdCkge1xuICAgICAgICAgICAgbGV0IG5vdyA9IHBhcnNlSW50KERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGlyZXNfYXQgLSBub3c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBnZXQgZXhwaXJlZCgpIHtcbiAgICAgICAgbGV0IGV4cGlyZXNfaW4gPSB0aGlzLmV4cGlyZXNfaW47XG4gICAgICAgIGlmIChleHBpcmVzX2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBpcmVzX2luIDw9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBnZXQgc2NvcGVzKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc2NvcGUgfHwgXCJcIikuc3BsaXQoXCIgXCIpO1xuICAgIH1cbiAgICBcbiAgICBnZXQgaXNPcGVuSWRDb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZXMuaW5kZXhPZihPaWRjU2NvcGUpID49IDAgfHwgISF0aGlzLmlkX3Rva2VuO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TaWduaW5SZXNwb25zZS5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBMb2cgZnJvbSAnLi9Mb2cnO1xuaW1wb3J0IFVybFV0aWxpdHkgZnJvbSAnLi9VcmxVdGlsaXR5JztcbmltcG9ydCBTdGF0ZSBmcm9tICcuL1N0YXRlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lnbm91dFJlcXVlc3Qge1xuICAgIGNvbnN0cnVjdG9yKHt1cmwsIGlkX3Rva2VuX2hpbnQsIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSwgZGF0YX0pIHtcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIk5vIHVybCBwYXNzZWQgdG8gU2lnbm91dFJlcXVlc3RcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1cmxcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWRfdG9rZW5faGludCkge1xuICAgICAgICAgICAgdXJsID0gVXJsVXRpbGl0eS5hZGRRdWVyeVBhcmFtKHVybCwgXCJpZF90b2tlbl9oaW50XCIsIGlkX3Rva2VuX2hpbnQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpKSB7XG4gICAgICAgICAgICB1cmwgPSBVcmxVdGlsaXR5LmFkZFF1ZXJ5UGFyYW0odXJsLCBcInBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaVwiLCBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgU3RhdGUoeyBkYXRhIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHVybCA9IFVybFV0aWxpdHkuYWRkUXVlcnlQYXJhbSh1cmwsIFwic3RhdGVcIiwgdGhpcy5zdGF0ZS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TaWdub3V0UmVxdWVzdC5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBVcmxVdGlsaXR5IGZyb20gJy4vVXJsVXRpbGl0eSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpZ25vdXRSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IodXJsKSB7XG5cbiAgICAgICAgdmFyIHZhbHVlcyA9IFVybFV0aWxpdHkucGFyc2VVcmxGcmFnbWVudCh1cmwsIFwiP1wiKTtcblxuICAgICAgICB0aGlzLmVycm9yID0gdmFsdWVzLmVycm9yO1xuICAgICAgICB0aGlzLmVycm9yX2Rlc2NyaXB0aW9uID0gdmFsdWVzLmVycm9yX2Rlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmVycm9yX3VyaSA9IHZhbHVlcy5lcnJvcl91cmk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHZhbHVlcy5zdGF0ZTtcbiAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1NpZ25vdXRSZXNwb25zZS5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBMb2cgZnJvbSAnLi9Mb2cnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbk1lbW9yeVdlYlN0b3JhZ2V7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuICAgIH1cbiAgICBcbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICBMb2cuZGVidWcoXCJJbk1lbW9yeVdlYlN0b3JhZ2UuZ2V0SXRlbVwiLCBrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtrZXldO1xuICAgIH1cbiAgICBcbiAgICBzZXRJdGVtKGtleSwgdmFsdWUpe1xuICAgICAgICBMb2cuZGVidWcoXCJJbk1lbW9yeVdlYlN0b3JhZ2Uuc2V0SXRlbVwiLCBrZXkpO1xuICAgICAgICB0aGlzLl9kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICB9ICAgXG4gICAgXG4gICAgcmVtb3ZlSXRlbShrZXkpe1xuICAgICAgICBMb2cuZGVidWcoXCJJbk1lbW9yeVdlYlN0b3JhZ2UucmVtb3ZlSXRlbVwiLCBrZXkpO1xuICAgICAgICBkZWxldGUgdGhpcy5fZGF0YVtrZXldO1xuICAgIH1cbiAgICBcbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fZGF0YSkubGVuZ3RoO1xuICAgIH1cbiAgICBcbiAgICBrZXkoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX2RhdGEpW2luZGV4XTtcbiAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0luTWVtb3J5V2ViU3RvcmFnZS5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBMb2cgZnJvbSAnLi9Mb2cnO1xuaW1wb3J0IE9pZGNDbGllbnQgZnJvbSAnLi9PaWRjQ2xpZW50JztcbmltcG9ydCBVc2VyTWFuYWdlclNldHRpbmdzIGZyb20gJy4vVXNlck1hbmFnZXJTZXR0aW5ncyc7XG5pbXBvcnQgVXNlciBmcm9tICcuL1VzZXInO1xuaW1wb3J0IFVzZXJNYW5hZ2VyRXZlbnRzIGZyb20gJy4vVXNlck1hbmFnZXJFdmVudHMnO1xuaW1wb3J0IFNpbGVudFJlbmV3U2VydmljZSBmcm9tICcuL1NpbGVudFJlbmV3U2VydmljZSc7XG5pbXBvcnQgU2Vzc2lvbk1vbml0b3IgZnJvbSAnLi9TZXNzaW9uTW9uaXRvcic7XG5pbXBvcnQgVG9rZW5SZXZvY2F0aW9uQ2xpZW50IGZyb20gJy4vVG9rZW5SZXZvY2F0aW9uQ2xpZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlck1hbmFnZXIgZXh0ZW5kcyBPaWRjQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LFxuICAgICAgICBTaWxlbnRSZW5ld1NlcnZpY2VDdG9yID0gU2lsZW50UmVuZXdTZXJ2aWNlLFxuICAgICAgICBTZXNzaW9uTW9uaXRvckN0b3IgPSBTZXNzaW9uTW9uaXRvcixcbiAgICAgICAgVG9rZW5SZXZvY2F0aW9uQ2xpZW50Q3RvciA9IFRva2VuUmV2b2NhdGlvbkNsaWVudFxuICAgICkge1xuXG4gICAgICAgIGlmICghKHNldHRpbmdzIGluc3RhbmNlb2YgVXNlck1hbmFnZXJTZXR0aW5ncykpIHtcbiAgICAgICAgICAgIHNldHRpbmdzID0gbmV3IFVzZXJNYW5hZ2VyU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcblxuICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgVXNlck1hbmFnZXJFdmVudHMoc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLl9zaWxlbnRSZW5ld1NlcnZpY2UgPSBuZXcgU2lsZW50UmVuZXdTZXJ2aWNlQ3Rvcih0aGlzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIG9yZGVyIGlzIGltcG9ydGFudCBmb3IgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOyB0aGVzZSBzZXJ2aWNlcyBkZXBlbmQgdXBvbiB0aGUgZXZlbnRzLlxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5hdXRvbWF0aWNTaWxlbnRSZW5ldykge1xuICAgICAgICAgICAgTG9nLmRlYnVnKFwiYXV0b21hdGljU2lsZW50UmVuZXcgaXMgY29uZmlndXJlZCwgc2V0dGluZyB1cCBzaWxlbnQgcmVuZXdcIik7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0U2lsZW50UmVuZXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm1vbml0b3JTZXNzaW9uKSB7XG4gICAgICAgICAgICBMb2cuZGVidWcoXCJtb25pdG9yU2Vzc2lvbiBpcyBjb25maWd1cmVkLCBzZXR0aW5nIHVwIHNlc3Npb24gbW9uaXRvclwiKTtcbiAgICAgICAgICAgIHRoaXMuX3Nlc3Npb25Nb25pdG9yID0gbmV3IFNlc3Npb25Nb25pdG9yQ3Rvcih0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Rva2VuUmV2b2NhdGlvbkNsaWVudCA9IG5ldyBUb2tlblJldm9jYXRpb25DbGllbnRDdG9yKHRoaXMuX3NldHRpbmdzKTtcbiAgICB9XG5cbiAgICBnZXQgX3JlZGlyZWN0TmF2aWdhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5yZWRpcmVjdE5hdmlnYXRvcjtcbiAgICB9XG4gICAgZ2V0IF9wb3B1cE5hdmlnYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MucG9wdXBOYXZpZ2F0b3I7XG4gICAgfVxuICAgIGdldCBfaWZyYW1lTmF2aWdhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5pZnJhbWVOYXZpZ2F0b3I7XG4gICAgfVxuICAgIGdldCBfdXNlclN0b3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy51c2VyU3RvcmU7XG4gICAgfVxuXG4gICAgZ2V0IGV2ZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cztcbiAgICB9XG5cbiAgICBnZXRVc2VyKCkge1xuICAgICAgICBMb2cuZGVidWcoXCJVc2VyTWFuYWdlci5nZXRVc2VyXCIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkVXNlcigpLnRoZW4odXNlciA9PiB7XG4gICAgICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgICAgIExvZy5pbmZvKFwidXNlciBsb2FkZWRcIik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMubG9hZCh1c2VyLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIExvZy5pbmZvKFwidXNlciBub3QgZm91bmQgaW4gc3RvcmFnZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlVXNlcigpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiVXNlck1hbmFnZXIucmVtb3ZlVXNlclwiKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZVVzZXIobnVsbCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBMb2cuaW5mbyhcInVzZXIgcmVtb3ZlZCBmcm9tIHN0b3JhZ2VcIik7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMudW5sb2FkKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNpZ25pblJlZGlyZWN0KGFyZ3MpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiVXNlck1hbmFnZXIuc2lnbmluUmVkaXJlY3RcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaWduaW5TdGFydChhcmdzLCB0aGlzLl9yZWRpcmVjdE5hdmlnYXRvcikudGhlbigoKT0+e1xuICAgICAgICAgICAgTG9nLmluZm8oXCJzaWduaW5SZWRpcmVjdCBzdWNjZXNzZnVsXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbmluUmVkaXJlY3RDYWxsYmFjayh1cmwpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiVXNlck1hbmFnZXIuc2lnbmluUmVkaXJlY3RDYWxsYmFja1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25pbkVuZCh1cmwgfHwgdGhpcy5fcmVkaXJlY3ROYXZpZ2F0b3IudXJsKS50aGVuKHVzZXIgPT4ge1xuICAgICAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlci5wcm9maWxlICYmIHVzZXIucHJvZmlsZS5zdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJzaWduaW5SZWRpcmVjdENhbGxiYWNrIHN1Y2Nlc3NmdWwsIHNpZ25lZCBpbiBzdWI6IFwiLCB1c2VyLnByb2ZpbGUuc3ViKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwic2lnbmluUmVkaXJlY3RDYWxsYmFjayBzdWNjZXNzZnVsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBzaWduaW5Qb3B1cChhcmdzID0ge30pIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiVXNlck1hbmFnZXIuc2lnbmluUG9wdXBcIik7XG5cbiAgICAgICAgbGV0IHVybCA9IGFyZ3MucmVkaXJlY3RfdXJpIHx8IHRoaXMuc2V0dGluZ3MucG9wdXBfcmVkaXJlY3RfdXJpIHx8IHRoaXMuc2V0dGluZ3MucmVkaXJlY3RfdXJpO1xuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiTm8gcG9wdXBfcmVkaXJlY3RfdXJpIG9yIHJlZGlyZWN0X3VyaSBjb25maWd1cmVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIHBvcHVwX3JlZGlyZWN0X3VyaSBvciByZWRpcmVjdF91cmkgY29uZmlndXJlZFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmdzLnJlZGlyZWN0X3VyaSA9IHVybDtcbiAgICAgICAgYXJncy5kaXNwbGF5ID0gXCJwb3B1cFwiO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9zaWduaW4oYXJncywgdGhpcy5fcG9wdXBOYXZpZ2F0b3IsIHtcbiAgICAgICAgICAgIHN0YXJ0VXJsOiB1cmwsXG4gICAgICAgICAgICBwb3B1cFdpbmRvd0ZlYXR1cmVzOiBhcmdzLnBvcHVwV2luZG93RmVhdHVyZXMgfHwgdGhpcy5zZXR0aW5ncy5wb3B1cFdpbmRvd0ZlYXR1cmVzLFxuICAgICAgICAgICAgcG9wdXBXaW5kb3dUYXJnZXQ6IGFyZ3MucG9wdXBXaW5kb3dUYXJnZXQgfHwgdGhpcy5zZXR0aW5ncy5wb3B1cFdpbmRvd1RhcmdldFxuICAgICAgICB9KS50aGVuKHVzZXIgPT4ge1xuICAgICAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlci5wcm9maWxlICYmIHVzZXIucHJvZmlsZS5zdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJzaWduaW5Qb3B1cCBzdWNjZXNzZnVsLCBzaWduZWQgaW4gc3ViOiBcIiwgdXNlci5wcm9maWxlLnN1Yik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcInNpZ25pblBvcHVwIHN1Y2Nlc3NmdWxcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdXNlcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25pblBvcHVwQ2FsbGJhY2sodXJsKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIlVzZXJNYW5hZ2VyLnNpZ25pblBvcHVwQ2FsbGJhY2tcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaWduaW5DYWxsYmFjayh1cmwsIHRoaXMuX3BvcHVwTmF2aWdhdG9yKS50aGVuKHVzZXIgPT4ge1xuICAgICAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlci5wcm9maWxlICYmIHVzZXIucHJvZmlsZS5zdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJzaWduaW5Qb3B1cENhbGxiYWNrIHN1Y2Nlc3NmdWwsIHNpZ25lZCBpbiBzdWI6IFwiLCB1c2VyLnByb2ZpbGUuc3ViKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwic2lnbmluUG9wdXBDYWxsYmFjayBzdWNjZXNzZnVsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNpZ25pblNpbGVudChhcmdzID0ge30pIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiVXNlck1hbmFnZXIuc2lnbmluU2lsZW50XCIpO1xuXG4gICAgICAgIGxldCB1cmwgPSBhcmdzLnJlZGlyZWN0X3VyaSB8fCB0aGlzLnNldHRpbmdzLnNpbGVudF9yZWRpcmVjdF91cmk7XG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoXCJObyBzaWxlbnRfcmVkaXJlY3RfdXJpIGNvbmZpZ3VyZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm8gc2lsZW50X3JlZGlyZWN0X3VyaSBjb25maWd1cmVkXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3MucmVkaXJlY3RfdXJpID0gdXJsO1xuICAgICAgICBhcmdzLnByb21wdCA9IFwibm9uZVwiO1xuXG4gICAgICAgIGxldCBzZXRJZFRva2VuO1xuICAgICAgICBpZiAoYXJncy5pZF90b2tlbl9oaW50IHx8ICF0aGlzLnNldHRpbmdzLmluY2x1ZGVJZFRva2VuSW5TaWxlbnRSZW5ldykge1xuICAgICAgICAgICAgc2V0SWRUb2tlbiA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0SWRUb2tlbiA9IHRoaXMuX2xvYWRVc2VyKCkudGhlbih1c2VyID0+IHtcbiAgICAgICAgICAgICAgICBhcmdzLmlkX3Rva2VuX2hpbnQgPSB1c2VyICYmIHVzZXIuaWRfdG9rZW47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXRJZFRva2VuLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25pbihhcmdzLCB0aGlzLl9pZnJhbWVOYXZpZ2F0b3IsIHtcbiAgICAgICAgICAgICAgICBzdGFydFVybDogdXJsLFxuICAgICAgICAgICAgICAgIHNpbGVudFJlcXVlc3RUaW1lb3V0OiBhcmdzLnNpbGVudFJlcXVlc3RUaW1lb3V0IHx8IHRoaXMuc2V0dGluZ3Muc2lsZW50UmVxdWVzdFRpbWVvdXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKHVzZXIgPT4ge1xuICAgICAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlci5wcm9maWxlICYmIHVzZXIucHJvZmlsZS5zdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJzaWduaW5TaWxlbnQgc3VjY2Vzc2Z1bCwgc2lnbmVkIGluIHN1YjogXCIsIHVzZXIucHJvZmlsZS5zdWIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJzaWduaW5TaWxlbnQgc3VjY2Vzc2Z1bFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1c2VyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbmluU2lsZW50Q2FsbGJhY2sodXJsKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIlVzZXJNYW5hZ2VyLnNpZ25pblNpbGVudENhbGxiYWNrXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmluQ2FsbGJhY2sodXJsLCB0aGlzLl9pZnJhbWVOYXZpZ2F0b3IpLnRoZW4odXNlciA9PiB7XG4gICAgICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgICAgIGlmICh1c2VyLnByb2ZpbGUgJiYgdXNlci5wcm9maWxlLnN1Yikge1xuICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcInNpZ25pblNpbGVudENhbGxiYWNrIHN1Y2Nlc3NmdWwsIHNpZ25lZCBpbiBzdWI6IFwiLCB1c2VyLnByb2ZpbGUuc3ViKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwic2lnbmluU2lsZW50Q2FsbGJhY2sgc3VjY2Vzc2Z1bFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1c2VyO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBxdWVyeVNlc3Npb25TdGF0dXMoYXJncyA9IHt9KSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIlVzZXJNYW5hZ2VyLnF1ZXJ5U2Vzc2lvblN0YXR1c1wiKTtcblxuICAgICAgICBsZXQgdXJsID0gYXJncy5yZWRpcmVjdF91cmkgfHwgdGhpcy5zZXR0aW5ncy5zaWxlbnRfcmVkaXJlY3RfdXJpO1xuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiTm8gc2lsZW50X3JlZGlyZWN0X3VyaSBjb25maWd1cmVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIHNpbGVudF9yZWRpcmVjdF91cmkgY29uZmlndXJlZFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmdzLnJlZGlyZWN0X3VyaSA9IHVybDtcbiAgICAgICAgYXJncy5wcm9tcHQgPSBcIm5vbmVcIjtcbiAgICAgICAgYXJncy5yZXNwb25zZV90eXBlID0gXCJpZF90b2tlblwiO1xuICAgICAgICBhcmdzLnNjb3BlID0gXCJvcGVuaWRcIjtcblxuICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmluU3RhcnQoYXJncywgdGhpcy5faWZyYW1lTmF2aWdhdG9yLCB7XG4gICAgICAgICAgICBzdGFydFVybDogdXJsLFxuICAgICAgICAgICAgc2lsZW50UmVxdWVzdFRpbWVvdXQ6IGFyZ3Muc2lsZW50UmVxdWVzdFRpbWVvdXQgfHwgdGhpcy5zZXR0aW5ncy5zaWxlbnRSZXF1ZXN0VGltZW91dFxuICAgICAgICB9KS50aGVuKG5hdlJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NTaWduaW5SZXNwb25zZShuYXZSZXNwb25zZS51cmwpLnRoZW4oc2lnbmluUmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIExvZy5kZWJ1ZyhcImdvdCBzaWduaW4gcmVzcG9uc2VcIik7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2lnbmluUmVzcG9uc2Uuc2Vzc2lvbl9zdGF0ZSAmJiBzaWduaW5SZXNwb25zZS5wcm9maWxlLnN1YiAmJiBzaWduaW5SZXNwb25zZS5wcm9maWxlLnNpZCkge1xuICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcInF1ZXJ5U2Vzc2lvblN0YXR1cyBzdWNjZXNzIGZvciBzdWI6IFwiLCAgc2lnbmluUmVzcG9uc2UucHJvZmlsZS5zdWIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbl9zdGF0ZTogc2lnbmluUmVzcG9uc2Uuc2Vzc2lvbl9zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yjogc2lnbmluUmVzcG9uc2UucHJvZmlsZS5zdWIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWQ6IHNpZ25pblJlc3BvbnNlLnByb2ZpbGUuc2lkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcInF1ZXJ5U2Vzc2lvblN0YXR1cyBzdWNjZXNzZnVsLCB1c2VyIG5vdCBhdXRoZW50aWNhdGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfc2lnbmluKGFyZ3MsIG5hdmlnYXRvciwgbmF2aWdhdG9yUGFyYW1zID0ge30pIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiX3NpZ25pblwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25pblN0YXJ0KGFyZ3MsIG5hdmlnYXRvciwgbmF2aWdhdG9yUGFyYW1zKS50aGVuKG5hdlJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWduaW5FbmQobmF2UmVzcG9uc2UudXJsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zaWduaW5TdGFydChhcmdzLCBuYXZpZ2F0b3IsIG5hdmlnYXRvclBhcmFtcyA9IHt9KSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIl9zaWduaW5TdGFydFwiKTtcblxuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLnByZXBhcmUobmF2aWdhdG9yUGFyYW1zKS50aGVuKGhhbmRsZSA9PiB7XG4gICAgICAgICAgICBMb2cuZGVidWcoXCJnb3QgbmF2aWdhdG9yIHdpbmRvdyBoYW5kbGVcIik7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNpZ25pblJlcXVlc3QoYXJncykudGhlbihzaWduaW5SZXF1ZXN0ID0+IHtcbiAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJnb3Qgc2lnbmluIHJlcXVlc3RcIik7XG5cbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3JQYXJhbXMudXJsID0gc2lnbmluUmVxdWVzdC51cmw7XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yUGFyYW1zLmlkID0gc2lnbmluUmVxdWVzdC5zdGF0ZS5pZDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlLm5hdmlnYXRlKG5hdmlnYXRvclBhcmFtcyk7XG4gICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGUuY2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nLmRlYnVnKFwiRXJyb3IgYWZ0ZXIgcHJlcGFyaW5nIG5hdmlnYXRvciwgY2xvc2luZyBuYXZpZ2F0b3Igd2luZG93XCIpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2lnbmluRW5kKHVybCkge1xuICAgICAgICBMb2cuZGVidWcoXCJfc2lnbmluRW5kXCIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NTaWduaW5SZXNwb25zZSh1cmwpLnRoZW4oc2lnbmluUmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgTG9nLmRlYnVnKFwiZ290IHNpZ25pbiByZXNwb25zZVwiKTtcblxuICAgICAgICAgICAgbGV0IHVzZXIgPSBuZXcgVXNlcihzaWduaW5SZXNwb25zZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JlVXNlcih1c2VyKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJ1c2VyIHN0b3JlZFwiKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5sb2FkKHVzZXIpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zaWduaW5DYWxsYmFjayh1cmwsIG5hdmlnYXRvcikge1xuICAgICAgICBMb2cuZGVidWcoXCJfc2lnbmluQ2FsbGJhY2tcIik7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IuY2FsbGJhY2sodXJsKTtcbiAgICB9XG5cbiAgICBzaWdub3V0UmVkaXJlY3QoYXJncyA9IHt9KSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIlVzZXJNYW5hZ2VyLnNpZ25vdXRSZWRpcmVjdFwiKTtcbiAgICAgICAgbGV0IHBvc3RMb2dvdXRSZWRpcmVjdFVyaSA9IGFyZ3MucG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpIHx8IHRoaXMuc2V0dGluZ3MucG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpO1xuICAgICAgICBpZiAocG9zdExvZ291dFJlZGlyZWN0VXJpKXtcbiAgICAgICAgICAgIGFyZ3MucG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpID0gcG9zdExvZ291dFJlZGlyZWN0VXJpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zaWdub3V0U3RhcnQoYXJncywgdGhpcy5fcmVkaXJlY3ROYXZpZ2F0b3IpLnRoZW4oKCk9PntcbiAgICAgICAgICAgIExvZy5pbmZvKFwic2lnbm91dFJlZGlyZWN0IHN1Y2Nlc3NmdWxcIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWdub3V0UmVkaXJlY3RDYWxsYmFjayh1cmwpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiVXNlck1hbmFnZXIuc2lnbm91dFJlZGlyZWN0Q2FsbGJhY2tcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaWdub3V0RW5kKHVybCB8fCB0aGlzLl9yZWRpcmVjdE5hdmlnYXRvci51cmwpLnRoZW4ocmVzcG9uc2U9PntcbiAgICAgICAgICAgIExvZy5pbmZvKFwic2lnbm91dFJlZGlyZWN0Q2FsbGJhY2sgc3VjY2Vzc2Z1bFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2lnbm91dFBvcHVwKGFyZ3MgPSB7fSkge1xuICAgICAgICBMb2cuZGVidWcoXCJVc2VyTWFuYWdlci5zaWduaW5Qb3B1cFwiKTtcblxuICAgICAgICBsZXQgdXJsID0gYXJncy5wb3N0X2xvZ291dF9yZWRpcmVjdF91cmkgfHwgdGhpcy5zZXR0aW5ncy5wb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmkgfHwgdGhpcy5zZXR0aW5ncy5wb3N0X2xvZ291dF9yZWRpcmVjdF91cmk7XG4gICAgICAgIGFyZ3MucG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpID0gdXJsO1xuICAgICAgICBhcmdzLmRpc3BsYXkgPSBcInBvcHVwXCI7XG4gICAgICAgIGlmIChhcmdzLnBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSl7XG4gICAgICAgICAgICAvLyB3ZSdyZSBwdXR0aW5nIGEgZHVtbXkgZW50cnkgaW4gaGVyZSBiZWNhdXNlIHdlIFxuICAgICAgICAgICAgLy8gbmVlZCBhIHVuaXF1ZSBpZCBmcm9tIHRoZSBzdGF0ZSBmb3Igbm90aWZpY2F0aW9uXG4gICAgICAgICAgICAvLyB0byB0aGUgcGFyZW50IHdpbmRvdywgd2hpY2ggaXMgbmVjZXNzYXJ5IGlmIHdlXG4gICAgICAgICAgICAvLyBwbGFuIHRvIHJldHVybiBiYWNrIHRvIHRoZSBjbGllbnQgYWZ0ZXIgc2lnbm91dFxuICAgICAgICAgICAgLy8gYW5kIHNvIHdlIGNhbiBjbG9zZSB0aGUgcG9wdXAgYWZ0ZXIgc2lnbm91dFxuICAgICAgICAgICAgYXJncy5zdGF0ZSA9IGFyZ3Muc3RhdGUgfHwge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fc2lnbm91dChhcmdzLCB0aGlzLl9wb3B1cE5hdmlnYXRvciwge1xuICAgICAgICAgICAgc3RhcnRVcmw6IHVybCxcbiAgICAgICAgICAgIHBvcHVwV2luZG93RmVhdHVyZXM6IGFyZ3MucG9wdXBXaW5kb3dGZWF0dXJlcyB8fCB0aGlzLnNldHRpbmdzLnBvcHVwV2luZG93RmVhdHVyZXMsXG4gICAgICAgICAgICBwb3B1cFdpbmRvd1RhcmdldDogYXJncy5wb3B1cFdpbmRvd1RhcmdldCB8fCB0aGlzLnNldHRpbmdzLnBvcHVwV2luZG93VGFyZ2V0XG4gICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgTG9nLmluZm8oXCJzaWdub3V0UG9wdXAgc3VjY2Vzc2Z1bFwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25vdXRQb3B1cENhbGxiYWNrKHVybCwga2VlcE9wZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZihrZWVwT3BlbikgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZih1cmwpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHVybCA9IG51bGw7XG4gICAgICAgICAgICBrZWVwT3BlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgTG9nLmRlYnVnKFwiVXNlck1hbmFnZXIuc2lnbm91dFBvcHVwQ2FsbGJhY2tcIik7XG4gICAgICAgIGxldCBkZWxpbWl0ZXIgPSAnPyc7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3B1cE5hdmlnYXRvci5jYWxsYmFjayh1cmwsIGtlZXBPcGVuLCBkZWxpbWl0ZXIpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgTG9nLmluZm8oXCJzaWdub3V0UG9wdXBDYWxsYmFjayBzdWNjZXNzZnVsXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfc2lnbm91dChhcmdzLCBuYXZpZ2F0b3IsIG5hdmlnYXRvclBhcmFtcyA9IHt9KSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIl9zaWdub3V0XCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2lnbm91dFN0YXJ0KGFyZ3MsIG5hdmlnYXRvciwgbmF2aWdhdG9yUGFyYW1zKS50aGVuKG5hdlJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWdub3V0RW5kKG5hdlJlc3BvbnNlLnVybCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2lnbm91dFN0YXJ0KGFyZ3MgPSB7fSwgbmF2aWdhdG9yLCBuYXZpZ2F0b3JQYXJhbXMgPSB7fSkge1xuICAgICAgICBMb2cuZGVidWcoXCJfc2lnbm91dFN0YXJ0XCIpO1xuXG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IucHJlcGFyZShuYXZpZ2F0b3JQYXJhbXMpLnRoZW4oaGFuZGxlID0+IHtcbiAgICAgICAgICAgIExvZy5kZWJ1ZyhcImdvdCBuYXZpZ2F0b3Igd2luZG93IGhhbmRsZVwiKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRVc2VyKCkudGhlbih1c2VyID0+IHtcbiAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJsb2FkZWQgY3VycmVudCB1c2VyIGZyb20gc3RvcmFnZVwiKTtcblxuICAgICAgICAgICAgICAgIHZhciByZXZva2VQcm9taXNlID0gdGhpcy5fc2V0dGluZ3MucmV2b2tlQWNjZXNzVG9rZW5PblNpZ25vdXQgPyB0aGlzLl9yZXZva2VJbnRlcm5hbCh1c2VyKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXZva2VQcm9taXNlLnRoZW4oKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZF90b2tlbiA9IGFyZ3MuaWRfdG9rZW5faGludCB8fCB1c2VyICYmIHVzZXIuaWRfdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZF90b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmRlYnVnKFwiU2V0dGluZyBpZF90b2tlbiBpbnRvIHNpZ25vdXQgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuaWRfdG9rZW5faGludCA9IGlkX3Rva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlVXNlcigpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmRlYnVnKFwidXNlciByZW1vdmVkLCBjcmVhdGluZyBzaWdub3V0IHJlcXVlc3RcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNpZ25vdXRSZXF1ZXN0KGFyZ3MpLnRoZW4oc2lnbm91dFJlcXVlc3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZy5kZWJ1ZyhcImdvdCBzaWdub3V0IHJlcXVlc3RcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3JQYXJhbXMudXJsID0gc2lnbm91dFJlcXVlc3QudXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWdub3V0UmVxdWVzdC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3JQYXJhbXMuaWQgPSBzaWdub3V0UmVxdWVzdC5zdGF0ZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZS5uYXZpZ2F0ZShuYXZpZ2F0b3JQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlLmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZy5kZWJ1ZyhcIkVycm9yIGFmdGVyIHByZXBhcmluZyBuYXZpZ2F0b3IsIGNsb3NpbmcgbmF2aWdhdG9yIHdpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3NpZ25vdXRFbmQodXJsKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIl9zaWdub3V0RW5kXCIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NTaWdub3V0UmVzcG9uc2UodXJsKS50aGVuKHNpZ25vdXRSZXNwb25zZSA9PiB7XG4gICAgICAgICAgICBMb2cuZGVidWcoXCJnb3Qgc2lnbm91dCByZXNwb25zZVwiKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNpZ25vdXRSZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV2b2tlQWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIlVzZXJNYW5hZ2VyLnJldm9rZUFjY2Vzc1Rva2VuXCIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkVXNlcigpLnRoZW4odXNlciA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV2b2tlSW50ZXJuYWwodXNlciwgdHJ1ZSkudGhlbihzdWNjZXNzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJyZW1vdmluZyB0b2tlbiBwcm9wZXJ0aWVzIGZyb20gdXNlciBhbmQgcmUtc3RvcmluZ1wiKTtcblxuICAgICAgICAgICAgICAgICAgICB1c2VyLmFjY2Vzc190b2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHVzZXIuZXhwaXJlc19hdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHVzZXIudG9rZW5fdHlwZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmVVc2VyKHVzZXIpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmRlYnVnKFwidXNlciBzdG9yZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMubG9hZCh1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4oKCk9PntcbiAgICAgICAgICAgIExvZy5pbmZvKFwiYWNjZXNzIHRva2VuIHJldm9rZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfcmV2b2tlSW50ZXJuYWwodXNlciwgcmVxdWlyZWQpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiY2hlY2tpbmcgaWYgdG9rZW4gcmV2b2NhdGlvbiBpcyBuZWNlc3NhcnlcIik7XG5cbiAgICAgICAgdmFyIGFjY2Vzc190b2tlbiA9IHVzZXIgJiYgdXNlci5hY2Nlc3NfdG9rZW47XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIEpXVCB2cy4gcmVmZXJlbmNlIHRva2VuXG4gICAgICAgIGlmICghYWNjZXNzX3Rva2VuIHx8IGFjY2Vzc190b2tlbi5pbmRleE9mKCcuJykgPj0gMCkge1xuICAgICAgICAgICAgTG9nLmRlYnVnKFwibm8gbmVlZCB0byByZXZva2UgZHVlIHRvIG5vIHVzZXIsIHRva2VuLCBvciBKV1QgZm9ybWF0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5SZXZvY2F0aW9uQ2xpZW50LnJldm9rZShhY2Nlc3NfdG9rZW4sIHJlcXVpcmVkKS50aGVuKCgpID0+IHRydWUpO1xuICAgIH1cblxuICAgIHN0YXJ0U2lsZW50UmVuZXcoKSB7XG4gICAgICAgIHRoaXMuX3NpbGVudFJlbmV3U2VydmljZS5zdGFydCgpO1xuICAgIH1cblxuICAgIHN0b3BTaWxlbnRSZW5ldygpIHtcbiAgICAgICAgdGhpcy5fc2lsZW50UmVuZXdTZXJ2aWNlLnN0b3AoKTtcbiAgICB9XG5cbiAgICBnZXQgX3VzZXJTdG9yZUtleSgpIHtcbiAgICAgICAgcmV0dXJuIGB1c2VyOiR7dGhpcy5zZXR0aW5ncy5hdXRob3JpdHl9OiR7dGhpcy5zZXR0aW5ncy5jbGllbnRfaWR9YDtcbiAgICB9XG5cbiAgICBfbG9hZFVzZXIoKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIl9sb2FkVXNlclwiKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdXNlclN0b3JlLmdldCh0aGlzLl91c2VyU3RvcmVLZXkpLnRoZW4oc3RvcmFnZVN0cmluZyA9PiB7XG4gICAgICAgICAgICBpZiAoc3RvcmFnZVN0cmluZykge1xuICAgICAgICAgICAgICAgIExvZy5kZWJ1ZyhcInVzZXIgc3RvcmFnZVN0cmluZyBsb2FkZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFVzZXIuZnJvbVN0b3JhZ2VTdHJpbmcoc3RvcmFnZVN0cmluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIExvZy5kZWJ1ZyhcIm5vIHVzZXIgc3RvcmFnZVN0cmluZ1wiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdG9yZVVzZXIodXNlcikge1xuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgTG9nLmRlYnVnKFwic3RvcmVVc2VyIHN0b3JpbmcgdXNlclwiKTtcblxuICAgICAgICAgICAgdmFyIHN0b3JhZ2VTdHJpbmcgPSB1c2VyLnRvU3RvcmFnZVN0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJTdG9yZS5zZXQodGhpcy5fdXNlclN0b3JlS2V5LCBzdG9yYWdlU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIExvZy5kZWJ1ZyhcInN0b3JlVXNlciByZW1vdmluZyB1c2VyIHN0b3JhZ2VcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlclN0b3JlLnJlbW92ZSh0aGlzLl91c2VyU3RvcmVLZXkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1VzZXJNYW5hZ2VyLmpzIiwiLy8gQ29weXJpZ2h0IChjKSBCcm9jayBBbGxlbiAmIERvbWluaWNrIEJhaWVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuaW1wb3J0IExvZyBmcm9tICcuL0xvZyc7XG5pbXBvcnQgT2lkY0NsaWVudFNldHRpbmdzIGZyb20gJy4vT2lkY0NsaWVudFNldHRpbmdzJztcbmltcG9ydCBSZWRpcmVjdE5hdmlnYXRvciBmcm9tICcuL1JlZGlyZWN0TmF2aWdhdG9yJztcbmltcG9ydCBQb3B1cE5hdmlnYXRvciBmcm9tICcuL1BvcHVwTmF2aWdhdG9yJztcbmltcG9ydCBJRnJhbWVOYXZpZ2F0b3IgZnJvbSAnLi9JRnJhbWVOYXZpZ2F0b3InO1xuaW1wb3J0IFdlYlN0b3JhZ2VTdGF0ZVN0b3JlIGZyb20gJy4vV2ViU3RvcmFnZVN0YXRlU3RvcmUnO1xuaW1wb3J0IEdsb2JhbCBmcm9tICcuL0dsb2JhbCc7XG5cbmNvbnN0IERlZmF1bHRBY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZSA9IDYwO1xuY29uc3QgRGVmYXVsdENoZWNrU2Vzc2lvbkludGVydmFsID0gMjAwMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlck1hbmFnZXJTZXR0aW5ncyBleHRlbmRzIE9pZGNDbGllbnRTZXR0aW5ncyB7XG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBwb3B1cF9yZWRpcmVjdF91cmksXG4gICAgICAgIHBvcHVwX3Bvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSxcbiAgICAgICAgcG9wdXBXaW5kb3dGZWF0dXJlcyxcbiAgICAgICAgcG9wdXBXaW5kb3dUYXJnZXQsXG4gICAgICAgIHNpbGVudF9yZWRpcmVjdF91cmksXG4gICAgICAgIHNpbGVudFJlcXVlc3RUaW1lb3V0LFxuICAgICAgICBhdXRvbWF0aWNTaWxlbnRSZW5ldyA9IGZhbHNlLFxuICAgICAgICBpbmNsdWRlSWRUb2tlbkluU2lsZW50UmVuZXcgPSB0cnVlLFxuICAgICAgICBtb25pdG9yU2Vzc2lvbiA9IHRydWUsXG4gICAgICAgIGNoZWNrU2Vzc2lvbkludGVydmFsID0gRGVmYXVsdENoZWNrU2Vzc2lvbkludGVydmFsLFxuICAgICAgICByZXZva2VBY2Nlc3NUb2tlbk9uU2lnbm91dCA9IGZhbHNlLFxuICAgICAgICBhY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZSA9IERlZmF1bHRBY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZSxcbiAgICAgICAgcmVkaXJlY3ROYXZpZ2F0b3IgPSBuZXcgUmVkaXJlY3ROYXZpZ2F0b3IoKSxcbiAgICAgICAgcG9wdXBOYXZpZ2F0b3IgPSBuZXcgUG9wdXBOYXZpZ2F0b3IoKSxcbiAgICAgICAgaWZyYW1lTmF2aWdhdG9yID0gbmV3IElGcmFtZU5hdmlnYXRvcigpLFxuICAgICAgICB1c2VyU3RvcmUgPSBuZXcgV2ViU3RvcmFnZVN0YXRlU3RvcmUoeyBzdG9yZTogR2xvYmFsLnNlc3Npb25TdG9yYWdlIH0pXG4gICAgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGFyZ3VtZW50c1swXSk7XG5cbiAgICAgICAgdGhpcy5fcG9wdXBfcmVkaXJlY3RfdXJpID0gcG9wdXBfcmVkaXJlY3RfdXJpO1xuICAgICAgICB0aGlzLl9wb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmkgPSBwb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmk7XG4gICAgICAgIHRoaXMuX3BvcHVwV2luZG93RmVhdHVyZXMgPSBwb3B1cFdpbmRvd0ZlYXR1cmVzO1xuICAgICAgICB0aGlzLl9wb3B1cFdpbmRvd1RhcmdldCA9IHBvcHVwV2luZG93VGFyZ2V0O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fc2lsZW50X3JlZGlyZWN0X3VyaSA9IHNpbGVudF9yZWRpcmVjdF91cmk7XG4gICAgICAgIHRoaXMuX3NpbGVudFJlcXVlc3RUaW1lb3V0ID0gc2lsZW50UmVxdWVzdFRpbWVvdXQ7XG4gICAgICAgIHRoaXMuX2F1dG9tYXRpY1NpbGVudFJlbmV3ID0gISFhdXRvbWF0aWNTaWxlbnRSZW5ldztcbiAgICAgICAgdGhpcy5faW5jbHVkZUlkVG9rZW5JblNpbGVudFJlbmV3ID0gaW5jbHVkZUlkVG9rZW5JblNpbGVudFJlbmV3O1xuICAgICAgICB0aGlzLl9hY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZSA9IGFjY2Vzc1Rva2VuRXhwaXJpbmdOb3RpZmljYXRpb25UaW1lO1xuXG4gICAgICAgIHRoaXMuX21vbml0b3JTZXNzaW9uID0gbW9uaXRvclNlc3Npb247XG4gICAgICAgIHRoaXMuX2NoZWNrU2Vzc2lvbkludGVydmFsID0gY2hlY2tTZXNzaW9uSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuX3Jldm9rZUFjY2Vzc1Rva2VuT25TaWdub3V0ID0gcmV2b2tlQWNjZXNzVG9rZW5PblNpZ25vdXQ7XG5cbiAgICAgICAgdGhpcy5fcmVkaXJlY3ROYXZpZ2F0b3IgPSByZWRpcmVjdE5hdmlnYXRvcjtcbiAgICAgICAgdGhpcy5fcG9wdXBOYXZpZ2F0b3IgPSBwb3B1cE5hdmlnYXRvcjtcbiAgICAgICAgdGhpcy5faWZyYW1lTmF2aWdhdG9yID0gaWZyYW1lTmF2aWdhdG9yO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fdXNlclN0b3JlID0gdXNlclN0b3JlO1xuICAgIH1cblxuICAgIGdldCBwb3B1cF9yZWRpcmVjdF91cmkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3B1cF9yZWRpcmVjdF91cmk7XG4gICAgfVxuICAgIGdldCBwb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmk7XG4gICAgfVxuICAgIGdldCBwb3B1cFdpbmRvd0ZlYXR1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9wdXBXaW5kb3dGZWF0dXJlcztcbiAgICB9XG4gICAgZ2V0IHBvcHVwV2luZG93VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9wdXBXaW5kb3dUYXJnZXQ7XG4gICAgfVxuXG4gICAgZ2V0IHNpbGVudF9yZWRpcmVjdF91cmkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaWxlbnRfcmVkaXJlY3RfdXJpO1xuICAgIH1cbiAgICAgZ2V0IHNpbGVudFJlcXVlc3RUaW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2lsZW50UmVxdWVzdFRpbWVvdXQ7XG4gICAgfVxuICAgIGdldCBhdXRvbWF0aWNTaWxlbnRSZW5ldygpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuc2lsZW50X3JlZGlyZWN0X3VyaSAmJiB0aGlzLl9hdXRvbWF0aWNTaWxlbnRSZW5ldyk7XG4gICAgfVxuICAgIGdldCBpbmNsdWRlSWRUb2tlbkluU2lsZW50UmVuZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmNsdWRlSWRUb2tlbkluU2lsZW50UmVuZXc7XG4gICAgfVxuICAgIGdldCBhY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjY2Vzc1Rva2VuRXhwaXJpbmdOb3RpZmljYXRpb25UaW1lO1xuICAgIH1cblxuICAgIGdldCBtb25pdG9yU2Vzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbml0b3JTZXNzaW9uO1xuICAgIH1cbiAgICBnZXQgY2hlY2tTZXNzaW9uSW50ZXJ2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja1Nlc3Npb25JbnRlcnZhbDtcbiAgICB9XG4gICAgZ2V0IHJldm9rZUFjY2Vzc1Rva2VuT25TaWdub3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmV2b2tlQWNjZXNzVG9rZW5PblNpZ25vdXQ7XG4gICAgfVxuXG4gICAgZ2V0IHJlZGlyZWN0TmF2aWdhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkaXJlY3ROYXZpZ2F0b3I7XG4gICAgfVxuICAgIGdldCBwb3B1cE5hdmlnYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcHVwTmF2aWdhdG9yO1xuICAgIH1cbiAgICBnZXQgaWZyYW1lTmF2aWdhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWZyYW1lTmF2aWdhdG9yO1xuICAgIH1cbiAgICBcbiAgICBnZXQgdXNlclN0b3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlclN0b3JlO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Vc2VyTWFuYWdlclNldHRpbmdzLmpzIiwiLy8gQ29weXJpZ2h0IChjKSBCcm9jayBBbGxlbiAmIERvbWluaWNrIEJhaWVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuaW1wb3J0IExvZyBmcm9tICcuL0xvZyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZGlyZWN0TmF2aWdhdG9yIHtcbiAgICBcbiAgICBwcmVwYXJlKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIH1cblxuICAgIG5hdmlnYXRlKHBhcmFtcykge1xuICAgICAgICBMb2cuZGVidWcoXCJSZWRpcmVjdE5hdmlnYXRvci5uYXZpZ2F0ZVwiKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghcGFyYW1zIHx8ICFwYXJhbXMudXJsKSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoXCJObyB1cmwgcHJvdmlkZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm8gdXJsIHByb3ZpZGVkXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHBhcmFtcy51cmw7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHVybCgpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiUmVkaXJlY3ROYXZpZ2F0b3IudXJsXCIpO1xuICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1JlZGlyZWN0TmF2aWdhdG9yLmpzIiwiLy8gQ29weXJpZ2h0IChjKSBCcm9jayBBbGxlbiAmIERvbWluaWNrIEJhaWVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuaW1wb3J0IExvZyBmcm9tICcuL0xvZyc7XG5pbXBvcnQgUG9wdXBXaW5kb3cgZnJvbSAnLi9Qb3B1cFdpbmRvdyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvcHVwTmF2aWdhdG9yIHtcbiAgICBcbiAgICBwcmVwYXJlKHBhcmFtcykge1xuICAgICAgICBsZXQgcG9wdXAgPSBuZXcgUG9wdXBXaW5kb3cocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwb3B1cCk7XG4gICAgfVxuICAgIFxuICAgIGNhbGxiYWNrKHVybCwga2VlcE9wZW4sIGRlbGltaXRlcikge1xuICAgICAgICBMb2cuZGVidWcoXCJQb3B1cE5hdmlnYXRvci5jYWxsYmFja1wiKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgUG9wdXBXaW5kb3cubm90aWZ5T3BlbmVyKHVybCwga2VlcE9wZW4sIGRlbGltaXRlcik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Qb3B1cE5hdmlnYXRvci5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBMb2cgZnJvbSAnLi9Mb2cnO1xuaW1wb3J0IFVybFV0aWxpdHkgZnJvbSAnLi9VcmxVdGlsaXR5JztcblxuY29uc3QgQ2hlY2tGb3JQb3B1cENsb3NlZEludGVydmFsID0gNTAwO1xuY29uc3QgRGVmYXVsdFBvcHVwRmVhdHVyZXMgPSAnbG9jYXRpb249bm8sdG9vbGJhcj1ubyx3aWR0aD01MDAsaGVpZ2h0PTUwMCxsZWZ0PTEwMCx0b3A9MTAwOyc7XG4vL2NvbnN0IERlZmF1bHRQb3B1cEZlYXR1cmVzID0gJ2xvY2F0aW9uPW5vLHRvb2xiYXI9bm8sd2lkdGg9NTAwLGhlaWdodD01MDAsbGVmdD0xMDAsdG9wPTEwMDtyZXNpemFibGU9eWVzJztcblxuY29uc3QgRGVmYXVsdFBvcHVwVGFyZ2V0ID0gXCJfYmxhbmtcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9wdXBXaW5kb3cge1xuXG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIlBvcHVwV2luZG93LmN0b3JcIik7XG5cbiAgICAgICAgdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgdGFyZ2V0ID0gcGFyYW1zLnBvcHVwV2luZG93VGFyZ2V0IHx8IERlZmF1bHRQb3B1cFRhcmdldDtcbiAgICAgICAgbGV0IGZlYXR1cmVzID0gcGFyYW1zLnBvcHVwV2luZG93RmVhdHVyZXMgfHwgRGVmYXVsdFBvcHVwRmVhdHVyZXM7XG5cbiAgICAgICAgdGhpcy5fcG9wdXAgPSB3aW5kb3cub3BlbignJywgdGFyZ2V0LCBmZWF0dXJlcyk7XG4gICAgICAgIGlmICh0aGlzLl9wb3B1cCkge1xuICAgICAgICAgICAgTG9nLmRlYnVnKFwicG9wdXAgc3VjY2Vzc2Z1bGx5IGNyZWF0ZWRcIik7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0ZvclBvcHVwQ2xvc2VkVGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwodGhpcy5fY2hlY2tGb3JQb3B1cENsb3NlZC5iaW5kKHRoaXMpLCBDaGVja0ZvclBvcHVwQ2xvc2VkSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICAgIH1cblxuICAgIG5hdmlnYXRlKHBhcmFtcykge1xuICAgICAgICBMb2cuZGVidWcoXCJQb3B1cFdpbmRvdy5uYXZpZ2F0ZVwiKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3BvcHVwKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihcIkVycm9yIG9wZW5pbmcgcG9wdXAgd2luZG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFwYXJhbXMgfHwgIXBhcmFtcy51cmwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKFwiTm8gdXJsIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgTG9nLmRlYnVnKFwiU2V0dGluZyBVUkwgaW4gcG9wdXBcIik7XG5cbiAgICAgICAgICAgIHRoaXMuX2lkID0gcGFyYW1zLmlkO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93W1wicG9wdXBDYWxsYmFja19cIiArIHBhcmFtcy5pZF0gPSB0aGlzLl9jYWxsYmFjay5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9wb3B1cC5mb2N1cygpO1xuICAgICAgICAgICAgdGhpcy5fcG9wdXAud2luZG93LmxvY2F0aW9uID0gcGFyYW1zLnVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgfVxuXG4gICAgX3N1Y2Nlc3MoZGF0YSkge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG5cbiAgICAgICAgTG9nLmRlYnVnKFwiU3VjY2Vzc2Z1bCByZXNwb25zZSBmcm9tIHBvcHVwIHdpbmRvd1wiKTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZShkYXRhKTtcbiAgICB9XG4gICAgX2Vycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuXG4gICAgICAgIExvZy5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fcmVqZWN0KG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xuICAgIH1cblxuICAgIF9jbGVhbnVwKGtlZXBPcGVuKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIlBvcHVwV2luZG93Ll9jbGVhbnVwXCIpO1xuXG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuX2NoZWNrRm9yUG9wdXBDbG9zZWRUaW1lcik7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9yUG9wdXBDbG9zZWRUaW1lciA9IG51bGw7XG5cbiAgICAgICAgZGVsZXRlIHdpbmRvd1tcInBvcHVwQ2FsbGJhY2tfXCIgKyB0aGlzLl9pZF07XG5cbiAgICAgICAgaWYgKHRoaXMuX3BvcHVwICYmICFrZWVwT3Blbikge1xuICAgICAgICAgICAgdGhpcy5fcG9wdXAuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb3B1cCA9IG51bGw7XG4gICAgfVxuXG4gICAgX2NoZWNrRm9yUG9wdXBDbG9zZWQoKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIlBvcHVwV2luZG93Ll9jaGVja0ZvclBvcHVwQ2xvc2VkXCIpO1xuXG4gICAgICAgIGlmICghdGhpcy5fcG9wdXAgfHwgdGhpcy5fcG9wdXAuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihcIlBvcHVwIHdpbmRvdyBjbG9zZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY2FsbGJhY2sodXJsLCBrZWVwT3Blbikge1xuICAgICAgICBMb2cuZGVidWcoXCJQb3B1cFdpbmRvdy5fY2FsbGJhY2tcIik7XG5cbiAgICAgICAgdGhpcy5fY2xlYW51cChrZWVwT3Blbik7XG5cbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgdGhpcy5fc3VjY2Vzcyh7IHVybDogdXJsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZyb20gcG9wdXBcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgbm90aWZ5T3BlbmVyKHVybCwga2VlcE9wZW4sIGRlbGltaXRlcikge1xuICAgICAgICBMb2cuZGVidWcoXCJQb3B1cFdpbmRvdy5ub3RpZnlPcGVuZXJcIik7XG5cbiAgICAgICAgaWYgKHdpbmRvdy5vcGVuZXIpIHtcbiAgICAgICAgICAgIHVybCA9IHVybCB8fCB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgICAgICAgIGlmICh1cmwpIHtcblxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gVXJsVXRpbGl0eS5wYXJzZVVybEZyYWdtZW50KHVybCwgZGVsaW1pdGVyKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFwicG9wdXBDYWxsYmFja19cIiArIGRhdGEuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHdpbmRvdy5vcGVuZXJbbmFtZV07IFxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZy5kZWJ1ZyhcInBhc3NpbmcgdXJsIG1lc3NhZ2UgdG8gb3BlbmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodXJsLCBrZWVwT3Blbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2cud2FybihcIm5vIG1hdGNoaW5nIGNhbGxiYWNrIGZvdW5kIG9uIG9wZW5lclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nLndhcm4oXCJubyBzdGF0ZSBmb3VuZCBpbiByZXNwb25zZSB1cmxcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1BvcHVwV2luZG93LmpzIiwiLy8gQ29weXJpZ2h0IChjKSBCcm9jayBBbGxlbiAmIERvbWluaWNrIEJhaWVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuaW1wb3J0IExvZyBmcm9tICcuL0xvZyc7XG5pbXBvcnQgSUZyYW1lV2luZG93IGZyb20gJy4vSUZyYW1lV2luZG93JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSUZyYW1lTmF2aWdhdG9yIHtcblxuICAgIHByZXBhcmUocGFyYW1zKSB7XG4gICAgICAgIGxldCBmcmFtZSA9IG5ldyBJRnJhbWVXaW5kb3cocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmcmFtZSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2sodXJsKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIklGcmFtZU5hdmlnYXRvci5jYWxsYmFja1wiKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgSUZyYW1lV2luZG93Lm5vdGlmeVBhcmVudCh1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvSUZyYW1lTmF2aWdhdG9yLmpzIiwiLy8gQ29weXJpZ2h0IChjKSBCcm9jayBBbGxlbiAmIERvbWluaWNrIEJhaWVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuaW1wb3J0IExvZyBmcm9tICcuL0xvZyc7XG5cbmNvbnN0IERlZmF1bHRUaW1lb3V0ID0gMTAwMDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElGcmFtZVdpbmRvdyB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiSUZyYW1lV2luZG93LmN0b3JcIik7XG5cbiAgICAgICAgdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9ib3VuZE1lc3NhZ2VFdmVudCA9IHRoaXMuX21lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX2JvdW5kTWVzc2FnZUV2ZW50LCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9mcmFtZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuXG4gICAgICAgIC8vIHNob3RndW4gYXBwcm9hY2hcbiAgICAgICAgdGhpcy5fZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIHRoaXMuX2ZyYW1lLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICB0aGlzLl9mcmFtZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHRoaXMuX2ZyYW1lLnN0eWxlLndpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fZnJhbWUuc3R5bGUuaGVpZ2h0ID0gMDtcbiAgICAgICAgXG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2ZyYW1lKTtcbiAgICB9XG5cbiAgICBuYXZpZ2F0ZShwYXJhbXMpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiSUZyYW1lV2luZG93Lm5hdmlnYXRlXCIpO1xuXG4gICAgICAgIGlmICghcGFyYW1zIHx8ICFwYXJhbXMudXJsKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihcIk5vIHVybCBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB0aW1lb3V0ID0gcGFyYW1zLnNpbGVudFJlcXVlc3RUaW1lb3V0IHx8IERlZmF1bHRUaW1lb3V0O1xuICAgICAgICAgICAgTG9nLmRlYnVnKFwiVXNpbmcgdGltZW91dCBvZjpcIiwgdGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuX3RpbWVvdXQuYmluZCh0aGlzKSwgdGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLl9mcmFtZS5zcmMgPSBwYXJhbXMudXJsO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIH1cblxuICAgIGdldCBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICB9XG5cbiAgICBfc3VjY2VzcyhkYXRhKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcblxuICAgICAgICBMb2cuZGVidWcoXCJTdWNjZXNzZnVsIHJlc3BvbnNlIGZyb20gZnJhbWUgd2luZG93XCIpO1xuICAgICAgICB0aGlzLl9yZXNvbHZlKGRhdGEpO1xuICAgIH1cbiAgICBfZXJyb3IobWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG5cbiAgICAgICAgTG9nLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9yZWplY3QobmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICB9XG5cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIH1cblxuICAgIF9jbGVhbnVwKCkge1xuICAgICAgICBpZiAodGhpcy5fZnJhbWUpIHtcbiAgICAgICAgICAgIExvZy5kZWJ1ZyhcIklGcmFtZVdpbmRvdy5fY2xlYW51cFwiKTtcblxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX2JvdW5kTWVzc2FnZUV2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuX2ZyYW1lKTtcblxuICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fZnJhbWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fYm91bmRNZXNzYWdlRXZlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3RpbWVvdXQoKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIklGcmFtZVdpbmRvdy5fdGltZW91dFwiKTtcbiAgICAgICAgdGhpcy5fZXJyb3IoXCJGcmFtZSB3aW5kb3cgdGltZWQgb3V0XCIpO1xuICAgIH1cblxuICAgIF9tZXNzYWdlKGUpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiSUZyYW1lV2luZG93Ll9tZXNzYWdlXCIpO1xuXG4gICAgICAgIGlmICh0aGlzLl90aW1lciAmJlxuICAgICAgICAgICAgZS5vcmlnaW4gPT09IHRoaXMuX29yaWdpbiAmJlxuICAgICAgICAgICAgZS5zb3VyY2UgPT09IHRoaXMuX2ZyYW1lLmNvbnRlbnRXaW5kb3dcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBsZXQgdXJsID0gZS5kYXRhO1xuICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1Y2Nlc3MoeyB1cmw6IHVybCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yKFwiSW52YWxpZCByZXNwb25zZSBmcm9tIGZyYW1lXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IF9vcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gICAgfVxuXG4gICAgc3RhdGljIG5vdGlmeVBhcmVudCh1cmwpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiSUZyYW1lV2luZG93Lm5vdGlmeVBhcmVudFwiKTtcblxuICAgICAgICBpZiAod2luZG93LnBhcmVudCAmJiB3aW5kb3cgIT09IHdpbmRvdy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHVybCA9IHVybCB8fCB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJwb3N0aW5nIHVybCBtZXNzYWdlIHRvIHBhcmVudFwiKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKHVybCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9JRnJhbWVXaW5kb3cuanMiLCIvLyBDb3B5cmlnaHQgKGMpIEJyb2NrIEFsbGVuICYgRG9taW5pY2sgQmFpZXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTElDRU5TRSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG5pbXBvcnQgTG9nIGZyb20gJy4vTG9nJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlciB7XG4gICAgY29uc3RydWN0b3Ioe2lkX3Rva2VuLCBzZXNzaW9uX3N0YXRlLCBhY2Nlc3NfdG9rZW4sIHRva2VuX3R5cGUsIHNjb3BlLCBwcm9maWxlLCBleHBpcmVzX2F0LCBzdGF0ZX0pIHtcbiAgICAgICAgdGhpcy5pZF90b2tlbiA9IGlkX3Rva2VuO1xuICAgICAgICB0aGlzLnNlc3Npb25fc3RhdGUgPSBzZXNzaW9uX3N0YXRlO1xuICAgICAgICB0aGlzLmFjY2Vzc190b2tlbiA9IGFjY2Vzc190b2tlbjtcbiAgICAgICAgdGhpcy50b2tlbl90eXBlID0gdG9rZW5fdHlwZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLnByb2ZpbGUgPSBwcm9maWxlO1xuICAgICAgICB0aGlzLmV4cGlyZXNfYXQgPSBleHBpcmVzX2F0O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfVxuXG4gICAgZ2V0IGV4cGlyZXNfaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cGlyZXNfYXQpIHtcbiAgICAgICAgICAgIGxldCBub3cgPSBwYXJzZUludChEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBpcmVzX2F0IC0gbm93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZ2V0IGV4cGlyZWQoKSB7XG4gICAgICAgIGxldCBleHBpcmVzX2luID0gdGhpcy5leHBpcmVzX2luO1xuICAgICAgICBpZiAoZXhwaXJlc19pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwaXJlc19pbiA8PSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZ2V0IHNjb3BlcygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnNjb3BlIHx8IFwiXCIpLnNwbGl0KFwiIFwiKTtcbiAgICB9XG5cbiAgICB0b1N0b3JhZ2VTdHJpbmcoKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIlVzZXIudG9TdG9yYWdlU3RyaW5nXCIpO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgaWRfdG9rZW46IHRoaXMuaWRfdG9rZW4sXG4gICAgICAgICAgICBzZXNzaW9uX3N0YXRlOiB0aGlzLnNlc3Npb25fc3RhdGUsXG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHRoaXMuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgdG9rZW5fdHlwZTogdGhpcy50b2tlbl90eXBlLFxuICAgICAgICAgICAgc2NvcGU6IHRoaXMuc2NvcGUsXG4gICAgICAgICAgICBwcm9maWxlOiB0aGlzLnByb2ZpbGUsXG4gICAgICAgICAgICBleHBpcmVzX2F0OiB0aGlzLmV4cGlyZXNfYXRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21TdG9yYWdlU3RyaW5nKHN0b3JhZ2VTdHJpbmcpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiVXNlci5mcm9tU3RvcmFnZVN0cmluZ1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVc2VyKEpTT04ucGFyc2Uoc3RvcmFnZVN0cmluZykpO1xuICAgIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvVXNlci5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBMb2cgZnJvbSAnLi9Mb2cnO1xuaW1wb3J0IEFjY2Vzc1Rva2VuRXZlbnRzIGZyb20gJy4vQWNjZXNzVG9rZW5FdmVudHMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4vRXZlbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVc2VyTWFuYWdlckV2ZW50cyBleHRlbmRzIEFjY2Vzc1Rva2VuRXZlbnRzIHtcblxuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5fdXNlckxvYWRlZCA9IG5ldyBFdmVudChcIlVzZXIgbG9hZGVkXCIpO1xuICAgICAgICB0aGlzLl91c2VyVW5sb2FkZWQgPSBuZXcgRXZlbnQoXCJVc2VyIHVubG9hZGVkXCIpO1xuICAgICAgICB0aGlzLl9zaWxlbnRSZW5ld0Vycm9yID0gbmV3IEV2ZW50KFwiU2lsZW50IHJlbmV3IGVycm9yXCIpO1xuICAgICAgICB0aGlzLl91c2VyU2lnbmVkT3V0ID0gbmV3IEV2ZW50KFwiVXNlciBzaWduZWQgb3V0XCIpO1xuICAgICAgICB0aGlzLl91c2VyU2Vzc2lvbkNoYW5nZWQgPSBuZXcgRXZlbnQoXCJVc2VyIHNlc3Npb24gY2hhbmdlZFwiKTtcbiAgICB9XG5cbiAgICBsb2FkKHVzZXIsIHJhaXNlRXZlbnQ9dHJ1ZSkge1xuICAgICAgICBMb2cuZGVidWcoXCJVc2VyTWFuYWdlckV2ZW50cy5sb2FkXCIpO1xuICAgICAgICBzdXBlci5sb2FkKHVzZXIpO1xuICAgICAgICBpZiAocmFpc2VFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5fdXNlckxvYWRlZC5yYWlzZSh1c2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmxvYWQoKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIlVzZXJNYW5hZ2VyRXZlbnRzLnVubG9hZFwiKTtcbiAgICAgICAgc3VwZXIudW5sb2FkKCk7XG4gICAgICAgIHRoaXMuX3VzZXJVbmxvYWRlZC5yYWlzZSgpO1xuICAgIH1cblxuICAgIGFkZFVzZXJMb2FkZWQoY2IpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvYWRlZC5hZGRIYW5kbGVyKGNiKTtcbiAgICB9XG4gICAgcmVtb3ZlVXNlckxvYWRlZChjYikge1xuICAgICAgICB0aGlzLl91c2VyTG9hZGVkLnJlbW92ZUhhbmRsZXIoY2IpO1xuICAgIH1cbiAgICBcbiAgICBhZGRVc2VyVW5sb2FkZWQoY2IpIHtcbiAgICAgICAgdGhpcy5fdXNlclVubG9hZGVkLmFkZEhhbmRsZXIoY2IpO1xuICAgIH1cbiAgICByZW1vdmVVc2VyVW5sb2FkZWQoY2IpIHtcbiAgICAgICAgdGhpcy5fdXNlclVubG9hZGVkLnJlbW92ZUhhbmRsZXIoY2IpO1xuICAgIH1cblxuICAgIGFkZFNpbGVudFJlbmV3RXJyb3IoY2IpIHtcbiAgICAgICAgdGhpcy5fc2lsZW50UmVuZXdFcnJvci5hZGRIYW5kbGVyKGNiKTtcbiAgICB9XG4gICAgcmVtb3ZlU2lsZW50UmVuZXdFcnJvcihjYikge1xuICAgICAgICB0aGlzLl9zaWxlbnRSZW5ld0Vycm9yLnJlbW92ZUhhbmRsZXIoY2IpO1xuICAgIH1cbiAgICBfcmFpc2VTaWxlbnRSZW5ld0Vycm9yKGUpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiVXNlck1hbmFnZXJFdmVudHMuX3JhaXNlU2lsZW50UmVuZXdFcnJvclwiLCBlLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9zaWxlbnRSZW5ld0Vycm9yLnJhaXNlKGUpO1xuICAgIH1cblxuICAgIGFkZFVzZXJTaWduZWRPdXQoY2IpIHtcbiAgICAgICAgdGhpcy5fdXNlclNpZ25lZE91dC5hZGRIYW5kbGVyKGNiKTtcbiAgICB9XG4gICAgcmVtb3ZlVXNlclNpZ25lZE91dChjYikge1xuICAgICAgICB0aGlzLl91c2VyU2lnbmVkT3V0LnJlbW92ZUhhbmRsZXIoY2IpO1xuICAgIH1cbiAgICBfcmFpc2VVc2VyU2lnbmVkT3V0KGUpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiVXNlck1hbmFnZXJFdmVudHMuX3JhaXNlVXNlclNpZ25lZE91dFwiKTtcbiAgICAgICAgdGhpcy5fdXNlclNpZ25lZE91dC5yYWlzZShlKTtcbiAgICB9XG5cbiAgICBhZGRVc2VyU2Vzc2lvbkNoYW5nZWQoY2IpIHtcbiAgICAgICAgdGhpcy5fdXNlclNlc3Npb25DaGFuZ2VkLmFkZEhhbmRsZXIoY2IpO1xuICAgIH1cbiAgICByZW1vdmVVc2VyU2Vzc2lvbkNoYW5nZWQoY2IpIHtcbiAgICAgICAgdGhpcy5fdXNlclNlc3Npb25DaGFuZ2VkLnJlbW92ZUhhbmRsZXIoY2IpO1xuICAgIH1cbiAgICBfcmFpc2VVc2VyU2Vzc2lvbkNoYW5nZWQoZSkge1xuICAgICAgICBMb2cuZGVidWcoXCJVc2VyTWFuYWdlckV2ZW50cy5fcmFpc2VVc2VyU2Vzc2lvbkNoYW5nZWRcIik7XG4gICAgICAgIHRoaXMuX3VzZXJTZXNzaW9uQ2hhbmdlZC5yYWlzZShlKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvVXNlck1hbmFnZXJFdmVudHMuanMiLCIvLyBDb3B5cmlnaHQgKGMpIEJyb2NrIEFsbGVuICYgRG9taW5pY2sgQmFpZXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTElDRU5TRSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG5pbXBvcnQgTG9nIGZyb20gJy4vTG9nJztcbmltcG9ydCBUaW1lciBmcm9tICcuL1RpbWVyJztcblxuY29uc3QgRGVmYXVsdEFjY2Vzc1Rva2VuRXhwaXJpbmdOb3RpZmljYXRpb25UaW1lID0gNjA7IC8vIHNlY29uZHNcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWNjZXNzVG9rZW5FdmVudHMge1xuXG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBhY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZSA9IERlZmF1bHRBY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZSxcbiAgICAgICAgYWNjZXNzVG9rZW5FeHBpcmluZ1RpbWVyID0gbmV3IFRpbWVyKFwiQWNjZXNzIHRva2VuIGV4cGlyaW5nXCIpLFxuICAgICAgICBhY2Nlc3NUb2tlbkV4cGlyZWRUaW1lciA9IG5ldyBUaW1lcihcIkFjY2VzcyB0b2tlbiBleHBpcmVkXCIpXG4gICAgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2FjY2Vzc1Rva2VuRXhwaXJpbmdOb3RpZmljYXRpb25UaW1lID0gYWNjZXNzVG9rZW5FeHBpcmluZ05vdGlmaWNhdGlvblRpbWU7XG5cbiAgICAgICAgdGhpcy5fYWNjZXNzVG9rZW5FeHBpcmluZyA9IGFjY2Vzc1Rva2VuRXhwaXJpbmdUaW1lcjtcbiAgICAgICAgdGhpcy5fYWNjZXNzVG9rZW5FeHBpcmVkID0gYWNjZXNzVG9rZW5FeHBpcmVkVGltZXI7XG4gICAgfVxuXG4gICAgbG9hZChjb250YWluZXIpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiQWNjZXNzVG9rZW5FdmVudHMubG9hZFwiKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2NhbmNlbFRpbWVycygpO1xuXG4gICAgICAgIC8vIG9ubHkgcmVnaXN0ZXIgZXZlbnRzIGlmIHRoZXJlJ3MgYW4gYWNjZXNzIHRva2VuIHdoZXJlIHdlIGNhcmUgYWJvdXQgZXhwaXJhdGlvblxuICAgICAgICBpZiAoY29udGFpbmVyLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgbGV0IGR1cmF0aW9uID0gY29udGFpbmVyLmV4cGlyZXNfaW47XG4gICAgICAgICAgICBMb2cuZGVidWcoXCJhY2Nlc3MgdG9rZW4gcHJlc2VudCwgcmVtYWluaW5nIGR1cmF0aW9uOlwiLCBkdXJhdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHJlZ2lzdGVyIGV4cGlyaW5nIGlmIHdlIHN0aWxsIGhhdmUgdGltZVxuICAgICAgICAgICAgICAgIGxldCBleHBpcmluZyA9IGR1cmF0aW9uIC0gdGhpcy5fYWNjZXNzVG9rZW5FeHBpcmluZ05vdGlmaWNhdGlvblRpbWU7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGlyaW5nIDw9IDApe1xuICAgICAgICAgICAgICAgICAgICBleHBpcmluZyA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIExvZy5kZWJ1ZyhcInJlZ2lzdGVyaW5nIGV4cGlyaW5nIHRpbWVyIGluOlwiLCBleHBpcmluZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWNjZXNzVG9rZW5FeHBpcmluZy5pbml0KGV4cGlyaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWx3YXlzIHJlZ2lzdGVyIGV4cGlyZWQuIGlmIGl0J3MgbmVnYXRpdmUsIGl0IHdpbGwgc3RpbGwgZmlyZVxuICAgICAgICAgICAgbGV0IGV4cGlyZWQgPSBkdXJhdGlvbiArIDE7XG4gICAgICAgICAgICBMb2cuZGVidWcoXCJyZWdpc3RlcmluZyBleHBpcmVkIHRpbWVyIGluOlwiLCBleHBpcmVkKTtcbiAgICAgICAgICAgIHRoaXMuX2FjY2Vzc1Rva2VuRXhwaXJlZC5pbml0KGV4cGlyZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdW5sb2FkKCkge1xuICAgICAgICBMb2cuZGVidWcoXCJBY2Nlc3NUb2tlbkV2ZW50cy51bmxvYWRcIik7XG4gICAgICAgIHRoaXMuX2NhbmNlbFRpbWVycygpO1xuICAgIH1cbiAgICBcbiAgICBfY2FuY2VsVGltZXJzKCl7XG4gICAgICAgIExvZy5kZWJ1ZyhcImNhbmNlbGluZyBleGlzdGluZyBhY2Nlc3MgdG9rZW4gdGltZXJzXCIpO1xuICAgICAgICB0aGlzLl9hY2Nlc3NUb2tlbkV4cGlyaW5nLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLl9hY2Nlc3NUb2tlbkV4cGlyZWQuY2FuY2VsKCk7XG4gICAgfVxuXG4gICAgYWRkQWNjZXNzVG9rZW5FeHBpcmluZyhjYikge1xuICAgICAgICB0aGlzLl9hY2Nlc3NUb2tlbkV4cGlyaW5nLmFkZEhhbmRsZXIoY2IpO1xuICAgIH1cbiAgICByZW1vdmVBY2Nlc3NUb2tlbkV4cGlyaW5nKGNiKSB7XG4gICAgICAgIHRoaXMuX2FjY2Vzc1Rva2VuRXhwaXJpbmcucmVtb3ZlSGFuZGxlcihjYik7XG4gICAgfVxuXG4gICAgYWRkQWNjZXNzVG9rZW5FeHBpcmVkKGNiKSB7XG4gICAgICAgIHRoaXMuX2FjY2Vzc1Rva2VuRXhwaXJlZC5hZGRIYW5kbGVyKGNiKTtcbiAgICB9XG4gICAgcmVtb3ZlQWNjZXNzVG9rZW5FeHBpcmVkKGNiKSB7XG4gICAgICAgIHRoaXMuX2FjY2Vzc1Rva2VuRXhwaXJlZC5yZW1vdmVIYW5kbGVyKGNiKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQWNjZXNzVG9rZW5FdmVudHMuanMiLCIvLyBDb3B5cmlnaHQgKGMpIEJyb2NrIEFsbGVuICYgRG9taW5pY2sgQmFpZXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTElDRU5TRSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG5pbXBvcnQgTG9nIGZyb20gJy4vTG9nJztcbmltcG9ydCBHbG9iYWwgZnJvbSAnLi9HbG9iYWwnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4vRXZlbnQnO1xuXG5jb25zdCBUaW1lckR1cmF0aW9uID0gNTsgLy8gc2Vjb25kc1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciBleHRlbmRzIEV2ZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHRpbWVyID0gR2xvYmFsLnRpbWVyKSB7XG4gICAgICAgIHN1cGVyKG5hbWUpO1xuICAgICAgICB0aGlzLl90aW1lciA9IHRpbWVyO1xuICAgICAgICB0aGlzLl9ub3dGdW5jID0gKCkgPT4gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgfVxuXG4gICAgZ2V0IG5vdygpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuX25vd0Z1bmMoKSk7XG4gICAgfVxuXG4gICAgaW5pdChkdXJhdGlvbikge1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuXG4gICAgICAgIGlmIChkdXJhdGlvbiA8PSAwKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZHVyYXRpb24gPSBwYXJzZUludChkdXJhdGlvbik7XG5cbiAgICAgICAgTG9nLmRlYnVnKFwiVGltZXIuaW5pdCB0aW1lciBcIiArIHRoaXMuX25hbWUgKyBcIiBmb3IgZHVyYXRpb246XCIsIGR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5fZXhwaXJhdGlvbiA9IHRoaXMubm93ICsgZHVyYXRpb247XG5cbiAgICAgICAgLy8gd2UncmUgdXNpbmcgYSBmYWlybHkgc2hvcnQgdGltZXIgYW5kIHRoZW4gY2hlY2tpbmcgdGhlIGV4cGlyYXRpb24gaW4gdGhlIFxuICAgICAgICAvLyBjYWxsYmFjayB0byBoYW5kbGUgc2NlbmFyaW9zIHdoZXJlIHRoZSBicm93c2VyIGRldmljZSBzbGVlcHMsIGFuZCB0aGVuIFxuICAgICAgICAvLyB0aGUgdGltZXJzIGVuZCB1cCBnZXR0aW5nIGRlbGF5ZWQuXG4gICAgICAgIHZhciB0aW1lckR1cmF0aW9uID0gVGltZXJEdXJhdGlvbjtcbiAgICAgICAgaWYgKGR1cmF0aW9uIDwgdGltZXJEdXJhdGlvbikge1xuICAgICAgICAgICAgdGltZXJEdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RpbWVySGFuZGxlID0gdGhpcy5fdGltZXIuc2V0SW50ZXJ2YWwodGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKSwgdGltZXJEdXJhdGlvbiAqIDEwMDApO1xuICAgIH1cblxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVySGFuZGxlKSB7XG4gICAgICAgICAgICBMb2cuZGVidWcoXCJUaW1lci5jYW5jZWw6IFwiLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyLmNsZWFySW50ZXJ2YWwodGhpcy5fdGltZXJIYW5kbGUpO1xuICAgICAgICAgICAgdGhpcy5fdGltZXJIYW5kbGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NhbGxiYWNrKCkge1xuICAgICAgICB2YXIgZGlmZiA9IHRoaXMuX2V4cGlyYXRpb24gLSB0aGlzLm5vdztcbiAgICAgICAgTG9nLmRlYnVnKFwiVGltZXIuX2NhbGxiYWNrOyBcIiArIHRoaXMuX25hbWUgKyBcIiB0aW1lciBleHBpcmVzIGluOlwiLCBkaWZmKTtcblxuICAgICAgICBpZiAodGhpcy5fZXhwaXJhdGlvbiA8PSB0aGlzLm5vdykge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgIHN1cGVyLnJhaXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvVGltZXIuanMiLCIvLyBDb3B5cmlnaHQgKGMpIEJyb2NrIEFsbGVuICYgRG9taW5pY2sgQmFpZXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTElDRU5TRSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG5pbXBvcnQgTG9nIGZyb20gJy4vTG9nJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnQge1xuXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gW107XG4gICAgfVxuXG4gICAgYWRkSGFuZGxlcihjYikge1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYik7XG4gICAgfVxuXG4gICAgcmVtb3ZlSGFuZGxlcihjYikge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5fY2FsbGJhY2tzLmZpbmRJbmRleChpdGVtID0+IGl0ZW0gPT09IGNiKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3Muc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByYWlzZSguLi5wYXJhbXMpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiUmFpc2luZyBldmVudDogXCIgKyB0aGlzLl9uYW1lKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9jYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrc1tpXSguLi5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0V2ZW50LmpzIiwiLy8gQ29weXJpZ2h0IChjKSBCcm9jayBBbGxlbiAmIERvbWluaWNrIEJhaWVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuaW1wb3J0IExvZyBmcm9tICcuL0xvZyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpbGVudFJlbmV3U2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcih1c2VyTWFuYWdlcikge1xuICAgICAgICB0aGlzLl91c2VyTWFuYWdlciA9IHVzZXJNYW5hZ2VyO1xuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFjayA9IHRoaXMuX3Rva2VuRXhwaXJpbmcuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5hZGRBY2Nlc3NUb2tlbkV4cGlyaW5nKHRoaXMuX2NhbGxiYWNrKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHRyaWdnZXIgbG9hZGluZyBvZiB0aGUgdXNlciBzbyB0aGUgZXhwaXJpbmcgZXZlbnRzIGNhbiBiZSBpbml0aWFsaXplZFxuICAgICAgICAgICAgdGhpcy5fdXNlck1hbmFnZXIuZ2V0VXNlcigpLnRoZW4odXNlcj0+e1xuICAgICAgICAgICAgICAgIC8vIGRlbGliZXJhdGUgbm9wXG4gICAgICAgICAgICB9KS5jYXRjaChlcnI9PntcbiAgICAgICAgICAgICAgICAvLyBjYXRjaCB0byBzdXBwcmVzcyBlcnJvcnMgc2luY2Ugd2UncmUgaW4gYSBjdG9yXG4gICAgICAgICAgICAgICAgTG9nLmVycm9yKFwiRXJyb3IgZnJvbSBnZXRVc2VyOlwiLCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fdXNlck1hbmFnZXIuZXZlbnRzLnJlbW92ZUFjY2Vzc1Rva2VuRXhwaXJpbmcodGhpcy5fY2FsbGJhY2spO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3Rva2VuRXhwaXJpbmcoKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIlNpbGVudFJlbmV3U2VydmljZSBhdXRvbWF0aWNhbGx5IHJlbmV3aW5nIGFjY2VzcyB0b2tlblwiKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3VzZXJNYW5hZ2VyLnNpZ25pblNpbGVudCgpLnRoZW4odXNlciA9PiB7XG4gICAgICAgICAgICBMb2cuZGVidWcoXCJTaWxlbnQgdG9rZW4gcmVuZXdhbCBzdWNjZXNzZnVsXCIpO1xuICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiRXJyb3IgZnJvbSBzaWduaW5TaWxlbnQ6XCIsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5fcmFpc2VTaWxlbnRSZW5ld0Vycm9yKGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TaWxlbnRSZW5ld1NlcnZpY2UuanMiLCIvLyBDb3B5cmlnaHQgKGMpIEJyb2NrIEFsbGVuICYgRG9taW5pY2sgQmFpZXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTElDRU5TRSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG5pbXBvcnQgTG9nIGZyb20gJy4vTG9nJztcbmltcG9ydCBDaGVja1Nlc3Npb25JRnJhbWUgZnJvbSAnLi9DaGVja1Nlc3Npb25JRnJhbWUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXNzaW9uTW9uaXRvciB7XG5cbiAgICBjb25zdHJ1Y3Rvcih1c2VyTWFuYWdlciwgQ2hlY2tTZXNzaW9uSUZyYW1lQ3RvciA9IENoZWNrU2Vzc2lvbklGcmFtZSkge1xuICAgICAgICBpZiAoIXVzZXJNYW5hZ2VyKSB7XG4gICAgICAgICAgICBMb2cuZXJyb3IoXCJObyB1c2VyIG1hbmFnZXIgcGFzc2VkIHRvIFNlc3Npb25Nb25pdG9yXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXNlck1hbmFnZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91c2VyTWFuYWdlciA9IHVzZXJNYW5hZ2VyO1xuICAgICAgICB0aGlzLl9DaGVja1Nlc3Npb25JRnJhbWVDdG9yID0gQ2hlY2tTZXNzaW9uSUZyYW1lQ3RvcjtcblxuICAgICAgICB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMuYWRkVXNlckxvYWRlZCh0aGlzLl9zdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fdXNlck1hbmFnZXIuZXZlbnRzLmFkZFVzZXJVbmxvYWRlZCh0aGlzLl9zdG9wLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuX3VzZXJNYW5hZ2VyLmdldFVzZXIoKS50aGVuKHVzZXIgPT4ge1xuICAgICAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCh1c2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIC8vIGNhdGNoIHRvIHN1cHByZXNzIGVycm9ycyBzaW5jZSB3ZSdyZSBpbiBhIGN0b3JcbiAgICAgICAgICAgIExvZy5lcnJvcihcIlNlc3Npb25Nb25pdG9yIGN0b3I7IGVycm9yIGZyb20gZ2V0VXNlcjpcIiwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXQgX3NldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlck1hbmFnZXIuc2V0dGluZ3M7XG4gICAgfVxuICAgIGdldCBfbWV0YWRhdGFTZXJ2aWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlck1hbmFnZXIubWV0YWRhdGFTZXJ2aWNlO1xuICAgIH1cbiAgICBnZXQgX2NsaWVudF9pZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLmNsaWVudF9pZDtcbiAgICB9XG4gICAgZ2V0IF9jaGVja1Nlc3Npb25JbnRlcnZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLmNoZWNrU2Vzc2lvbkludGVydmFsO1xuICAgIH1cblxuICAgIF9zdGFydCh1c2VyKSB7XG4gICAgICAgIGxldCBzZXNzaW9uX3N0YXRlID0gdXNlci5zZXNzaW9uX3N0YXRlO1xuXG4gICAgICAgIGlmIChzZXNzaW9uX3N0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWIgPSB1c2VyLnByb2ZpbGUuc3ViO1xuICAgICAgICAgICAgdGhpcy5fc2lkID0gdXNlci5wcm9maWxlLnNpZDtcbiAgICAgICAgICAgIExvZy5kZWJ1ZyhcIlNlc3Npb25Nb25pdG9yLl9zdGFydDsgc2Vzc2lvbl9zdGF0ZTpcIiwgc2Vzc2lvbl9zdGF0ZSwgXCIsIHN1YjpcIiwgdGhpcy5fc3ViKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jaGVja1Nlc3Npb25JRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXRhZGF0YVNlcnZpY2UuZ2V0Q2hlY2tTZXNzaW9uSWZyYW1lKCkudGhlbih1cmwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJJbml0aWFsaXppbmcgY2hlY2sgc2Vzc2lvbiBpZnJhbWVcIilcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNsaWVudF9pZCA9IHRoaXMuX2NsaWVudF9pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbnRlcnZhbCA9IHRoaXMuX2NoZWNrU2Vzc2lvbkludGVydmFsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Nlc3Npb25JRnJhbWUgPSBuZXcgdGhpcy5fQ2hlY2tTZXNzaW9uSUZyYW1lQ3Rvcih0aGlzLl9jYWxsYmFjay5iaW5kKHRoaXMpLCBjbGllbnRfaWQsIHVybCwgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lLmxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Nlc3Npb25JRnJhbWUuc3RhcnQoc2Vzc2lvbl9zdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZy53YXJuKFwiTm8gY2hlY2sgc2Vzc2lvbiBpZnJhbWUgZm91bmQgaW4gdGhlIG1ldGFkYXRhXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2F0Y2ggdG8gc3VwcHJlc3MgZXJyb3JzIHNpbmNlIHdlJ3JlIGluIG5vbi1wcm9taXNlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIExvZy5lcnJvcihcIkVycm9yIGZyb20gZ2V0Q2hlY2tTZXNzaW9uSWZyYW1lOlwiLCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Nlc3Npb25JRnJhbWUuc3RhcnQoc2Vzc2lvbl9zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc3RvcCgpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiU2Vzc2lvbk1vbml0b3IuX3N0b3BcIik7XG5cbiAgICAgICAgdGhpcy5fc3ViID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2lkID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Nlc3Npb25JRnJhbWUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NhbGxiYWNrKCkge1xuICAgICAgICBMb2cuZGVidWcoXCJTZXNzaW9uTW9uaXRvci5fY2FsbGJhY2tcIik7XG5cbiAgICAgICAgdGhpcy5fdXNlck1hbmFnZXIucXVlcnlTZXNzaW9uU3RhdHVzKCkudGhlbihzZXNzaW9uID0+IHtcbiAgICAgICAgICAgIHZhciByYWlzZVVzZXJTaWduZWRPdXRFdmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uc3ViID09PSB0aGlzLl9zdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFpc2VVc2VyU2lnbmVkT3V0RXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lLnN0YXJ0KHNlc3Npb24uc2Vzc2lvbl9zdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uc2lkID09PSB0aGlzLl9zaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZy5kZWJ1ZyhcIlNhbWUgc3ViIHN0aWxsIGxvZ2dlZCBpbiBhdCBPUCwgcmVzdGFydGluZyBjaGVjayBzZXNzaW9uIGlmcmFtZTsgc2Vzc2lvbl9zdGF0ZTpcIiwgc2Vzc2lvbi5zZXNzaW9uX3N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZy5kZWJ1ZyhcIlNhbWUgc3ViIHN0aWxsIGxvZ2dlZCBpbiBhdCBPUCwgc2Vzc2lvbiBzdGF0ZSBoYXMgY2hhbmdlZCwgcmVzdGFydGluZyBjaGVjayBzZXNzaW9uIGlmcmFtZTsgc2Vzc2lvbl9zdGF0ZTpcIiwgc2Vzc2lvbi5zZXNzaW9uX3N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5fcmFpc2VVc2VyU2Vzc2lvbkNoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nLmRlYnVnKFwiRGlmZmVyZW50IHN1YmplY3Qgc2lnbmVkIGludG8gT1A6XCIsIHNlc3Npb24uc3ViKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJTdWJqZWN0IG5vIGxvbmdlciBzaWduZWQgaW50byBPUFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJhaXNlVXNlclNpZ25lZE91dEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgTG9nLmRlYnVnKFwiU2Vzc2lvbk1vbml0b3IuX2NhbGxiYWNrOyByYWlzaW5nIHNpZ25lZCBvdXQgZXZlbnRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlck1hbmFnZXIuZXZlbnRzLl9yYWlzZVVzZXJTaWduZWRPdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIExvZy5kZWJ1ZyhcIkVycm9yIGNhbGxpbmcgcXVlcnlDdXJyZW50U2lnbmluU2Vzc2lvbjsgcmFpc2luZyBzaWduZWQgb3V0IGV2ZW50XCIsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5fcmFpc2VVc2VyU2lnbmVkT3V0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TZXNzaW9uTW9uaXRvci5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBMb2cgZnJvbSAnLi9Mb2cnO1xuXG5jb25zdCBEZWZhdWx0SW50ZXJ2YWwgPSAyMDAwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGVja1Nlc3Npb25JRnJhbWUge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBjbGllbnRfaWQsIHVybCwgaW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5fY2xpZW50X2lkID0gY2xpZW50X2lkO1xuICAgICAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gaW50ZXJ2YWwgfHwgRGVmYXVsdEludGVydmFsO1xuXG4gICAgICAgIHZhciBpZHggPSB1cmwuaW5kZXhPZihcIi9cIiwgdXJsLmluZGV4T2YoXCIvL1wiKSArIDIpO1xuICAgICAgICB0aGlzLl9mcmFtZV9vcmlnaW4gPSB1cmwuc3Vic3RyKDAsIGlkeCk7XG5cbiAgICAgICAgdGhpcy5fZnJhbWUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcblxuICAgICAgICAvLyBzaG90Z3VuIGFwcHJvYWNoXG4gICAgICAgIHRoaXMuX2ZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICB0aGlzLl9mcmFtZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgdGhpcy5fZnJhbWUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB0aGlzLl9mcmFtZS5zdHlsZS53aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX2ZyYW1lLnN0eWxlLmhlaWdodCA9IDA7XG5cbiAgICAgICAgdGhpcy5fZnJhbWUuc3JjID0gdXJsO1xuICAgIH1cbiAgICBsb2FkKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2ZyYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kTWVzc2FnZUV2ZW50ID0gdGhpcy5fbWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX2JvdW5kTWVzc2FnZUV2ZW50LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfbWVzc2FnZShlKSB7XG4gICAgICAgIGlmIChlLm9yaWdpbiA9PT0gdGhpcy5fZnJhbWVfb3JpZ2luICYmXG4gICAgICAgICAgICBlLnNvdXJjZSA9PT0gdGhpcy5fZnJhbWUuY29udGVudFdpbmRvd1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChlLmRhdGEgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgIExvZy5lcnJvcihcImVycm9yIG1lc3NhZ2UgZnJvbSBjaGVjayBzZXNzaW9uIG9wIGlmcmFtZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUuZGF0YSA9PT0gXCJjaGFuZ2VkXCIpIHtcbiAgICAgICAgICAgICAgICBMb2cuZGVidWcoXCJjaGFuZ2VkIG1lc3NhZ2UgZnJvbSBjaGVjayBzZXNzaW9uIG9wIGlmcmFtZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgTG9nLmRlYnVnKGUuZGF0YSArIFwiIG1lc3NhZ2UgZnJvbSBjaGVjayBzZXNzaW9uIG9wIGlmcmFtZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydChzZXNzaW9uX3N0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZXNzaW9uX3N0YXRlICE9PSBzZXNzaW9uX3N0YXRlKSB7XG4gICAgICAgICAgICBMb2cuZGVidWcoXCJDaGVja1Nlc3Npb25JRnJhbWUuc3RhcnRcIik7XG5cbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgICAgICB0aGlzLl9zZXNzaW9uX3N0YXRlID0gc2Vzc2lvbl9zdGF0ZTtcblxuICAgICAgICAgICAgdGhpcy5fdGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UodGhpcy5fY2xpZW50X2lkICsgXCIgXCIgKyB0aGlzLl9zZXNzaW9uX3N0YXRlLCB0aGlzLl9mcmFtZV9vcmlnaW4pO1xuICAgICAgICAgICAgfSwgdGhpcy5faW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RvcCgpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiQ2hlY2tTZXNzaW9uSUZyYW1lLnN0b3BcIik7XG5cbiAgICAgICAgdGhpcy5fc2Vzc2lvbl9zdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuX3RpbWVyKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLl90aW1lcik7XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQ2hlY2tTZXNzaW9uSUZyYW1lLmpzIiwiLy8gQ29weXJpZ2h0IChjKSBCcm9jayBBbGxlbiAmIERvbWluaWNrIEJhaWVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuaW1wb3J0IExvZyBmcm9tICcuL0xvZyc7XG5pbXBvcnQgTWV0YWRhdGFTZXJ2aWNlIGZyb20gJy4vTWV0YWRhdGFTZXJ2aWNlJztcbmltcG9ydCBHbG9iYWwgZnJvbSAnLi9HbG9iYWwnO1xuXG5jb25zdCBBY2Nlc3NUb2tlblR5cGVIaW50ID0gXCJhY2Nlc3NfdG9rZW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9rZW5SZXZvY2F0aW9uQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncywgWE1MSHR0cFJlcXVlc3RDdG9yID0gR2xvYmFsLlhNTEh0dHBSZXF1ZXN0LCBNZXRhZGF0YVNlcnZpY2VDdG9yID0gTWV0YWRhdGFTZXJ2aWNlKSB7XG4gICAgICAgIGlmICghc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIExvZy5lcnJvcihcIk5vIHNldHRpbmdzIHByb3ZpZGVkXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2V0dGluZ3MgcHJvdmlkZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLl9YTUxIdHRwUmVxdWVzdEN0b3IgPSBYTUxIdHRwUmVxdWVzdEN0b3I7XG4gICAgICAgIHRoaXMuX21ldGFkYXRhU2VydmljZSA9IG5ldyBNZXRhZGF0YVNlcnZpY2VDdG9yKHRoaXMuX3NldHRpbmdzKTtcbiAgICB9XG5cbiAgICByZXZva2UoYWNjZXNzVG9rZW4sIHJlcXVpcmVkKSB7XG4gICAgICAgIExvZy5kZWJ1ZyhcIlRva2VuUmV2b2NhdGlvbkNsaWVudC5yZXZva2VcIik7XG5cbiAgICAgICAgaWYgKCFhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgTG9nLmVycm9yKFwiTm8gYWNjZXNzVG9rZW4gcHJvdmlkZWRcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhY2Nlc3NUb2tlbiBwcm92aWRlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGFTZXJ2aWNlLmdldFJldm9jYXRpb25FbmRwb2ludCgpLnRoZW4odXJsID0+IHtcbiAgICAgICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZy5lcnJvcihcIlJldm9jYXRpb24gbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmV2b2NhdGlvbiBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG5vdCByZXF1aXJlZCwgc28gZG9uJ3QgZXJyb3IgYW5kIGp1c3QgcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2xpZW50X2lkID0gdGhpcy5fc2V0dGluZ3MuY2xpZW50X2lkO1xuICAgICAgICAgICAgdmFyIGNsaWVudF9zZWNyZXQgPSB0aGlzLl9zZXR0aW5ncy5jbGllbnRfc2VjcmV0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jldm9rZSh1cmwsIGNsaWVudF9pZCwgY2xpZW50X3NlY3JldCwgYWNjZXNzVG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfcmV2b2tlKHVybCwgY2xpZW50X2lkLCBjbGllbnRfc2VjcmV0LCBhY2Nlc3NUb2tlbikge1xuICAgICAgICBMb2cuZGVidWcoXCJDYWxsaW5nIHJldm9jYXRpb24gZW5kcG9pbnRcIik7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgdmFyIHhociA9IG5ldyB0aGlzLl9YTUxIdHRwUmVxdWVzdEN0b3IoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKFwiUE9TVFwiLCB1cmwpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB4aHIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIExvZy5kZWJ1ZyhcIkhUVFAgcmVzcG9uc2UgcmVjZWl2ZWQsIHN0YXR1c1wiLCB4aHIuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChFcnJvcih4aHIuc3RhdHVzVGV4dCArIFwiIChcIiArIHhoci5zdGF0dXMgKyBcIilcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBib2R5ID0gXCJjbGllbnRfaWQ9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoY2xpZW50X2lkKTsgXG4gICAgICAgICAgICBpZiAoY2xpZW50X3NlY3JldCkge1xuICAgICAgICAgICAgICAgIGJvZHkgKz0gXCImY2xpZW50X3NlY3JldD1cIiArIGVuY29kZVVSSUNvbXBvbmVudChjbGllbnRfc2VjcmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHkgKz0gXCImdG9rZW5fdHlwZV9oaW50PVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KEFjY2Vzc1Rva2VuVHlwZUhpbnQpO1xuICAgICAgICAgICAgYm9keSArPSBcIiZ0b2tlbj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChhY2Nlc3NUb2tlbik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpO1xuICAgICAgICAgICAgeGhyLnNlbmQoYm9keSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Ub2tlblJldm9jYXRpb25DbGllbnQuanMiLCIvLyBDb3B5cmlnaHQgKGMpIEJyb2NrIEFsbGVuICYgRG9taW5pY2sgQmFpZXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTElDRU5TRSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG5pbXBvcnQgTG9nIGZyb20gJy4vTG9nJztcbmltcG9ydCBDb3Jkb3ZhUG9wdXBXaW5kb3cgZnJvbSAnLi9Db3Jkb3ZhUG9wdXBXaW5kb3cnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb3Jkb3ZhUG9wdXBOYXZpZ2F0b3Ige1xuICAgIFxuICAgIHByZXBhcmUocGFyYW1zKSB7XG4gICAgICAgIGxldCBwb3B1cCA9IG5ldyBDb3Jkb3ZhUG9wdXBXaW5kb3cocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwb3B1cCk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0NvcmRvdmFQb3B1cE5hdmlnYXRvci5qcyIsIi8vIENvcHlyaWdodCAoYykgQnJvY2sgQWxsZW4gJiBEb21pbmljayBCYWllci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBMb2cgZnJvbSAnLi9Mb2cnO1xuXG5jb25zdCBEZWZhdWx0UG9wdXBGZWF0dXJlcyA9ICdsb2NhdGlvbj1ubyx0b29sYmFyPW5vLHpvb209bm8nO1xuY29uc3QgRGVmYXVsdFBvcHVwVGFyZ2V0ID0gXCJfYmxhbmtcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29yZG92YVBvcHVwV2luZG93IHtcblxuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBMb2cuZGVidWcoXCJDb3Jkb3ZhUG9wdXBXaW5kb3cuY3RvclwiKTtcblxuICAgICAgICB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBwYXJhbXMucG9wdXBXaW5kb3dGZWF0dXJlcyB8fCBEZWZhdWx0UG9wdXBGZWF0dXJlcztcbiAgICAgICAgdGhpcy50YXJnZXQgPSBwYXJhbXMucG9wdXBXaW5kb3dUYXJnZXQgfHwgRGVmYXVsdFBvcHVwVGFyZ2V0O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5yZWRpcmVjdF91cmkgPSBwYXJhbXMuc3RhcnRVcmw7XG4gICAgICAgIExvZy5kZWJ1ZyhcInJlZGlyZWN0X3VyaTogXCIgKyB0aGlzLnJlZGlyZWN0X3VyaSk7XG4gICAgfVxuXG4gICAgX2lzSW5BcHBCcm93c2VySW5zdGFsbGVkKGNvcmRvdmFNZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gW1wiY29yZG92YS1wbHVnaW4taW5hcHBicm93c2VyXCIsIFwiY29yZG92YS1wbHVnaW4taW5hcHBicm93c2VyLmluYXBwYnJvd3NlclwiLCBcIm9yZy5hcGFjaGUuY29yZG92YS5pbmFwcGJyb3dzZXJcIl0uc29tZShmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcmRvdmFNZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgICB9KVxuICAgIH1cbiAgICBcbiAgICBuYXZpZ2F0ZShwYXJhbXMpIHtcbiAgICAgICAgTG9nLmRlYnVnKFwiQ29yZG92YVBvcHVwV2luZG93Lm5hdmlnYXRlXCIpO1xuXG4gICAgICAgIGlmICghcGFyYW1zIHx8ICFwYXJhbXMudXJsKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihcIk5vIHVybCBwcm92aWRlZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghd2luZG93LmNvcmRvdmEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3IoXCJjb3Jkb3ZhIGlzIHVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgY29yZG92YU1ldGFkYXRhID0gd2luZG93LmNvcmRvdmEucmVxdWlyZShcImNvcmRvdmEvcGx1Z2luX2xpc3RcIikubWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNJbkFwcEJyb3dzZXJJbnN0YWxsZWQoY29yZG92YU1ldGFkYXRhKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3IoXCJJbkFwcEJyb3dzZXIgcGx1Z2luIG5vdCBmb3VuZFwiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcG9wdXAgPSBjb3Jkb3ZhLkluQXBwQnJvd3Nlci5vcGVuKHBhcmFtcy51cmwsIHRoaXMudGFyZ2V0LCB0aGlzLmZlYXR1cmVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wb3B1cCkge1xuICAgICAgICAgICAgICAgIExvZy5kZWJ1ZyhcInBvcHVwIHN1Y2Nlc3NmdWxseSBjcmVhdGVkXCIpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuX2V4aXRDYWxsYmFja0V2ZW50ID0gdGhpcy5fZXhpdENhbGxiYWNrLmJpbmQodGhpcyk7IFxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRTdGFydENhbGxiYWNrRXZlbnQgPSB0aGlzLl9sb2FkU3RhcnRDYWxsYmFjay5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVwLmFkZEV2ZW50TGlzdGVuZXIoXCJleGl0XCIsIHRoaXMuX2V4aXRDYWxsYmFja0V2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9wdXAuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRzdGFydFwiLCB0aGlzLl9sb2FkU3RhcnRDYWxsYmFja0V2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yKFwiRXJyb3Igb3BlbmluZyBwb3B1cCB3aW5kb3dcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgICB9XG5cbiAgICBnZXQgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gICAgfVxuXG4gICAgX2xvYWRTdGFydENhbGxiYWNrKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC51cmwuaW5kZXhPZih0aGlzLnJlZGlyZWN0X3VyaSkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3N1Y2Nlc3MoeyB1cmw6IGV2ZW50LnVybCB9KTtcbiAgICAgICAgfSAgICBcbiAgICB9XG4gICAgX2V4aXRDYWxsYmFjayhtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Vycm9yKG1lc3NhZ2UpOyAgICBcbiAgICB9XG4gICAgXG4gICAgX3N1Y2Nlc3MoZGF0YSkge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG5cbiAgICAgICAgTG9nLmRlYnVnKFwiU3VjY2Vzc2Z1bCByZXNwb25zZSBmcm9tIGNvcmRvdmEgcG9wdXAgd2luZG93XCIpO1xuICAgICAgICB0aGlzLl9yZXNvbHZlKGRhdGEpO1xuICAgIH1cbiAgICBfZXJyb3IobWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG5cbiAgICAgICAgTG9nLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9yZWplY3QobmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICB9XG5cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIH1cblxuICAgIF9jbGVhbnVwKCkge1xuICAgICAgICBMb2cuZGVidWcoXCJDb3Jkb3ZhUG9wdXBXaW5kb3cuX2NsZWFudXBcIik7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BvcHVwKXtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJleGl0XCIsIHRoaXMuX2V4aXRDYWxsYmFja0V2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZHN0YXJ0XCIsIHRoaXMuX2xvYWRTdGFydENhbGxiYWNrRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9wdXAgPSBudWxsO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Db3Jkb3ZhUG9wdXBXaW5kb3cuanMiLCIvLyBDb3B5cmlnaHQgKGMpIEJyb2NrIEFsbGVuICYgRG9taW5pY2sgQmFpZXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiBTZWUgTElDRU5TRSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG5pbXBvcnQgTG9nIGZyb20gJy4vTG9nJztcbmltcG9ydCBDb3Jkb3ZhUG9wdXBXaW5kb3cgZnJvbSAnLi9Db3Jkb3ZhUG9wdXBXaW5kb3cnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb3Jkb3ZhSUZyYW1lTmF2aWdhdG9yIHtcbiAgICBcbiAgICBwcmVwYXJlKHBhcmFtcykge1xuICAgICAgICBwYXJhbXMucG9wdXBXaW5kb3dGZWF0dXJlcyA9ICdoaWRkZW49eWVzJztcbiAgICAgICAgbGV0IHBvcHVwID0gbmV3IENvcmRvdmFQb3B1cFdpbmRvdyhwYXJhbXMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBvcHVwKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQ29yZG92YUlGcmFtZU5hdmlnYXRvci5qcyJdLCJzb3VyY2VSb290IjoiIn0=